<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Boxing Manager v3.3 - NAME FIX</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Oswald:wght@300;400;600;700&display=swap');
        
        :root {
            --blood-red: #8B0000;
            --ring-red: #C41E3A;
            --gold: #FFD700;
            --dark-bg: #0a0a0a;
            --canvas-white: #F5F5DC;
            --rope-blue: #1E3A8A;
            --steel: #4A5568;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Oswald', sans-serif;
            background: var(--dark-bg);
            color: var(--canvas-white);
            overflow: hidden;
            height: 100vh;
            position: relative;
        }
        
        /* Noise texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0,0,0,.03) 2px,
                    rgba(0,0,0,.03) 4px
                );
            pointer-events: none;
            z-index: 1000;
            opacity: 0.3;
        }
        
        .screen {
            display: none;
            width: 100%;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .screen.active {
            display: flex;
            flex-direction: column;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* LOADING SCREEN */
        #loadingScreen {
            justify-content: center;
            align-items: center;
            background: var(--dark-bg);
        }
        
        .loading-content {
            text-align: center;
            position: relative;
            z-index: 2;
        }
        
        .game-logo {
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(2rem, 8vw, 3rem);
            letter-spacing: 0.2rem;
            margin-bottom: 1rem;
            text-transform: uppercase;
            color: var(--canvas-white);
        }
        
        .game-subtitle {
            font-size: clamp(0.8rem, 3vw, 1rem);
            letter-spacing: 0.3rem;
            color: var(--canvas-white);
            opacity: 0.5;
            font-weight: 300;
        }
        
        .loading-bar-container {
            width: min(250px, 80vw);
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            margin: 2.5rem auto 1rem;
            overflow: hidden;
            position: relative;
        }
        
        .loading-bar {
            height: 100%;
            background: var(--canvas-white);
            animation: loading 2s ease-in-out;
            width: 0%;
        }
        
        @keyframes loading {
            0% { width: 0%; }
            100% { width: 100%; }
        }
        
        .loading-text {
            font-size: clamp(0.8rem, 3vw, 0.9rem);
            opacity: 0.6;
            margin-top: 1rem;
            letter-spacing: 0.2rem;
        }
        
        /* PROLOGUE SCREEN */
        #prologueScreen {
            background: var(--dark-bg);
            padding: 1.5rem;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* Cinematic vignette effect */
        #prologueScreen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.7) 100%);
            pointer-events: none;
        }
        
        .prologue-content {
            max-width: 500px;
            text-align: center;
            position: relative;
            padding: 0 1rem;
            z-index: 1;
        }
        
        .prologue-text {
            font-size: clamp(1.1rem, 4vw, 1.5rem);
            line-height: 2;
            font-weight: 300;
            opacity: 1;
            text-align: center;
        }
        
        .prologue-line {
            opacity: 0;
            transform: translateY(10px);
            display: block;
            margin-bottom: 0.8rem;
        }
        
        .prologue-line.highlight {
            color: var(--gold);
            font-weight: 400;
        }
        
        .prologue-line.fade-in {
            animation: fadeInLine 1.2s ease-out forwards;
        }
        
        @keyframes fadeInLine {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .prologue-highlight {
            color: var(--gold);
            font-weight: 400;
        }
        
        .continue-button {
            margin-top: 2rem;
            padding: 0.9rem 2rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: var(--canvas-white);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            letter-spacing: 0.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        @keyframes fadeInButton {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .continue-button:active {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--gold);
        }
        
        /* CHARACTER CREATION SCREEN */
        #characterScreen {
            padding: 1.5rem;
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .character-header {
            text-align: center;
            margin-bottom: 2.5rem;
        }
        
        .character-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.8rem);
            font-weight: 300;
            letter-spacing: 0.1rem;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .character-subtitle {
            font-size: clamp(0.8rem, 3vw, 0.9rem);
            opacity: 0.5;
            letter-spacing: 0.05rem;
            font-weight: 300;
        }
        
        .form-container {
            max-width: 500px;
            margin: 0 auto;
        }
        
        .form-group {
            margin-bottom: 2rem;
        }
        
        .form-label {
            display: block;
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            letter-spacing: 0.05rem;
            color: var(--canvas-white);
            margin-bottom: 1rem;
            opacity: 0.7;
            font-weight: 300;
        }
        
        .form-input,
        .form-select {
            width: 100%;
            padding: 0.9rem 0.5rem;
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0;
            color: var(--canvas-white);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 4vw, 1.2rem);
            transition: all 0.3s ease;
        }
        
        .form-select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23F5F5DC' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            padding-right: 2rem;
        }
        
        .form-select option {
            background: var(--dark-bg);
            color: var(--canvas-white);
        }
        
        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-bottom-color: var(--gold);
        }
        
        .start-button {
            width: 100%;
            margin-top: 2.5rem;
            padding: 0.9rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: var(--canvas-white);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            letter-spacing: 0.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
        }
        
        .start-button:active:not(:disabled) {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--gold);
        }
        
        .start-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        /* Mobile optimizations for small screens */
        @media screen and (max-width: 375px) {
            .prologue-text {
                font-size: 1.1rem;
                line-height: 1.8;
                margin-bottom: 2rem;
            }
            
            .form-group {
                margin-bottom: 1.5rem;
            }
            
            .character-header {
                margin-bottom: 2rem;
            }
        }
        
        /* Ensure touch targets are large enough */
        @media (pointer: coarse) {
            .continue-button,
            .start-button {
                min-height: 44px;
            }
        }
        
        /* STREET WALK TRANSITION SCREEN */
        #streetWalkScreen {
            background: var(--dark-bg);
            padding: 1.5rem;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* Cinematic vignette */
        #streetWalkScreen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.7) 100%);
            pointer-events: none;
        }
        
        .street-walk-content {
            max-width: 500px;
            text-align: center;
            position: relative;
            padding: 0 1rem;
            z-index: 1;
        }
        
        .street-walk-text {
            font-size: clamp(1.1rem, 4vw, 1.4rem);
            line-height: 2;
            font-weight: 300;
            opacity: 1;
            text-align: center;
        }
        
        .street-walk-line {
            opacity: 0;
            transform: translateY(10px);
            display: block;
            margin-bottom: 0.8rem;
        }
        
        .street-walk-line.highlight {
            color: var(--gold);
            font-weight: 400;
        }
        
        .street-walk-line.fade-in {
            animation: fadeInLine 1.2s ease-out forwards;
        }
        
        /* STREET TOURNAMENT SCREEN */
        #streetScreen {
            background: var(--dark-bg);
            padding: 1.5rem;
            overflow-y: auto;
        }
        
        .street-header {
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .street-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 2rem);
            font-weight: 300;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .street-subtitle {
            font-size: clamp(0.85rem, 3vw, 1rem);
            opacity: 0.6;
            line-height: 1.6;
            font-weight: 300;
        }
        
        .fighters-grid {
            display: grid;
            gap: 1.5rem;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .fighter-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .fighter-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .fighter-card:active::before {
            opacity: 1;
        }
        
        .fighter-card:active {
            border-color: var(--gold);
            transform: scale(0.98);
        }
        
        .fighter-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1.2rem;
        }
        
        .fighter-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 4.5vw, 1.6rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
        }
        
        .fighter-nickname {
            font-size: clamp(0.85rem, 3vw, 0.95rem);
            opacity: 0.5;
            font-style: italic;
        }
        
        .talent-badge {
            background: linear-gradient(135deg, var(--gold), #FFA500);
            color: var(--dark-bg);
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            box-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
        }
        
        .fighter-basics {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1.2rem;
            font-size: clamp(0.85rem, 3vw, 0.95rem);
            opacity: 0.7;
        }
        
        .fighter-basics span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .fighter-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.8rem;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
        }
        
        .stat-label {
            opacity: 0.6;
            font-weight: 300;
        }
        
        .stat-value {
            font-weight: 400;
            color: var(--canvas-white);
        }
        
        .stat-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.3rem;
        }
        
        .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--gold), #FFA500);
            transition: width 0.5s ease;
        }
        
        .talent-description {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            font-size: clamp(0.8rem, 2.8vw, 0.85rem);
            opacity: 0.5;
            line-height: 1.5;
        }
        
        .talent-bonus {
            color: var(--gold);
            font-weight: 400;
        }
        
        /* CONFIRMATION MODAL */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 1.5rem;
        }
        
        .modal-overlay.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }
        
        .modal-content {
            background: var(--dark-bg);
            border: 1px solid var(--gold);
            border-radius: 8px;
            padding: 2rem 1.5rem;
            max-width: 400px;
            width: 100%;
            text-align: center;
            animation: slideUp 0.3s ease;
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .modal-fighter-avatar {
            font-size: 4rem;
            margin-bottom: 1rem;
        }
        
        .modal-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.4rem, 5vw, 1.8rem);
            color: var(--gold);
            margin-bottom: 0.5rem;
        }
        
        .modal-subtitle {
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            opacity: 0.7;
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .modal-buttons {
            display: flex;
            gap: 1rem;
        }
        
        .modal-button {
            flex: 1;
            padding: 0.9rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: var(--canvas-white);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            letter-spacing: 0.05rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
        }
        
        .modal-button.confirm {
            border-color: var(--gold);
            color: var(--gold);
        }
        
        .modal-button:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.05);
        }
        
        .modal-button.confirm:active {
            background: rgba(255, 215, 0, 0.1);
        }
        
        .fighter-avatar {
            font-size: 3rem;
            text-align: center;
            margin-bottom: 1rem;
        }
        
        /* MAIN GAME SCREEN */
        #gameScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        /* Manager Profile Section */
        .manager-profile {
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem;
            flex-shrink: 0;
        }
        
        .manager-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.8rem;
        }
        
        .vip-star-container {
            position: relative;
            flex-shrink: 0;
        }
        
        .vip-star {
            position: absolute;
            top: -5px;
            left: -5px;
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            filter: grayscale(100%) brightness(0.5);
            opacity: 0.5;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .vip-star.active {
            filter: grayscale(0%) brightness(1);
            opacity: 1;
            animation: vipPulse 2s ease-in-out infinite;
        }
        
        @keyframes vipPulse {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
            }
            50% { 
                transform: scale(1.1) rotate(10deg);
            }
        }
        
        .manager-avatar {
            font-size: clamp(2.5rem, 8vw, 3rem);
            width: clamp(60px, 15vw, 70px);
            height: clamp(60px, 15vw, 70px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 50%;
        }
        
        .vip-status {
            font-size: clamp(0.75rem, 2.8vw, 0.8rem);
            opacity: 0.7;
            margin-top: 0.2rem;
            color: var(--gold);
        }
        
        .vip-quick-btn {
            padding: 0.6rem 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.85rem, 3vw, 0.95rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .vip-quick-btn:active {
            transform: scale(0.95);
        }
        
        .manager-info {
            flex: 1;
        }
        
        .manager-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.6rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .vip-badge {
            background: linear-gradient(135deg, var(--gold), #FFA500);
            color: var(--dark-bg);
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: clamp(0.7rem, 2.5vw, 0.8rem);
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
        }
        
        .manager-details {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
            display: flex;
            gap: 0.8rem;
            flex-wrap: wrap;
        }
        
        .manager-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.6rem;
        }
        
        .manager-stat-box {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 0.6rem;
            text-align: center;
        }
        
        .manager-stat-label {
            font-size: clamp(0.7rem, 2.5vw, 0.75rem);
            opacity: 0.5;
            margin-bottom: 0.2rem;
        }
        
        .manager-stat-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.8vw, 1.2rem);
            color: var(--gold);
            font-weight: 400;
        }
        
        .manager-stat-box.clickable {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .manager-stat-box.clickable:active {
            transform: scale(0.95);
            background: rgba(255, 215, 0, 0.1);
        }
        
        /* Fighter Card (compact) */
        .fighter-card-main {
            margin: 1rem;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
        }
        
        .fighter-card-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .fighter-card-avatar {
            font-size: clamp(2rem, 7vw, 2.5rem);
            width: clamp(50px, 12vw, 60px);
            height: clamp(50px, 12vw, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.2);
            border-radius: 50%;
        }
        
        .fighter-card-info {
            flex: 1;
        }
        
        .fighter-card-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.2rem;
        }
        
        .fighter-card-stats {
            font-size: clamp(0.8rem, 3vw, 0.85rem);
            opacity: 0.6;
            display: flex;
            gap: 0.8rem;
        }
        
        .fighter-quick-stats {
            display: flex;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .fighter-quick-stat {
            flex: 1;
            text-align: center;
        }
        
        .fighter-quick-stat-label {
            font-size: clamp(0.75rem, 2.5vw, 0.8rem);
            opacity: 0.5;
            margin-bottom: 0.2rem;
        }
        
        .fighter-quick-stat-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            color: var(--canvas-white);
        }
        
        .fighter-next-fight {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 6px;
            padding: 0.6rem;
            text-align: center;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            margin-bottom: 1rem;
        }
        
        .fighter-card-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.6rem;
        }
        
        .fighter-card-btn {
            padding: 0.7rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--canvas-white);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3vw, 0.95rem);
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px;
        }
        
        .fighter-card-btn.primary {
            border-color: var(--gold);
            color: var(--gold);
        }
        
        .fighter-card-btn:active {
            transform: scale(0.97);
            background: rgba(255, 255, 255, 0.05);
        }
        
        /* Main Content */
        /* TOP RESOURCE BAR */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, var(--dark-bg) 0%, rgba(10, 10, 10, 0.95) 100%);
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
            padding: 0.8rem 1rem;
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        /* SCROLLABLE CONTENT */
        .game-scroll-content {
            flex: 1;
            overflow-y: auto;
            padding-top: 60px;
            padding-bottom: 80px;
        }
        
        /* BOTTOM NAVIGATION */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(0deg, var(--dark-bg) 0%, rgba(10, 10, 10, 0.95) 100%);
            border-top: 1px solid rgba(255, 215, 0, 0.2);
            padding: 0.5rem 0.5rem calc(env(safe-area-inset-bottom) + 0.5rem);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            padding: 0.4rem 0.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 8px;
            position: relative;
            min-width: 0;
        }
        
        .nav-item:active {
            background: rgba(255, 215, 0, 0.1);
            transform: scale(0.95);
        }
        
        .nav-icon {
            font-size: clamp(1.3rem, 4.5vw, 1.6rem);
            filter: grayscale(0.3);
            transition: all 0.2s ease;
        }
        
        .nav-item:active .nav-icon {
            filter: grayscale(0);
            transform: scale(1.1);
        }
        
        .nav-label {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.6rem, 2.2vw, 0.7rem);
            color: var(--canvas-white);
            opacity: 0.8;
            letter-spacing: 0.02rem;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }
        
        .nav-badge {
            position: absolute;
            top: 0.3rem;
            right: 0.5rem;
            background: #ef4444;
            color: white;
            font-size: 0.6rem;
            font-weight: 600;
            padding: 0.15rem 0.4rem;
            border-radius: 10px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        .resource-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .resource-icon {
            font-size: clamp(1.2rem, 4vw, 1.4rem);
        }
        
        .resource-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            color: var(--canvas-white);
            font-weight: 400;
        }
        
        /* TRAINING SCREEN */
        #trainingScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .training-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
        }
        
        .training-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .training-subtitle {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
        }
        
        .training-content {
            padding: 1rem;
        }
        
        .training-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1.2rem;
            margin-bottom: 1rem;
        }
        
        .training-card.active {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.05);
        }
        
        .training-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .training-stat-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            font-weight: 400;
            color: var(--canvas-white);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .training-stat-icon {
            font-size: clamp(1.5rem, 5vw, 1.8rem);
        }
        
        .training-stat-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            color: var(--gold);
        }
        
        .training-progress {
            margin-bottom: 1rem;
        }
        
        .training-progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        
        .training-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--gold), #FFA500);
            transition: width 0.3s ease;
        }
        
        .training-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.6rem;
            margin-bottom: 1rem;
        }
        
        .training-option {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 0.8rem 0.4rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .training-option.selected {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.1);
        }
        
        .training-option:active {
            transform: scale(0.95);
        }
        
        .training-option-time {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            color: var(--canvas-white);
            margin-bottom: 0.2rem;
        }
        
        .training-option-cost {
            font-size: clamp(0.75rem, 2.8vw, 0.8rem);
            opacity: 0.6;
        }
        
        .training-option-reward {
            font-size: clamp(0.7rem, 2.5vw, 0.75rem);
            color: var(--gold);
            margin-top: 0.2rem;
        }
        
        .training-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            letter-spacing: 0.05rem;
        }
        
        .training-button:active {
            transform: scale(0.98);
        }
        
        .training-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .training-timer {
            text-align: center;
            padding: 1.5rem;
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        
        .training-timer-label {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        
        .training-timer-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(2rem, 7vw, 2.5rem);
            color: var(--gold);
            font-weight: 400;
            margin-bottom: 1rem;
        }
        
        .training-boost-button {
            padding: 0.8rem 1.5rem;
            background: transparent;
            border: 1px solid var(--gold);
            color: var(--gold);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3vw, 1rem);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .training-boost-button:active {
            background: rgba(255, 215, 0, 0.1);
        }
        
        .back-button {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--canvas-white);
            font-size: 1.5rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .back-button:active {
            background: rgba(255, 255, 255, 0.05);
            transform: scale(0.95);
        }
        
        /* FIGHTS SCREEN */
        #fightsScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .fights-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
        }
        
        .fights-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .fights-subtitle {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
        }
        
        .fights-cooldown {
            margin: 1rem;
            padding: 1rem;
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            text-align: center;
        }
        
        .cooldown-text {
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            opacity: 0.8;
            margin-bottom: 0.5rem;
        }
        
        .cooldown-timer {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            color: var(--gold);
            margin-bottom: 0.8rem;
        }
        
        .cooldown-skip-btn {
            padding: 0.7rem 1.5rem;
            background: transparent;
            border: 1px solid var(--gold);
            color: var(--gold);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3vw, 1rem);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .cooldown-skip-btn:active {
            background: rgba(255, 215, 0, 0.1);
        }
        
        .fights-content {
            padding: 1rem;
        }
        
        .opponent-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1.2rem;
            margin-bottom: 1rem;
        }
        
        .opponent-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .opponent-avatar {
            font-size: clamp(2rem, 7vw, 2.5rem);
            width: clamp(50px, 12vw, 60px);
            height: clamp(50px, 12vw, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.2);
            border-radius: 50%;
        }
        
        .opponent-info {
            flex: 1;
        }
        
        .opponent-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
        }
        
        .opponent-details {
            font-size: clamp(0.8rem, 3vw, 0.85rem);
            opacity: 0.6;
            display: flex;
            gap: 0.8rem;
        }
        
        .opponent-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .opponent-stat {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 0.6rem;
        }
        
        .opponent-stat-label {
            font-size: clamp(0.75rem, 2.5vw, 0.8rem);
            opacity: 0.5;
            margin-bottom: 0.2rem;
        }
        
        .opponent-stat-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            color: var(--canvas-white);
        }
        
        .opponent-stat-value.positive {
            color: #4ade80;
        }
        
        .opponent-stat-value.negative {
            color: #f87171;
        }
        
        .difficulty-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 12px;
            font-size: clamp(0.75rem, 2.5vw, 0.8rem);
            font-weight: 600;
            margin-bottom: 0.8rem;
        }
        
        .difficulty-easy {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid #4ade80;
        }
        
        .difficulty-medium {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid #fbbf24;
        }
        
        .difficulty-hard {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            border: 1px solid #f87171;
        }
        
        .opponent-rewards {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 6px;
            padding: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .rewards-label {
            font-size: clamp(0.75rem, 2.5vw, 0.8rem);
            opacity: 0.6;
            margin-bottom: 0.4rem;
        }
        
        .rewards-values {
            display: flex;
            gap: 1rem;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
        }
        
        .fight-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            letter-spacing: 0.05rem;
        }
        
        .fight-button:active {
            transform: scale(0.98);
        }
        
        /* FIGHT SIMULATION SCREEN */
        #fightSimScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .fight-sim-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
            text-align: center;
        }
        
        .fight-sim-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.6rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .fight-sim-round {
            font-size: clamp(0.9rem, 3vw, 1rem);
            opacity: 0.6;
        }
        
        .fight-sim-content {
            padding: 1rem;
        }
        
        .fighters-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            gap: 1rem;
        }
        
        .fighter-display {
            flex: 1;
            text-align: center;
        }
        
        .fighter-display-avatar {
            font-size: clamp(2.5rem, 8vw, 3rem);
            margin-bottom: 0.5rem;
        }
        
        .fighter-display-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .fighter-health-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .fighter-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 0.5s ease;
        }
        
        .fighter-health-fill.low {
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
        }
        
        .fighter-health-fill.critical {
            background: linear-gradient(90deg, #f87171, #ef4444);
        }
        
        .vs-text {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 2rem);
            color: var(--gold);
            font-weight: 600;
        }
        
        .fight-log {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 1rem;
        }
        
        .fight-log-entry {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            line-height: 1.5;
            opacity: 0.8;
            animation: slideInLog 0.3s ease;
            border-radius: 4px;
        }
        
        @keyframes slideInLog {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 0.8;
                transform: translateX(0);
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        .fight-log-entry.player {
            color: #4ade80;
            background: rgba(74, 222, 128, 0.05);
            border-left: 3px solid #4ade80;
        }
        
        .fight-log-entry.opponent {
            color: #f87171;
            background: rgba(248, 113, 113, 0.05);
            border-left: 3px solid #f87171;
        }
        
        .fight-log-entry.neutral {
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
        }
        
        .fight-result {
            text-align: center;
            padding: 2rem 1rem;
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        
        .result-icon {
            font-size: clamp(3rem, 10vw, 4rem);
            margin-bottom: 1rem;
        }
        
        .result-text {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 2rem);
            font-weight: 400;
            color: var(--gold);
            margin-bottom: 1rem;
        }
        
        /* NEW IMPROVED RESULT STYLES */
        #fightResultDisplay {
            display: none;
            width: 100%;
            min-height: 100vh;
            padding: 2rem;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: var(--dark-bg);
            text-align: center;
        }
        
        #fightResultDisplay.show {
            display: block !important;
        }
        
        .result-icon {
            font-size: clamp(5rem, 15vw, 8rem);
            margin: 2rem 0;
            animation: resultBounce 0.6s ease-out;
        }
        
        @keyframes resultBounce {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .result-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(2rem, 8vw, 3rem);
            font-weight: 700;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 1rem 0;
            text-transform: uppercase;
        }
        
        .result-subtitle {
            font-size: clamp(1rem, 4vw, 1.3rem);
            opacity: 0.7;
            margin: 1rem 0 2rem;
        }
        
        .result-rewards {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }
        
        .reward-item {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #FFD700;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 5vw, 1.5rem);
            font-weight: 600;
            color: var(--gold);
        }
        
        .continue-btn {
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            padding: clamp(1rem, 4vw, 1.5rem) clamp(2rem, 8vw, 3rem);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4.5vw, 1.4rem);
            font-weight: 700;
            letter-spacing: 0.05em;
            color: var(--dark-bg);
            border-radius: 12px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.3);
            margin-top: 2rem;
            transition: all 0.3s ease;
        }
        
        .continue-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.5);
        }
        
        .continue-btn:active {
            transform: translateY(0);
        }
        
        .result-content {
            text-align: center;
            padding: 2rem;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .result-icon-large {
            font-size: clamp(5rem, 15vw, 8rem);
            margin-bottom: 1rem;
            animation: resultBounce 0.6s ease-out;
        }
        
        @keyframes resultBounce {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        
        .result-title-large {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(2rem, 8vw, 3.5rem);
            font-weight: 700;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        
        .result-subtitle {
            font-size: clamp(1rem, 4vw, 1.3rem);
            opacity: 0.7;
            margin-bottom: 2rem;
        }
        
        .result-rewards {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin: 2rem 0;
        }
        
        .result-reward-item {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 5vw, 1.8rem);
            font-weight: 600;
            color: var(--gold);
            animation: rewardPulse 0.8s ease-out;
        }
        
        @keyframes rewardPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .result-button-large {
            width: 100%;
            max-width: 400px;
            padding: 1.2rem 2rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4.5vw, 1.4rem);
            font-weight: 700;
            letter-spacing: 0.05em;
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.3);
            margin-top: 2rem;
        }
        
        .result-button-large:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.5);
        }
        
        .result-button-large:active {
            transform: translateY(0);
        }
        
        .result-rewards {
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            opacity: 0.8;
        }
        
        .continue-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .continue-button:active {
            transform: scale(0.98);
        }
        
        /* VIP SCREEN */
        #vipScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .vip-header {
            padding: 1.5rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.1) 0%, transparent 100%);
            text-align: center;
        }
        
        .vip-icon {
            font-size: clamp(3rem, 10vw, 4rem);
            margin-bottom: 0.5rem;
        }
        
        .vip-header-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.8rem, 6vw, 2.2rem);
            font-weight: 600;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }
        
        .vip-header-subtitle {
            font-size: clamp(0.9rem, 3vw, 1rem);
            opacity: 0.7;
        }
        
        .vip-content {
            padding: 1rem;
        }
        
        .vip-status-card {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 1.2rem;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .vip-status-active {
            border-color: var(--gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 165, 0, 0.05));
        }
        
        .vip-status-label {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        
        .vip-status-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.6rem);
            color: var(--gold);
            font-weight: 600;
            margin-bottom: 0.3rem;
        }
        
        .vip-timer {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            color: var(--canvas-white);
            opacity: 0.8;
        }
        
        .vip-benefits {
            margin-bottom: 1.5rem;
        }
        
        .vip-benefits-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            color: var(--canvas-white);
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .vip-benefit-item {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.8rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .vip-benefit-icon {
            font-size: clamp(1.8rem, 6vw, 2.2rem);
            width: clamp(50px, 12vw, 60px);
            height: clamp(50px, 12vw, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .vip-benefit-text {
            flex: 1;
        }
        
        .vip-benefit-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            color: var(--gold);
            margin-bottom: 0.2rem;
        }
        
        .vip-benefit-desc {
            font-size: clamp(0.8rem, 3vw, 0.85rem);
            opacity: 0.6;
        }
        
        .vip-packages {
            margin-bottom: 1.5rem;
        }
        
        .vip-packages-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            color: var(--canvas-white);
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .vip-package {
            background: rgba(255, 255, 255, 0.02);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 1.2rem;
            margin-bottom: 1rem;
            position: relative;
        }
        
        .vip-package.recommended {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.05);
        }
        
        .vip-package-badge {
            position: absolute;
            top: -10px;
            right: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            color: var(--dark-bg);
            padding: 0.3rem 0.8rem;
            border-radius: 12px;
            font-size: clamp(0.7rem, 2.5vw, 0.75rem);
            font-weight: 600;
        }
        
        .vip-package-duration {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.4rem, 5vw, 1.6rem);
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
            text-align: center;
        }
        
        .vip-package-price {
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            color: var(--gold);
            text-align: center;
            margin-bottom: 0.5rem;
        }
        
        .vip-package-save {
            font-size: clamp(0.8rem, 3vw, 0.85rem);
            color: #4ade80;
            text-align: center;
            margin-bottom: 1rem;
        }
        
        .vip-buy-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            letter-spacing: 0.05rem;
        }
        
        .vip-buy-button:active {
            transform: scale(0.98);
        }
        
        .vip-buy-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .vip-note {
            text-align: center;
            font-size: clamp(0.8rem, 2.8vw, 0.85rem);
            opacity: 0.5;
            margin-top: 1rem;
            line-height: 1.5;
        }
        
        /* FIGHTERS MANAGEMENT */
        .fighters-list {
            margin: 1rem;
        }
        
        .fighter-slot {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .fighter-slot.active {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.05);
        }
        
        .fighter-slot.locked {
            cursor: pointer;
            opacity: 1;
        }
        
        .slot-locked-content {
            text-align: center;
            padding: 1rem;
        }
        
        .slot-locked-content.collapsed {
            padding: 0.8rem 1rem;
        }
        
        .slot-locked-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }
        
        .slot-locked-header-left {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            flex: 1;
        }
        
        .slot-locked-icon {
            font-size: clamp(1.8rem, 6vw, 2.2rem);
        }
        
        .slot-locked-content.collapsed .slot-locked-icon {
            font-size: clamp(1.5rem, 5vw, 1.8rem);
        }
        
        .slot-locked-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 4vw, 1.2rem);
            color: var(--canvas-white);
        }
        
        .slot-locked-content.collapsed .slot-locked-title {
            font-size: clamp(0.95rem, 3.5vw, 1.1rem);
        }
        
        .slot-expand-icon {
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            opacity: 0.6;
            transition: transform 0.3s ease;
        }
        
        .slot-expand-icon.expanded {
            transform: rotate(180deg);
        }
        
        .slot-locked-details {
            margin-top: 1rem;
            display: none;
        }
        
        .slot-locked-details.expanded {
            display: block;
        }
        
        .slot-locked-desc {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        
        .slot-unlock-button {
            padding: 0.9rem 1.5rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.95rem, 3.5vw, 1.05rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .slot-unlock-button:active {
            transform: scale(0.98);
        }
        
        /* ACADEMY SCREEN */
        #academyScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .academy-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
        }
        
        .academy-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .academy-subtitle {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
        }
        
        .academy-content {
            padding: 1rem;
        }
        
        .academy-tab {
            flex: 1;
            padding: 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: white;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .academy-tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .academy-tab.active {
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border-color: var(--gold);
            color: var(--dark-bg);
            font-weight: 700;
        }
        
        .academy-timer-card {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .academy-timer-label {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        
        .academy-timer-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.6rem);
            color: var(--gold);
            margin-bottom: 1rem;
        }
        
        .academy-refresh-button {
            padding: 0.8rem 1.5rem;
            background: transparent;
            border: 1px solid var(--gold);
            color: var(--gold);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3vw, 1rem);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .academy-refresh-button:active {
            background: rgba(255, 215, 0, 0.1);
        }
        
        .academy-candidates {
            margin-top: 1rem;
        }
        
        .academy-candidates-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            color: var(--canvas-white);
            margin-bottom: 1rem;
        }
        
        .candidate-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1.2rem;
            margin-bottom: 1rem;
        }
        
        .candidate-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .candidate-avatar {
            font-size: clamp(2rem, 7vw, 2.5rem);
            width: clamp(50px, 12vw, 60px);
            height: clamp(50px, 12vw, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.2);
            border-radius: 50%;
        }
        
        .candidate-info {
            flex: 1;
        }
        
        .candidate-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
        }
        
        .candidate-details {
            font-size: clamp(0.8rem, 3vw, 0.85rem);
            opacity: 0.6;
        }
        
        .candidate-talent-badge {
            background: linear-gradient(135deg, var(--gold), #FFA500);
            color: var(--dark-bg);
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .candidate-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.6rem;
            margin-bottom: 1rem;
        }
        
        .candidate-stat {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 0.5rem;
        }
        
        .candidate-stat-label {
            font-size: clamp(0.75rem, 2.5vw, 0.8rem);
            opacity: 0.5;
            margin-bottom: 0.2rem;
        }
        
        .candidate-stat-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.95rem, 3.5vw, 1.05rem);
            color: var(--canvas-white);
        }
        
        .candidate-price {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 6px;
            padding: 0.8rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .candidate-price-label {
            font-size: clamp(0.75rem, 2.5vw, 0.8rem);
            opacity: 0.6;
            margin-bottom: 0.3rem;
        }
        
        .candidate-price-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            color: var(--gold);
        }
        
        .candidate-hire-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .candidate-hire-button:active {
            transform: scale(0.98);
        }
        
        .candidate-hire-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* TOAST NOTIFICATIONS */
        .toast-container {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            pointer-events: none;
            max-width: 90%;
            width: 400px;
        }
        
        .toast {
            background: var(--dark-bg);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 1rem 1.2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            gap: 0.8rem;
            animation: slideInDown 0.3s ease, fadeOut 0.3s ease 2.7s;
            pointer-events: auto;
        }
        
        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateY(-10px);
            }
        }
        
        .toast-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }
        
        .toast-content {
            flex: 1;
        }
        
        .toast-title {
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            color: var(--canvas-white);
            margin-bottom: 0.2rem;
        }
        
        .toast-message {
            font-size: 0.85rem;
            opacity: 0.8;
            line-height: 1.4;
        }
        
        .toast.success {
            border-color: #4ade80;
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.1), rgba(10, 10, 10, 0.95));
        }
        
        .toast.error {
            border-color: #ef4444;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(10, 10, 10, 0.95));
        }
        
        .toast.info {
            border-color: #3b82f6;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(10, 10, 10, 0.95));
        }
        
        .toast.warning {
            border-color: #f59e0b;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(10, 10, 10, 0.95));
        }
        
        /* LOADING OVERLAY */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 10, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2500;
            backdrop-filter: blur(5px);
        }
        
        .loading-overlay.active {
            display: flex;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 215, 0, 0.2);
            border-top-color: var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* SMOOTH SCREEN TRANSITIONS */
        .screen {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .screen:not(.active) {
            opacity: 0;
            transform: scale(0.98);
            pointer-events: none;
        }
        
        .screen.active {
            opacity: 1;
            transform: scale(1);
        }
        
        /* BUTTON PRESS EFFECTS */
        .nav-item:active,
        .action-card:active,
        .fighter-slot:active,
        button:active {
            transform: scale(0.95);
        }
        
        /* PULSE ANIMATION for important elements */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }
        
        /* FIGHTER STATS SCREEN */
        #fighterStatsScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .stats-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
        }
        
        .stats-fighter-card {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .stats-fighter-avatar {
            font-size: clamp(3rem, 10vw, 4rem);
            width: clamp(80px, 20vw, 100px);
            height: clamp(80px, 20vw, 100px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid var(--gold);
            border-radius: 50%;
        }
        
        .stats-fighter-info {
            flex: 1;
        }
        
        .stats-fighter-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.6rem);
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
        }
        
        .stats-fighter-details {
            display: flex;
            gap: 1rem;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        
        .stats-fighter-record {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            color: var(--gold);
        }
        
        .stats-content {
            padding: 1rem;
        }
        
        .stats-section {
            margin-bottom: 1.5rem;
        }
        
        .stats-section-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 4vw, 1.2rem);
            color: var(--canvas-white);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.8rem;
        }
        
        .stats-box {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 0.8rem;
            text-align: center;
        }
        
        .stats-box-label {
            font-size: clamp(0.75rem, 2.8vw, 0.8rem);
            opacity: 0.6;
            margin-bottom: 0.3rem;
        }
        
        .stats-box-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.5rem);
            color: var(--canvas-white);
        }
        
        .stats-box.highlight {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.05);
        }
        
        .stats-bar-item {
            margin-bottom: 1rem;
        }
        
        .stats-bar-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
        }
        
        .stats-bar-label {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            color: var(--canvas-white);
        }
        
        .stats-bar-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            color: var(--gold);
        }
        
        .stats-bar-container {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .stats-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--gold), #FFA500);
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .fight-history-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .fight-history-item {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 0.8rem;
        }
        
        .fight-history-result {
            font-size: 1.5rem;
            flex-shrink: 0;
        }
        
        .fight-history-info {
            flex: 1;
        }
        
        .fight-history-opponent {
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            color: var(--canvas-white);
            margin-bottom: 0.2rem;
        }
        
        .fight-history-date {
            font-size: clamp(0.75rem, 2.8vw, 0.8rem);
            opacity: 0.5;
        }
        
        .fight-history-item.win {
            border-left: 3px solid #4ade80;
        }
        
        .fight-history-item.loss {
            border-left: 3px solid #ef4444;
        }
        
        .fight-history-item.draw {
            border-left: 3px solid #94a3b8;
        }
        
        .stats-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .stats-badge {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 20px;
            padding: 0.5rem 1rem;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
        }
        
        .stats-badge-icon {
            font-size: 1.2rem;
        }
        
        .stats-empty {
            text-align: center;
            padding: 2rem 1rem;
            opacity: 0.5;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
        }
        
        /* DAILY REWARDS SCREEN */
        #dailyRewardsScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .daily-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
        }
        
        .daily-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
            text-align: center;
        }
        
        .daily-subtitle {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
            text-align: center;
        }
        
        .daily-streak {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem;
            text-align: center;
        }
        
        .daily-streak-icon {
            font-size: clamp(2rem, 7vw, 2.5rem);
            margin-bottom: 0.5rem;
        }
        
        .daily-streak-label {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.7;
            margin-bottom: 0.3rem;
        }
        
        .daily-streak-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            color: var(--gold);
        }
        
        .daily-content {
            padding: 1rem;
        }
        
        .daily-calendar {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .daily-day {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            position: relative;
        }
        
        .daily-day.claimed {
            background: rgba(74, 222, 128, 0.1);
            border-color: rgba(74, 222, 128, 0.5);
        }
        
        .daily-day.today {
            border-color: var(--gold);
            border-width: 2px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            animation: pulse 2s ease-in-out infinite;
        }
        
        .daily-day.locked {
            opacity: 0.3;
        }
        
        .daily-day-number {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.8rem, 3vw, 0.9rem);
            color: var(--canvas-white);
            margin-bottom: 0.2rem;
        }
        
        .daily-day-reward {
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            margin-bottom: 0.2rem;
        }
        
        .daily-day-value {
            font-size: clamp(0.65rem, 2.5vw, 0.7rem);
            font-weight: 600;
        }
        
        .daily-day-check {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.9rem;
        }
        
        .daily-claim-section {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
        }
        
        .daily-claim-icon {
            font-size: clamp(3rem, 10vw, 4rem);
            margin-bottom: 0.5rem;
        }
        
        .daily-claim-text {
            font-size: clamp(1rem, 4vw, 1.2rem);
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .daily-claim-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 2rem);
            color: var(--gold);
            margin-bottom: 1rem;
        }
        
        .daily-claim-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 4vw, 1.2rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .daily-claim-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
        }
        
        .daily-claim-button:active:not(:disabled) {
            transform: scale(0.97);
        }
        
        .daily-next-reward {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            text-align: center;
        }
        
        .daily-next-label {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        
        .daily-next-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            color: var(--canvas-white);
        }
        
        .daily-timer {
            margin-top: 1rem;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
            text-align: center;
        }
        
        /* ACHIEVEMENTS SCREEN */
        #achievementsScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .achievements-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
        }
        
        .achievements-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
            text-align: center;
        }
        
        .achievements-subtitle {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
            text-align: center;
        }
        
        .achievements-summary {
            display: flex;
            justify-content: space-around;
            padding: 1rem;
            background: rgba(255, 215, 0, 0.05);
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .achievement-summary-item {
            text-align: center;
        }
        
        .achievement-summary-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.5rem);
            color: var(--gold);
        }
        
        .achievement-summary-label {
            font-size: clamp(0.75rem, 2.8vw, 0.8rem);
            opacity: 0.7;
            margin-top: 0.2rem;
        }
        
        .achievements-content {
            padding: 1rem;
        }
        
        .achievement-category {
            margin-bottom: 1.5rem;
        }
        
        .achievement-category-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 4vw, 1.2rem);
            color: var(--canvas-white);
            margin-bottom: 0.8rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .achievement-item {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.8rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .achievement-item.completed {
            background: rgba(74, 222, 128, 0.1);
            border-color: rgba(74, 222, 128, 0.5);
        }
        
        .achievement-item.locked {
            opacity: 0.6;
        }
        
        .achievement-icon {
            font-size: clamp(2rem, 7vw, 2.5rem);
            flex-shrink: 0;
            filter: grayscale(100%);
            opacity: 0.5;
            transition: all 0.3s ease;
        }
        
        .achievement-item.completed .achievement-icon {
            filter: grayscale(0%);
            opacity: 1;
        }
        
        .achievement-info {
            flex: 1;
        }
        
        .achievement-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 4vw, 1.1rem);
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
        }
        
        .achievement-description {
            font-size: clamp(0.8rem, 3vw, 0.85rem);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        
        .achievement-progress {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .achievement-progress-bar {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .achievement-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--gold), #FFA500);
            border-radius: 3px;
            transition: width 0.5s ease;
        }
        
        .achievement-progress-text {
            font-size: clamp(0.75rem, 2.8vw, 0.8rem);
            opacity: 0.7;
            white-space: nowrap;
        }
        
        .achievement-reward {
            flex-shrink: 0;
            text-align: center;
        }
        
        .achievement-reward-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            color: var(--gold);
        }
        
        .achievement-reward-label {
            font-size: clamp(0.65rem, 2.5vw, 0.7rem);
            opacity: 0.6;
        }
        
        .achievement-claim-btn {
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .achievement-claim-btn:active {
            transform: scale(0.97);
        }
        
        /* ========================================= */
        /* INJURY SYSTEM STYLES */
        /* ========================================= */
        
        .injury-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .injury-modal.active {
            opacity: 1;
        }
        
        .injury-modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
        }
        
        .injury-modal-content {
            position: relative;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            border: 2px solid var(--gold);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.3);
            animation: slideUpInjury 0.3s ease;
        }
        
        @keyframes slideUpInjury {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .injury-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .injury-modal-header h2 {
            font-family: 'Oswald', sans-serif;
            font-size: 1.8rem;
            color: var(--gold);
            margin: 0;
        }
        
        .injury-close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .injury-close-btn:hover {
            opacity: 1;
        }
        
        .injury-info {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .injury-name {
            font-family: 'Oswald', sans-serif;
            font-size: 1.5rem;
            color: white;
            margin-bottom: 0.8rem;
        }
        
        .injury-severity {
            display: inline-block;
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.8rem;
        }
        
        .injury-severity.light {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
        }
        
        .injury-severity.medium {
            background: rgba(250, 204, 21, 0.2);
            color: #facc15;
        }
        
        .injury-severity.heavy {
            background: rgba(251, 146, 60, 0.2);
            color: #fb923c;
        }
        
        .injury-severity.critical {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }
        
        .injury-effect,
        .injury-time {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 0.5rem;
        }
        
        .treatment-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .treatment-option {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1rem;
            transition: all 0.3s ease;
        }
        
        .treatment-option:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: var(--gold);
        }
        
        .treatment-option.instant {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.1);
        }
        
        .treatment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .treatment-name {
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            color: white;
        }
        
        .treatment-cost {
            font-weight: 700;
            color: var(--gold);
        }
        
        .treatment-time {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 0.8rem;
        }
        
        .treatment-btn {
            width: 100%;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: #0a0a0a;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            padding: 0.8rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        
        .treatment-btn:hover:not(.disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
        }
        
        .treatment-btn.instant {
            background: linear-gradient(135deg, #FFD700, #FFC700);
        }
        
        .treatment-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #555;
        }
        
        .injury-natural-btn {
            width: 100%;
            background: none;
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            padding: 0.8rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .injury-natural-btn:hover {
            border-color: white;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .fighter-injury-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            padding: 0.3rem 0.6rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            animation: pulseInjury 2s ease infinite;
        }
        
        @keyframes pulseInjury {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }
        
        .injury-status-banner {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.2));
            border: 2px solid #ef4444;
            border-radius: 12px;
            padding: 1rem;
            margin: 1rem 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .injury-status-banner:hover {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(220, 38, 38, 0.3));
            transform: translateY(-2px);
        }
        
        .injury-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .injury-status-name {
            font-family: 'Oswald', sans-serif;
            font-size: 1.2rem;
            color: #ef4444;
        }
        
        .injury-status-severity {
            font-size: 0.9rem;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            background: rgba(239, 68, 68, 0.3);
            color: white;
        }
        
        .injury-status-time {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 0.3rem;
        }
        
        .injury-status-action {
            margin-top: 0.8rem;
            font-size: 0.9rem;
            color: var(--gold);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <!-- LOADING SCREEN -->
    <div id="loadingScreen" class="screen active">
        <div class="loading-content">
            <div class="game-logo">BOXING<br>MANAGER</div>
            <div class="game-subtitle"></div>
            <div class="loading-bar-container">
                <div class="loading-bar"></div>
            </div>
            <div class="loading-text">...</div>
            <div style="position: absolute; bottom: 20px; width: 100%; text-align: center; color: var(--gold); font-size: 0.8rem; opacity: 0.6;">
                v3.3 - NAME FIX
            </div>
        </div>
    </div>

    <!-- PROLOGUE SCREEN -->
    <div id="prologueScreen" class="screen">
        <div class="prologue-content">
            <div class="prologue-text" id="prologueText">
                <span class="prologue-line highlight">   .</span>
                <span class="prologue-line"> .  .  .</span>
                <span class="prologue-line highlight">   .</span>
                <span class="prologue-line"> .  .</span>
                <span class="prologue-line">  :           .</span>
                <span class="prologue-line highlight">' .     .</span>
                <span class="prologue-line">   '.</span>
                <span class="prologue-line highlight">   .</span>
            </div>
            <button class="continue-button" id="continueBtn" onclick="showCharacterCreation()" style="opacity: 0;">
                
            </button>
        </div>
    </div>

    <!-- CHARACTER CREATION SCREEN -->
    <div id="characterScreen" class="screen">
        <div class="character-header">
            <div class="character-title"> </div>
            <div class="character-subtitle">  </div>
        </div>
        
        <div class="form-container">
            <div class="form-group">
                <label class="form-label">'  </label>
                <input type="text" 
                       id="managerNameInput" 
                       class="form-input" 
                       placeholder=" "
                       maxlength="40">
            </div>
            
            <div class="form-group">
                <label class="form-label"></label>
                <input type="number" 
                       id="managerAge" 
                       class="form-input" 
                       placeholder="  ..."
                       min="8"
                       max="99">
            </div>
            
            <div class="form-group">
                <label class="form-label"></label>
                <select id="managerCountry" class="form-select">
                    <option value=""> ...</option>
                    <option value=""> </option>
                    <option value=""> </option>
                    <option value=""> </option>
                    <option value=""> </option>
                    <option value=""> </option>
                    <option value=""> </option>
                    <option value=""> </option>
                    <option value=""> </option>
                    <option value=""> </option>
                    <option value=""> </option>
                    <option value=""> </option>
                </select>
            </div>
            
            <div class="form-group">
                <label class="form-label"></label>
                <input type="text" 
                       id="managerCity" 
                       class="form-input" 
                       placeholder=""
                       maxlength="30"
                       pattern="[A-Za-z--\s\-']+"
                       title=" ">
            </div>
            
            <button class="start-button" id="startButton" onclick="startGame()" disabled>
                 
            </button>
        </div>
    </div>

    <!-- STREET WALK TRANSITION -->
    <div id="streetWalkScreen" class="screen">
        <div class="street-walk-content">
            <div class="street-walk-text" id="streetWalkText">
                <span class="street-walk-line">.   .</span>
                <span class="street-walk-line">  ,   .</span>
                <span class="street-walk-line highlight">    .</span>
                <span class="street-walk-line"> .</span>
                <span class="street-walk-line">.  .  .</span>
                <span class="street-walk-line highlight"> .</span>
                <span class="street-walk-line">     ,    .</span>
                <span class="street-walk-line highlight">. Fire. .</span>
            </div>
        </div>
    </div>

    <!-- STREET TOURNAMENT SCREEN -->
    <div id="streetScreen" class="screen">
        <div class="street-header">
            <div class="street-title">  </div>
            <div class="street-subtitle">
                     .<br>
                    .
            </div>
        </div>
        
        <div class="fighters-grid" id="fightersGrid">
            <!-- Fighters will be generated here -->
        </div>
    </div>

    <!-- CONFIRMATION MODAL -->
    <div class="modal-overlay" id="confirmModal">
        <div class="modal-content">
            <div class="modal-fighter-avatar" id="modalAvatar"></div>
            <div class="modal-title" id="modalFighterName"></div>
            <div class="modal-subtitle">
                 ,     ?<br>
                    .
            </div>
            <div class="modal-buttons">
                <button class="modal-button" onclick="closeModal()"></button>
                <button class="modal-button confirm" onclick="confirmFighterSelection()">, !</button>
            </div>
        </div>
    </div>

    <!-- MAIN GAME SCREEN -->
    <div id="gameScreen" class="screen">
        <!-- Top Resource Bar -->
        <div class="top-bar">
            <div class="resource-item">
                <div class="resource-icon"></div>
                <div class="resource-value" id="resourceCash">0</div>
            </div>
            <div class="resource-item">
                <div class="resource-icon"></div>
                <div class="resource-value" id="resourceStars">0</div>
            </div>
            <div class="resource-item">
                <div class="resource-icon"></div>
                <div class="resource-value" id="resourceRating">0</div>
            </div>
            <div class="resource-item" id="cloudStatus" style="cursor: pointer; opacity: 0.7;" onclick="showCloudInfo()">
                <div class="resource-icon" id="cloudIcon"></div>
                <div class="resource-value" id="cloudText" style="font-size: 0.7rem;">Cloud</div>
            </div>
        </div>
        
        <!-- Scrollable Content -->
        <div class="game-scroll-content">
            <!-- Manager Profile -->
            <div class="manager-profile">
                <div class="manager-header">
                    <div class="vip-star-container">
                        <div class="vip-star" id="vipStar"></div>
                        <div class="manager-avatar" id="managerAvatar"></div>
                    </div>
                    <div class="manager-info">
                        <div class="manager-name">
                            <span id="managerName"></span>
                        </div>
                        <div class="manager-details">
                            <span id="managerLocation">, </span>
                        </div>
                        <div class="vip-status" id="vipStatus" style="display: none;">
                            <!-- VIP timer will be here -->
                        </div>
                    </div>
                    <button class="vip-quick-btn" onclick="hapticMedium(); openVIP()">
                         VIP
                    </button>
                </div>
                
                <div class="manager-stats">
                    <div class="manager-stat-box">
                        <div class="manager-stat-label"></div>
                        <div class="manager-stat-value" id="managerFighters">1</div>
                    </div>
                    <div class="manager-stat-box">
                        <div class="manager-stat-label"></div>
                        <div class="manager-stat-value" id="managerWins">0</div>
                    </div>
                    <div class="manager-stat-box clickable" onclick="hapticMedium(); openAchievements()">
                        <div class="manager-stat-label"></div>
                        <div class="manager-stat-value" id="achievementsCount">0/20</div>
                    </div>
                </div>
            </div>
            
            <!-- Fighters List -->
            <div class="fighters-list" id="fightersList">
                <!-- Fighters will be generated here -->
            </div>
        </div>
        
        <!-- Bottom Navigation -->
        <div class="bottom-nav">
            <div class="nav-item" onclick="hapticMedium(); openTraining()">
                <div class="nav-icon"></div>
                <div class="nav-label"></div>
            </div>
            
            <div class="nav-item" onclick="hapticMedium(); openFights()">
                <div class="nav-icon"></div>
                <div class="nav-label"></div>
            </div>
            
            <div class="nav-item" onclick="hapticMedium(); openMarket()">
                <div class="nav-icon"></div>
                <div class="nav-label"></div>
            </div>
            
            <div class="nav-item" onclick="hapticMedium(); openDailyRewards()">
                <div class="nav-icon"></div>
                <div class="nav-label"></div>
                <div class="nav-badge" id="dailyBadge" style="display: none;">!</div>
            </div>
            
            <div class="nav-item" onclick="hapticMedium(); openTeam()">
                <div class="nav-icon"></div>
                <div class="nav-label"></div>
            </div>
            
            <div class="nav-item" onclick="hapticMedium(); openAchievements()">
                <div class="nav-icon"></div>
                <div class="nav-label"></div>
                <div class="nav-badge" id="achievementsBadge" style="display: none;">!</div>
            </div>
        </div>
    </div>

    <!-- TRAINING SCREEN -->
    <div id="trainingScreen" class="screen">
        <button class="back-button" onclick="backToGame()"></button>
        
        <div class="training-header">
            <div class="training-title"> </div>
            <div class="training-subtitle">   </div>
        </div>
        
        <div class="training-content" id="trainingContent">
            <!-- Training cards will be generated here -->
        </div>
    </div>

    <!-- FIGHTS SCREEN -->
    <div id="fightsScreen" class="screen">
        <button class="back-button" onclick="backToGame()"></button>
        
        <div class="fights-header">
            <div class="fights-title"> </div>
            <div class="fights-subtitle">     </div>
        </div>
        
        <div id="fightsCooldown" style="display: none;">
            <!-- Cooldown timer will be shown here -->
        </div>
        
        <div class="fights-content" id="fightsContent">
            <!-- Opponents will be generated here -->
        </div>
    </div>

    <!-- FIGHT SIMULATION SCREEN -->
    <div id="fightSimScreen" class="screen">
        <div class="fight-sim-header">
            <div class="fight-sim-title"> </div>
            <div class="fight-sim-round" id="simRound"> 1</div>
        </div>
        
        <!-- SIMULATION CONTENT (shown during fight) -->
        <div class="fight-sim-content" id="fightSimContent">
            <div class="fighters-display">
                <div class="fighter-display">
                    <div class="fighter-display-avatar" id="simPlayerAvatar"></div>
                    <div class="fighter-display-name" id="simPlayerName"></div>
                    <div class="fighter-health-bar">
                        <div class="fighter-health-fill" id="simPlayerHealth" style="width: 100%"></div>
                    </div>
                </div>
                
                <div class="vs-text">VS</div>
                
                <div class="fighter-display">
                    <div class="fighter-display-avatar" id="simOpponentAvatar"></div>
                    <div class="fighter-display-name" id="simOpponentName"></div>
                    <div class="fighter-health-bar">
                        <div class="fighter-health-fill" id="simOpponentHealth" style="width: 100%"></div>
                    </div>
                </div>
            </div>
            
            <div class="fight-log" id="fightLog">
                <!-- Fight events will appear here -->
            </div>
        </div>
        
        <!-- RESULT DISPLAY (shown after fight) -->
        <div id="fightResultDisplay" style="display: none;">
            <!-- Result will be shown here -->
        </div>
    </div>

    <!-- VIP SCREEN -->
    <div id="vipScreen" class="screen">
        <button class="back-button" onclick="backToGame()"></button>
        
        <div class="vip-header">
            <div class="vip-icon"></div>
            <div class="vip-header-title">VIP </div>
            <div class="vip-header-subtitle">    </div>
        </div>
        
        <div class="vip-content" id="vipContent">
            <!-- VIP content will be generated here -->
        </div>
    </div>

    <!-- ACADEMY SCREEN -->
    <div id="academyScreen" class="screen">
        <button class="back-button" onclick="backToGame()"></button>
        
        <div class="academy-header">
            <div class="academy-title"> </div>
            <div class="academy-subtitle">  </div>
        </div>
        
        <div style="display: flex; gap: 0.5rem; margin: 1rem; padding: 0 1rem;">
            <button id="academyTabRookies" class="academy-tab active" onclick="switchAcademyTab('rookies')">
                 
            </button>
            <button id="academyTabMarket" class="academy-tab" onclick="switchAcademyTab('market')">
                 
            </button>
        </div>
        
        <div class="academy-content" id="academyContent">
            <!-- Academy content will be generated here -->
        </div>
    </div>

    <!-- FIGHTER STATS SCREEN -->
    <div id="fighterStatsScreen" class="screen">
        <button class="back-button" onclick="backToGame()"></button>
        
        <div class="stats-header">
            <div class="stats-fighter-card" id="statsFighterCard">
                <!-- Fighter info will be generated here -->
            </div>
        </div>
        
        <div class="stats-content" id="statsContent">
            <!-- Stats content will be generated here -->
        </div>
    </div>

    <!-- DAILY REWARDS SCREEN -->
    <div id="dailyRewardsScreen" class="screen">
        <button class="back-button" onclick="backToGame()"></button>
        
        <div class="daily-header">
            <div class="daily-title">  </div>
            <div class="daily-subtitle">     !</div>
        </div>
        
        <div class="daily-streak" id="dailyStreak">
            <!-- Streak info will be generated here -->
        </div>
        
        <div class="daily-content" id="dailyContent">
            <!-- Daily rewards content will be generated here -->
        </div>
    </div>

    <!-- TEAM SCREEN -->
    <div class="screen" id="teamScreen">
        <button class="back-button" onclick="backToGame()"></button>
        
        <div class="screen-content" style="padding: 1.5rem 1rem;">
            <!-- Header -->
            <div style="text-align: center; margin-bottom: 2rem;">
                <h1 style="font-size: 2rem; margin: 0; margin-bottom: 0.5rem;"></h1>
                <h2 style="margin: 0; font-size: 1.3rem; font-weight: 600;"></h2>
            </div>
            
            <!-- Summary -->
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 1rem;">
                <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 0.75rem; text-align: center; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem; text-transform: uppercase; letter-spacing: 0.5px;"></div>
                    <div id="teamCount" style="font-size: 1.3rem; font-weight: 700; color: white;">0/3</div>
                </div>
                <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 0.75rem; text-align: center; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem; text-transform: uppercase; letter-spacing: 0.5px;"> </div>
                    <div id="teamRating" style="font-size: 1.3rem; font-weight: 700; color: #4ade80;">0</div>
                </div>
            </div>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 2rem;">
                <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 0.75rem; text-align: center; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem; text-transform: uppercase; letter-spacing: 0.5px;"></div>
                    <div id="teamExpenses" style="font-size: 1.3rem; font-weight: 700; color: #ef4444;">$0</div>
                </div>
                <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 0.75rem; text-align: center; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem; text-transform: uppercase; letter-spacing: 0.5px;"></div>
                    <div id="teamTotalSpent" style="font-size: 1.3rem; font-weight: 700; color: rgba(255,255,255,0.7);">$0</div>
                </div>
            </div>
            
            <!-- Current Team -->
            <div style="margin-bottom: 2rem;">
                <div style="font-size: 0.75rem; font-weight: 600; color: rgba(255,255,255,0.5); margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 1px;"> </div>
                <div id="currentTeam"></div>
            </div>
            
            <!-- Available -->
            <div>
                <div style="font-size: 0.75rem; font-weight: 600; color: rgba(255,255,255,0.5); margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 1px;">  </div>
                <div id="availableTeam"></div>
            </div>
        </div>
    </div>

    <!-- ACHIEVEMENTS SCREEN -->
    <div id="achievementsScreen" class="screen">
        <button class="back-button" onclick="backToGame()"></button>
        
        <div class="achievements-header">
            <div class="achievements-title"> </div>
            <div class="achievements-subtitle">    </div>
        </div>
        
        <div class="achievements-summary" id="achievementsSummary">
            <!-- Summary will be generated here -->
        </div>
        
        <div class="achievements-content" id="achievementsContent">
            <!-- Achievements will be generated here -->
        </div>
    </div>

    <!-- TOAST CONTAINER -->
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- LOADING OVERLAY -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <script>
        // Initialize Telegram Web App
        let tg = window.Telegram?.WebApp || {
            // Fallback    Telegram
            expand: () => console.log('Telegram API not available - using fallback'),
            enableClosingConfirmation: () => {},
            themeParams: { bg_color: '#0a0a0a' },
            HapticFeedback: {
                notificationOccurred: () => {},
                impactOccurred: () => {}
            },
            BackButton: {
                show: () => {},
                hide: () => {},
                onClick: () => {}
            },
            CloudStorage: null, //  null    Telegram
            initDataUnsafe: { user: null }
        };
        
        tg.expand();
        tg.enableClosingConfirmation();
        
        // Set theme
        document.body.style.backgroundColor = tg.themeParams.bg_color || '#0a0a0a';
        
        //    Cloud Storage
        const isCloudAvailable = !!(tg.CloudStorage && typeof tg.CloudStorage.setItem === 'function');
        console.log(' Cloud Storage available:', isCloudAvailable);
        
        if (!isCloudAvailable) {
            console.warn(' Telegram Cloud Storage .   localStorage.');
        }
        
        // ===== CLOUD STORAGE SYSTEM =====
        
        // Storage Adapter Pattern -     
        class StorageAdapter {
            async save(key, data) {
                throw new Error('Method not implemented');
            }
            
            async load(key) {
                throw new Error('Method not implemented');
            }
            
            async remove(key) {
                throw new Error('Method not implemented');
            }
        }
        
        // Cloud Storage Adapter ( )
        class CloudStorageAdapter extends StorageAdapter {
            async save(key, data) {
                return new Promise((resolve, reject) => {
                    //    Cloud Storage
                    if (!tg.CloudStorage || typeof tg.CloudStorage.setItem !== 'function') {
                        console.warn(' Cloud Storage ');
                        reject(new Error('Cloud Storage not available'));
                        return;
                    }
                    
                    try {
                        const jsonData = JSON.stringify(data);
                        
                        //    4KB,   
                        if (jsonData.length > 3500) {
                            const chunks = this._splitIntoChunks(jsonData, 3500);
                            let saved = 0;
                            
                            chunks.forEach((chunk, index) => {
                                tg.CloudStorage.setItem(`${key}_${index}`, chunk, (error, success) => {
                                    if (error) {
                                        console.error('Cloud save error:', error);
                                        reject(error);
                                    } else {
                                        saved++;
                                        if (saved === chunks.length) {
                                            //  -   
                                            tg.CloudStorage.setItem(`${key}_meta`, JSON.stringify({ chunks: chunks.length }), (err) => {
                                                if (err) reject(err);
                                                else resolve(true);
                                            });
                                        }
                                    }
                                });
                            });
                        } else {
                            //     
                            tg.CloudStorage.setItem(key, jsonData, (error, success) => {
                                if (error) {
                                    console.error('Cloud save error:', error);
                                    reject(error);
                                } else {
                                    resolve(true);
                                }
                            });
                        }
                    } catch (e) {
                        console.error('Save error:', e);
                        reject(e);
                    }
                });
            }
            
            async load(key) {
                return new Promise((resolve, reject) => {
                    //    Cloud Storage
                    if (!tg.CloudStorage || typeof tg.CloudStorage.getItem !== 'function') {
                        console.warn(' Cloud Storage ');
                        reject(new Error('Cloud Storage not available'));
                        return;
                    }
                    
                    //     - ( )
                    tg.CloudStorage.getItem(`${key}_meta`, (error, metaData) => {
                        if (!error && metaData) {
                            //    
                            const meta = JSON.parse(metaData);
                            const chunkKeys = [];
                            for (let i = 0; i < meta.chunks; i++) {
                                chunkKeys.push(`${key}_${i}`);
                            }
                            
                            tg.CloudStorage.getItems(chunkKeys, (err, items) => {
                                if (err) {
                                    reject(err);
                                } else {
                                    //   
                                    let fullData = '';
                                    for (let i = 0; i < meta.chunks; i++) {
                                        fullData += items[`${key}_${i}`] || '';
                                    }
                                    
                                    try {
                                        resolve(JSON.parse(fullData));
                                    } catch (e) {
                                        reject(e);
                                    }
                                }
                            });
                        } else {
                            //    
                            tg.CloudStorage.getItem(key, (err, data) => {
                                if (err) {
                                    reject(err);
                                } else if (data) {
                                    try {
                                        resolve(JSON.parse(data));
                                    } catch (e) {
                                        reject(e);
                                    }
                                } else {
                                    resolve(null);
                                }
                            });
                        }
                    });
                });
            }
            
            async remove(key) {
                return new Promise((resolve) => {
                    tg.CloudStorage.removeItem(key, () => {
                        resolve(true);
                    });
                });
            }
            
            _splitIntoChunks(str, size) {
                const chunks = [];
                for (let i = 0; i < str.length; i += size) {
                    chunks.push(str.slice(i, i + size));
                }
                return chunks;
            }
        }
        
        // LocalStorage Adapter (FALLBACK  Cloud  )
        class LocalStorageAdapter extends StorageAdapter {
            async save(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (e) {
                    console.error('LocalStorage save error:', e);
                    throw e;
                }
            }
            
            async load(key) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : null;
                } catch (e) {
                    console.error('LocalStorage load error:', e);
                    return null;
                }
            }
            
            async remove(key) {
                localStorage.removeItem(key);
                return true;
            }
        }
        
        // Game Storage Manager
        class GameStorage {
            constructor() {
                //  Cloud Storage, fallback  LocalStorage
                this.cloudAdapter = new CloudStorageAdapter();
                this.localAdapter = new LocalStorageAdapter();
                
                //    Cloud Storage
                this.useCloud = isCloudAvailable;
                this.syncInProgress = false;
                
                if (this.useCloud) {
                    console.log(' Storage initialized:  Cloud +  Local');
                } else {
                    console.log(' Storage initialized:  Local only (Cloud )');
                }
            }
            
            async saveCharacter(characterData) {
                const saveTime = Date.now();
                characterData._lastSave = saveTime;
                characterData._version = '2.0';
                
                try {
                    if (this.useCloud) {
                        //   Cloud
                        await this.cloudAdapter.save('bm_character', characterData);
                        console.log(' Saved to Cloud Storage');
                        
                        //     
                        await this.localAdapter.save('bm_character', characterData);
                        
                        return { success: true, cloud: true, timestamp: saveTime };
                    } else {
                        //  
                        await this.localAdapter.save('bm_character', characterData);
                        console.log(' Saved to Local Storage');
                        
                        return { success: true, cloud: false, timestamp: saveTime };
                    }
                } catch (error) {
                    console.error('Save error:', error);
                    
                    // Fallback   
                    try {
                        await this.localAdapter.save('bm_character', characterData);
                        this.useCloud = false;
                        return { success: true, cloud: false, timestamp: saveTime, error: error.message };
                    } catch (localError) {
                        return { success: false, error: localError.message };
                    }
                }
            }
            
            async loadCharacter() {
                try {
                    //    Cloud
                    const cloudData = await this.cloudAdapter.load('bm_character');
                    
                    if (cloudData) {
                        console.log(' Loaded from Cloud Storage');
                        
                        //   
                        await this.localAdapter.save('bm_character', cloudData);
                        
                        return { data: cloudData, source: 'cloud' };
                    }
                    
                    //   Cloud ,  
                    const localData = await this.localAdapter.load('bm_character');
                    
                    if (localData) {
                        console.log(' Loaded from Local Storage (migrating to Cloud...)');
                        
                        //   Cloud
                        try {
                            await this.cloudAdapter.save('bm_character', localData);
                            console.log(' Migrated to Cloud Storage');
                        } catch (e) {
                            console.warn('Migration failed:', e);
                        }
                        
                        return { data: localData, source: 'local' };
                    }
                    
                    return { data: null, source: 'none' };
                    
                } catch (error) {
                    console.error('Load error:', error);
                    
                    // Fallback   
                    try {
                        const localData = await this.localAdapter.load('bm_character');
                        this.useCloud = false;
                        return { data: localData, source: 'local_fallback' };
                    } catch (localError) {
                        return { data: null, source: 'error', error: localError.message };
                    }
                }
            }
            
            async syncToCloud() {
                if (this.syncInProgress) return;
                
                this.syncInProgress = true;
                
                try {
                    const localData = await this.localAdapter.load('bm_character');
                    
                    if (localData) {
                        await this.cloudAdapter.save('bm_character', localData);
                        console.log(' Synced to Cloud');
                        this.useCloud = true;
                    }
                } catch (error) {
                    console.error('Sync error:', error);
                } finally {
                    this.syncInProgress = false;
                }
            }
        }
        
        //  
        const gameStorage = new GameStorage();
        
        //   30 
        setInterval(() => {
            if (gameStorage.useCloud) {
                gameStorage.syncToCloud();
            }
        }, 30000);
        
        // Helper  (    )
        async function saveGame(characterData) {
            const result = await gameStorage.saveCharacter(characterData);
            
            if (result.success) {
                //   
                if (result.cloud) {
                    console.log(' Game saved to Cloud + Local');
                } else {
                    console.log(' Game saved to Local only');
                }
                
                // DEBUG:   
                console.log(' Saved data size:', JSON.stringify(characterData).length, 'bytes');
                console.log(' Player:', characterData.name);
                console.log(' Cash:', characterData.gameState?.cash);
            } else {
                console.error(' Save failed:', result.error);
                showToast(' ', result.error, 'error');
            }
            
            return result.success;
        }
        
        async function loadGame() {
            const result = await gameStorage.loadCharacter();
            
            if (result.data) {
                console.log(` Game loaded from ${result.source}`);
                // Toast  -   
            }
            
            return result.data;
        }
        
        //     ( localStorage  )
        function saveGameSync(characterData) {
            // Safe local save (prevents game reset on quota/JSON issues)
            try {
                // Keep a one-step backup before overwriting
                const prev = localStorage.getItem('boxingManager_character');
                if (prev) localStorage.setItem('boxingManager_character_backup', prev);
            } catch (e) {
                // ignore backup errors
            }

            try {
                localStorage.setItem('boxingManager_character', JSON.stringify(characterData));
            } catch (e) {
                console.error(' LocalStorage save failed:', e);

                // Inform user, but DO NOT reset progress
                try {
                    if (typeof showToast === 'function') {
                        showToast(' ', '    .     .', 'warning');
                    }
                } catch (_) {}
            }

            // Async save to cloud (non-blocking)
            saveGame(characterData).catch(e => {
                console.error('Cloud save error:', e);
                // Do not reset, only inform
                try {
                    if (typeof showToast === 'function') {
                        showToast(' ', '    Cloud.    .', 'warning');
                    }
                } catch (_) {}
            });
        }

        function loadGameSync() {
            const data = localStorage.getItem('boxingManager_character');
            if (!data) return null;
            try {
                return normalizeCharacterData(JSON.parse(data));
            } catch (e) {
                console.error(' Failed to parse saved game data:', e);
                // Try backup
                const backup = localStorage.getItem('boxingManager_character_backup');
                if (backup) {
                    try {
                        const parsed = JSON.parse(backup);
                        // Restore backup as main save (best-effort)
                        try { localStorage.setItem('boxingManager_character', backup); } catch (_) {}
                        return normalizeCharacterData(parsed);
                    } catch (e2) {
                        console.error(' Failed to parse backup data:', e2);
                    }
                }
                return null;
            }
        }
        

        function normalizeCharacterData(data) {
            if (!data || typeof data !== 'object') return data;
            // Backward-compat: some older saves used `fighter` instead of `fighters`
            if (!Array.isArray(data.fighters)) {
                if (data.fighter && typeof data.fighter === 'object') {
                    data.fighters = [data.fighter];
                } else if (data.fighters && typeof data.fighters === 'object' && data.fighters.id) {
                    data.fighters = [data.fighters];
                } else {
                    data.fighters = [];
                }
            }
            // Ensure each fighter has gameData object
            data.fighters = data.fighters.map(f => {
                if (!f || typeof f !== 'object') return f;
                f.gameData = f.gameData || {};
                return f;
            });
            return data;
        }

        // ===== UI/UX UTILITIES =====
        
        // Toast Notifications
        function showToast(title, message = '', type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: '',
                error: '',
                warning: '',
                info: ''
            };
            
            toast.innerHTML = `
                <div class="toast-icon">${icons[type]}</div>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    ${message ? `<div class="toast-message">${message}</div>` : ''}
                </div>
            `;
            
            container.appendChild(toast);
            
            // Haptic feedback
            try {
                if (type === 'success') {
                    tg.HapticFeedback.notificationOccurred('success');
                } else if (type === 'error') {
                    tg.HapticFeedback.notificationOccurred('error');
                } else if (type === 'warning') {
                    tg.HapticFeedback.notificationOccurred('warning');
                }
            } catch (e) {}
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // Loading overlay
        function showLoading() {
            document.getElementById('loadingOverlay').classList.add('active');
        }
        
        function hideLoading() {
            document.getElementById('loadingOverlay').classList.remove('active');
        }
        
        // Haptic feedback helpers
        function hapticLight() {
            try { tg.HapticFeedback.impactOccurred('light'); } catch (e) {}
        }
        
        function hapticMedium() {
            try { tg.HapticFeedback.impactOccurred('medium'); } catch (e) {}
        }
        
        function hapticHeavy() {
            try { tg.HapticFeedback.impactOccurred('heavy'); } catch (e) {}
        }
        
        // Cloud Storage status functions
        function updateCloudStatus() {
            const icon = document.getElementById('cloudIcon');
            const text = document.getElementById('cloudText');
            
            if (!icon || !text) return;
            
            if (gameStorage.useCloud) {
                icon.textContent = '';
                text.textContent = 'Cloud';
                text.style.color = '#4ade80';
            } else {
                icon.textContent = '';
                text.textContent = 'Local';
                text.style.color = '#fbbf24';
            }
        }
        
        function showCloudInfo() {
            const characterData = loadGameSync();
            
            if (!characterData) {
                showToast(' Cloud Storage', '  ', 'info');
                return;
            }
            
            const lastSave = characterData._lastSave ? new Date(characterData._lastSave).toLocaleString('uk-UA') : '';
            const version = characterData._version || '1.0';
            const storage = gameStorage.useCloud ? ' Cloud Storage' : ' Local Storage';
            
            const telegramUser = tg.initDataUnsafe?.user;
            const userId = telegramUser ? telegramUser.id : 'N/A';
            
            showToast(
                '  ',
                `${storage}\n` +
                ` : ${lastSave}\n` +
                `: ${version}\n` +
                `Telegram ID: ${userId}`,
                'info'
            );
        }
        
        // ===== END UI/UX UTILITIES =====
        
        // ===== DAILY REWARDS SYSTEM =====
        
        const DAILY_REWARDS = [
            { day: 1, type: 'cash', amount: 500, icon: '' },
            { day: 2, type: 'cash', amount: 1000, icon: '' },
            { day: 3, type: 'stars', amount: 5, icon: '' },
            { day: 4, type: 'cash', amount: 2000, icon: '' },
            { day: 5, type: 'stars', amount: 10, icon: '' },
            { day: 6, type: 'cash', amount: 3000, icon: '' },
            { day: 7, type: 'stars', amount: 20, icon: '', bonus: true }
        ];
        
        function initializeDailyRewards() {
            try {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                if (!characterData) return;
                
                const gameState = characterData.gameState;
                
                // Initialize daily rewards data if not exists
                if (!gameState.dailyRewards) {
                    gameState.dailyRewards = {
                        streak: 0,
                        lastClaimDate: null,
                        claimedDays: []
                    };
                    saveGameSync(characterData);
                }
            } catch (error) {
                console.error('Error initializing daily rewards:', error);
            }
        }
        
        function openDailyRewards() {
            showScreen('dailyRewardsScreen');
            loadDailyRewards();
        }
        
        function loadDailyRewards() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const dailyData = characterData.gameState.dailyRewards;
            
            // Check if streak should be reset
            checkDailyStreak(characterData);
            
            // Streak display
            const streakDiv = document.getElementById('dailyStreak');
            streakDiv.innerHTML = `
                <div class="daily-streak-icon"></div>
                <div class="daily-streak-label">  </div>
                <div class="daily-streak-value">${dailyData.streak} ${getDaysWord(dailyData.streak)}</div>
            `;
            
            // Main content
            const content = document.getElementById('dailyContent');
            
            // Check if can claim today
            const canClaim = canClaimToday(dailyData);
            const nextDay = dailyData.streak + 1;
            const nextReward = DAILY_REWARDS[(nextDay - 1) % 7];
            
            content.innerHTML = `
                <!-- Calendar -->
                <div class="daily-calendar">
                    ${DAILY_REWARDS.map((reward, index) => {
                        const day = index + 1;
                        const isClaimed = dailyData.claimedDays.includes(day);
                        const isToday = day === nextDay && canClaim;
                        const isLocked = day > nextDay;
                        
                        return `
                            <div class="daily-day ${isClaimed ? 'claimed' : ''} ${isToday ? 'today' : ''} ${isLocked ? 'locked' : ''}">
                                ${isClaimed ? '<div class="daily-day-check"></div>' : ''}
                                <div class="daily-day-number"> ${day}</div>
                                <div class="daily-day-reward">${reward.icon}</div>
                                <div class="daily-day-value">${reward.type === 'cash' ? '$' + reward.amount : reward.amount}</div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <!-- Claim Section -->
                <div class="daily-claim-section">
                    ${canClaim ? `
                        <div class="daily-claim-icon">${nextReward.icon}</div>
                        <div class="daily-claim-text"> ${nextDay}</div>
                        <div class="daily-claim-value">
                            ${nextReward.type === 'cash' ? '$' + nextReward.amount.toLocaleString() : ' ' + nextReward.amount}
                        </div>
                        ${nextReward.bonus ? '<div style="color: var(--gold); margin-bottom: 1rem;">  !</div>' : ''}
                        <button class="daily-claim-button" onclick="claimDailyReward()">
                              
                        </button>
                    ` : `
                        <div class="daily-claim-icon"></div>
                        <div class="daily-claim-text">  !</div>
                        <div class="daily-timer" id="dailyTimer"></div>
                        <button class="daily-claim-button" disabled>
                             
                        </button>
                    `}
                    
                    ${nextDay < 7 ? `
                        <div class="daily-next-reward">
                            <div class="daily-next-label">  ( ${nextDay + 1}):</div>
                            <div class="daily-next-value">
                                ${DAILY_REWARDS[nextDay % 7].icon} ${DAILY_REWARDS[nextDay % 7].type === 'cash' ? '$' + DAILY_REWARDS[nextDay % 7].amount.toLocaleString() : ' ' + DAILY_REWARDS[nextDay % 7].amount}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            // Start timer if already claimed
            if (!canClaim) {
                startDailyTimer();
            }
        }
        
        function checkDailyStreak(characterData) {
            const dailyData = characterData.gameState.dailyRewards;
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            
            if (dailyData.lastClaimDate) {
                const lastClaim = new Date(dailyData.lastClaimDate);
                const lastClaimDay = new Date(lastClaim.getFullYear(), lastClaim.getMonth(), lastClaim.getDate()).getTime();
                const daysSince = Math.floor((today - lastClaimDay) / (24 * 60 * 60 * 1000));
                
                // Reset if missed more than 1 day
                if (daysSince > 1) {
                    dailyData.streak = 0;
                    dailyData.claimedDays = [];
                    saveGameSync(characterData);
                }
            }
        }
        
        function canClaimToday(dailyData) {
            if (!dailyData.lastClaimDate) return true;
            
            const now = Date.now();
            const timeSinceLastClaim = now - dailyData.lastClaimDate;
            const hoursInMs = 24 * 60 * 60 * 1000; // 24   
            
            //    24 
            return timeSinceLastClaim >= hoursInMs;
        }
        
        function claimDailyReward() {
            hapticHeavy();
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const dailyData = gameState.dailyRewards;
            
            if (!canClaimToday(dailyData)) {
                showToast(' !', '    ', 'warning');
                return;
            }
            
            // Get next reward
            const nextDay = dailyData.streak + 1;
            const reward = DAILY_REWARDS[(nextDay - 1) % 7];
            
            // Apply reward
            if (reward.type === 'cash') {
                gameState.cash += reward.amount;
            } else if (reward.type === 'stars') {
                gameState.stars += reward.amount;
            }
            
            // Update streak
            dailyData.streak = nextDay;
            dailyData.lastClaimDate = Date.now();
            
            // Update claimed days
            if (!dailyData.claimedDays.includes(nextDay)) {
                dailyData.claimedDays.push(nextDay);
            }
            
            // Reset after 7 days
            if (dailyData.streak >= 7) {
                dailyData.streak = 0;
                dailyData.claimedDays = [];
            }
            
            saveGameSync(characterData);
            
            // Show success
            const rewardText = reward.type === 'cash' 
                ? `$${reward.amount.toLocaleString()}`
                : ` ${reward.amount}`;
            
            showToast('  !', `${reward.icon} ${rewardText}${reward.bonus ? '\n  !' : ''}`, 'success');
            
            // Reload screen
            setTimeout(() => {
                loadDailyRewards();
            }, 500);
        }
        
        function startDailyTimer() {
            const updateTimer = () => {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                const dailyData = characterData.gameState.dailyRewards;
                
                if (!dailyData.lastClaimDate) return;
                
                const now = Date.now();
                const nextClaimTime = dailyData.lastClaimDate + (24 * 60 * 60 * 1000); // +24 
                const remaining = nextClaimTime - now;
                
                if (remaining <= 0) {
                    const timerEl = document.getElementById('dailyTimer');
                    if (timerEl) {
                        timerEl.textContent = '  !';
                    }
                    return;
                }
                
                const hours = Math.floor(remaining / (60 * 60 * 1000));
                const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
                const seconds = Math.floor((remaining % (60 * 1000)) / 1000);
                
                const timerEl = document.getElementById('dailyTimer');
                if (timerEl) {
                    timerEl.textContent = `  : ${hours} ${minutes} ${seconds}`;
                }
            };
            
            updateTimer();
            setInterval(updateTimer, 1000); // Update every second
        }
        
        function getDaysWord(days) {
            if (days === 1) return '';
            if (days >= 2 && days <= 4) return '';
            return '';
        }
        
        function updateDailyBadge() {
            try {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                if (!characterData || !characterData.gameState || !characterData.gameState.dailyRewards) return;
                
                const dailyData = characterData.gameState.dailyRewards;
                const badge = document.getElementById('dailyBadge');
                
                if (badge && canClaimToday(dailyData)) {
                    badge.style.display = 'block';
                } else if (badge) {
                    badge.style.display = 'none';
                }
            } catch (error) {
                console.error('Error updating daily badge:', error);
            }
        }
        
        // ===== END DAILY REWARDS SYSTEM =====
        
        // ===== ACHIEVEMENTS SYSTEM =====
        
        const ACHIEVEMENTS = {
            // Milestone achievements -  
            first_win: {
                id: 'first_win',
                name: ' ',
                description: '   ',
                icon: '',
                category: '',
                reward: { type: 'cash', amount: 500 },
                check: (data) => data.gameState.totalWins >= 1
            },
            wins_5: {
                id: 'wins_5',
                name: '',
                description: ' 5 ',
                icon: '',
                category: '',
                reward: { type: 'cash', amount: 1000 },
                check: (data) => data.gameState.totalWins >= 5
            },
            wins_10: {
                id: 'wins_10',
                name: '',
                description: ' 10 ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 3 },
                check: (data) => data.gameState.totalWins >= 10
            },
            wins_25: {
                id: 'wins_25',
                name: '',
                description: ' 25 ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 5 },
                check: (data) => data.gameState.totalWins >= 25
            },
            wins_50: {
                id: 'wins_50',
                name: '',
                description: ' 50 ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 10 },
                check: (data) => data.gameState.totalWins >= 50
            },
            
            // Training achievements
            first_training: {
                id: 'first_training',
                name: ' ',
                description: ' - ',
                icon: '',
                category: '',
                reward: { type: 'cash', amount: 300 },
                check: (data) => (data.gameState.totalTrainings || 0) >= 1
            },
            trainings_10: {
                id: 'trainings_10',
                name: '',
                description: ' 10 ',
                icon: '',
                category: '',
                reward: { type: 'cash', amount: 1500 },
                check: (data) => (data.gameState.totalTrainings || 0) >= 10
            },
            trainings_25: {
                id: 'trainings_25',
                name: '',
                description: ' 25 ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 5 },
                check: (data) => (data.gameState.totalTrainings || 0) >= 25
            },
            
            // Stats achievements
            stat_50: {
                id: 'stat_50',
                name: '',
                description: ' 50  - ',
                icon: '',
                category: '',
                reward: { type: 'cash', amount: 2000 },
                check: (data) => {
                    return data.fighters.some(f => 
                        f.stats.power >= 50 || f.stats.speed >= 50 || 
                        f.stats.stamina >= 50 || f.stats.defense >= 50
                    );
                }
            },
            stat_75: {
                id: 'stat_75',
                name: '',
                description: ' 75  - ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 5 },
                check: (data) => {
                    return data.fighters.some(f => 
                        f.stats.power >= 75 || f.stats.speed >= 75 || 
                        f.stats.stamina >= 75 || f.stats.defense >= 75
                    );
                }
            },
            stat_100: {
                id: 'stat_100',
                name: '',
                description: ' 100  - ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 10 },
                check: (data) => {
                    return data.fighters.some(f => 
                        f.stats.power === 1000 || f.stats.speed === 1000 || 
                        f.stats.stamina === 1000 || f.stats.defense === 1000
                    );
                }
            },
            
            // Money achievements
            money_10k: {
                id: 'money_10k',
                name: '',
                description: ' $10,000',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 2 },
                check: (data) => data.gameState.cash >= 10000
            },
            money_50k: {
                id: 'money_50k',
                name: '',
                description: ' $50,000',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 5 },
                check: (data) => data.gameState.cash >= 50000
            },
            
            // Reputation achievements
            rep_500: {
                id: 'rep_500',
                name: '',
                description: ' 500 ',
                icon: '',
                category: '',
                reward: { type: 'cash', amount: 2000 },
                check: (data) => {
                    const fighter = data.fighters[data.activeFighterIndex];
                    return fighter.gameData && fighter.gameData.rating >= 500;
                }
            },
            rep_1000: {
                id: 'rep_1000',
                name: '',
                description: '  1000',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 5 },
                check: (data) => {
                    const fighter = data.fighters[data.activeFighterIndex];
                    return fighter.gameData && fighter.gameData.rating >= 1000;
                }
            },
            
            // Academy achievements
            second_fighter: {
                id: 'second_fighter',
                name: '',
                description: '  ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 3 },
                check: (data) => data.fighters.length >= 2
            },
            three_fighters: {
                id: 'three_fighters',
                name: ' ',
                description: '  ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 5 },
                check: (data) => data.fighters.length >= 3
            },
            
            // Talent achievements
            talent_8: {
                id: 'talent_8',
                name: '',
                description: '    8+',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 3 },
                check: (data) => data.fighters.some(f => f.talent >= 8)
            },
            talent_10: {
                id: 'talent_10',
                name: ' ',
                description: '    10',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 10 },
                check: (data) => data.fighters.some(f => f.talent === 10)
            },
            
            // Team achievements
            first_team_member: {
                id: 'first_team_member',
                name: '  ',
                description: ' ,   ',
                icon: '',
                category: '',
                reward: { type: 'cash', amount: 2000 },
                check: (data) => data.team && Object.keys(data.team.members || {}).length >= 1
            },
            full_team: {
                id: 'full_team',
                name: ' ',
                description: ' 3  ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 5 },
                check: (data) => data.team && Object.keys(data.team.members || {}).length >= 3
            },
            
            // Rating achievements
            rating_100: {
                id: 'rating_100',
                name: ' ',
                description: ' 100 ',
                icon: '',
                category: '',
                reward: { type: 'cash', amount: 1000 },
                check: (data) => {
                    const fighter = data.fighters[data.activeFighterIndex];
                    return fighter.gameData && fighter.gameData.rating >= 100;
                }
            },
            rating_300: {
                id: 'rating_300',
                name: ' ',
                description: ' 300 ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 3 },
                check: (data) => {
                    const fighter = data.fighters[data.activeFighterIndex];
                    return fighter.gameData && fighter.gameData.rating >= 300;
                }
            },
            
            // Fight difficulty achievements
            hard_opponent: {
                id: 'hard_opponent',
                name: '',
                description: '  ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 2 },
                check: (data) => (data.gameState.hardWins || 0) >= 1
            },
            hard_10: {
                id: 'hard_10',
                name: '',
                description: ' 10  ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 5 },
                check: (data) => (data.gameState.hardWins || 0) >= 10
            },
            
            // Championship achievements  
            first_belt: {
                id: 'first_belt',
                name: '!',
                description: '   ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 5 },
                check: (data) => {
                    const fighter = data.fighters[data.activeFighterIndex];
                    return fighter.belts && Object.keys(fighter.belts).length >= 1;
                }
            },
            three_belts: {
                id: 'three_belts',
                name: '',
                description: ' 3  ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 10 },
                check: (data) => {
                    const fighter = data.fighters[data.activeFighterIndex];
                    return fighter.belts && Object.keys(fighter.belts).length >= 3;
                }
            },
            
            // Daily bonus achievements
            daily_7: {
                id: 'daily_7',
                name: ' ',
                description: '   7  ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 3 },
                check: (data) => (data.gameState.dailyStreak || 0) >= 7
            },
            daily_30: {
                id: 'daily_30',
                name: ' ',
                description: '   30  ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 15 },
                check: (data) => (data.gameState.dailyStreak || 0) >= 30
            },
            
            // Money achievements (extended)
            money_100k: {
                id: 'money_100k',
                name: '',
                description: ' $100,000',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 10 },
                check: (data) => data.gameState.cash >= 100000
            },
            
            // Win streak achievements
            streak_5: {
                id: 'streak_5',
                name: '',
                description: ' 5  ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 3 },
                check: (data) => (data.gameState.winStreak || 0) >= 5
            },
            streak_10: {
                id: 'streak_10',
                name: '',
                description: ' 10  ',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 7 },
                check: (data) => (data.gameState.winStreak || 0) >= 10
            },
            
            // Special achievements
            daily_7: {
                id: 'daily_7',
                name: '',
                description: '    (7 )',
                icon: '',
                category: '',
                reward: { type: 'stars', amount: 10 },
                check: (data) => (data.gameState.dailyRewards?.streak || 0) >= 7
            },
            vip_first: {
                id: 'vip_first',
                name: 'VIP ',
                description: ' VIP ',
                icon: '',
                category: '',
                reward: { type: 'cash', amount: 3000 },
                check: (data) => data.gameState.vipUntil && data.gameState.vipUntil > Date.now()
            }
        };
        
        function initializeAchievements() {
            try {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                if (!characterData) return;
                
                const gameState = characterData.gameState;
                
                // Initialize achievements data if not exists
                if (!gameState.achievements) {
                    gameState.achievements = {
                        completed: [],
                        claimed: [],
                        totalClaimed: 0
                    };
                    saveGameSync(characterData);
                }
            } catch (error) {
                console.error('Error initializing achievements:', error);
            }
        }
        
        // ===== TEAM UI FUNCTIONS =====
        
        function openTeam() {
            showScreen('teamScreen');
            loadTeamScreen();
        }
        
        function loadTeamScreen() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            initializeTeam(characterData);
            
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            // Backward-compat: older saves may miss gameData
            fighter.gameData = fighter.gameData || {};
            console.log('=== TEAM SCREEN RATING DEBUG ===');
            console.log('fighter.gameData:', fighter.gameData);
            console.log('fighter.gameData.rating:', fighter.gameData?.rating);
            console.log('fighter.rating:', fighter.rating);
            
            const currentRating = (fighter.gameData?.rating ?? fighter.rating ?? 0);
            console.log('Displayed rating:', currentRating);
            
            // Update summary
            const memberCount = Object.keys(characterData.team.members).length;
            document.getElementById('teamCount').textContent = memberCount + '/3';
            document.getElementById('teamRating').textContent = currentRating;
            document.getElementById('teamExpenses').textContent = '$' + characterData.team.expenses.toLocaleString();
            document.getElementById('teamTotalSpent').textContent = '$' + characterData.team.totalSpent.toLocaleString();
            
            // Render
            renderCurrentTeam(characterData);
            renderAvailableTeam(characterData);
        }
        
        function renderCurrentTeam(characterData) {
            const container = document.getElementById('currentTeam');
            const members = Object.values(characterData.team.members);
            
            if (members.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 3rem 1rem; opacity: 0.4;">
                        <div style="font-size: 2.5rem; margin-bottom: 0.5rem;"></div>
                        <div style="font-size: 0.9rem;"> </div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = members.map(member => {
                const typeInfo = TEAM_MEMBER_TYPES[member.type];
                
                // Format bonuses
                const bonuses = [];
                if (member.bonuses.trainingBonus) bonuses.push({ icon: '', text: '+' + Math.round(member.bonuses.trainingBonus * 100) + '%' });
                if (member.bonuses.powerBonus) bonuses.push({ icon: '', text: '+' + member.bonuses.powerBonus });
                if (member.bonuses.healingSpeed) bonuses.push({ icon: '', text: '-' + Math.round((1 - member.bonuses.healingSpeed) * 100) + '%' });
                if (member.bonuses.injuryResistance) bonuses.push({ icon: '', text: '-' + Math.round(member.bonuses.injuryResistance * 100) + '%' });
                if (member.bonuses.fightEarnings) bonuses.push({ icon: '', text: '+' + Math.round(member.bonuses.fightEarnings * 100) + '%' });
                
                return `
                    <div style="background: rgba(255,255,255,0.03); 
                                border: 1px solid rgba(255,255,255,0.1); 
                                border-radius: 12px; 
                                padding: 1rem; 
                                margin-bottom: 0.75rem;">
                        
                        <!-- Header -->
                        <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem;">
                            <div style="font-size: 2rem; line-height: 1;">${typeInfo.icon}</div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.95rem; font-weight: 600; color: white; margin-bottom: 0.2rem;">
                                    ${member.firstName} ${member.lastName}
                                </div>
                                <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">
                                    ${typeInfo.name}
                                </div>
                            </div>
                            <button onclick="fireMember('${member.type}')" 
                                    style="background: rgba(239,68,68,0.15); 
                                           color: #ef4444; 
                                           border: 1px solid rgba(239,68,68,0.3);
                                           padding: 0.5rem 0.75rem; 
                                           border-radius: 8px; 
                                           font-size: 0.8rem;
                                           font-weight: 600; 
                                           cursor: pointer;">
                                
                            </button>
                        </div>
                        
                        <!-- Bonuses -->
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.75rem;">
                            ${bonuses.map(bonus => `
                                <div style="background: rgba(255,255,255,0.05); 
                                            border: 1px solid rgba(255,255,255,0.1);
                                            border-radius: 6px; 
                                            padding: 0.4rem 0.6rem;
                                            display: flex;
                                            align-items: center;
                                            gap: 0.3rem;">
                                    <span style="font-size: 0.9rem;">${bonus.icon}</span>
                                    <span style="font-size: 0.75rem; font-weight: 600; color: rgba(255,255,255,0.9);">${bonus.text}</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <!-- Salary -->
                        <div style="padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem; margin-bottom: 0.2rem; text-transform: uppercase; letter-spacing: 0.5px;">
                                
                            </div>
                            <div style="color: #fbbf24; font-weight: 600; font-size: 0.95rem;">
                                $${member.salary.toLocaleString()}/
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderAvailableTeam(characterData) {
            const container = document.getElementById('availableTeam');
            const available = getAvailableTeamMembers(characterData);
            const gameState = characterData.gameState;
            
            let html = '';
            
            Object.entries(TEAM_MEMBER_TYPES).forEach(([typeId, typeInfo]) => {
                const members = available[typeId];
                if (!members || members.length === 0) return;
                
                members.forEach(member => {
                    const canHire = member.meetsRequirements && member.canAfford;
                    html += `
                        <div style="background: rgba(255,255,255,0.03); 
                                    border: 1px solid ${canHire ? 'rgba(255,255,255,0.15)' : 'rgba(255,255,255,0.08)'}; 
                                    border-radius: 12px; 
                                    padding: 1rem; 
                                    margin-bottom: 0.75rem;
                                    ${!canHire ? 'opacity: 0.5;' : ''}">
                            
                            <!-- Header -->
                            <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem;">
                                <div style="font-size: 2rem; line-height: 1;">${typeInfo.icon}</div>
                                <div style="flex: 1;">
                                    <div style="font-size: 0.95rem; font-weight: 600; color: white; margin-bottom: 0.2rem;">
                                        ${member.firstName} ${member.lastName}
                                    </div>
                                    <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">
                                        ${typeInfo.name}
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Costs -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.75rem;">
                                <div style="background: rgba(255,255,255,0.05); 
                                            border: 1px solid rgba(255,255,255,0.1);
                                            border-radius: 8px; 
                                            padding: 0.5rem; 
                                            text-align: center;">
                                    <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem; text-transform: uppercase; letter-spacing: 0.5px;"></div>
                                    <div style="font-size: 0.9rem; font-weight: 700; color: #fbbf24;">
                                        $${member.hiringCost.toLocaleString()}
                                    </div>
                                </div>
                                <div style="background: rgba(255,255,255,0.05); 
                                            border: 1px solid rgba(255,255,255,0.1);
                                            border-radius: 8px; 
                                            padding: 0.5rem; 
                                            text-align: center;">
                                    <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem; text-transform: uppercase; letter-spacing: 0.5px;"></div>
                                    <div style="font-size: 0.9rem; font-weight: 700; color: #ef4444;">
                                        $${member.salary.toLocaleString()}
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Requirements Info (Always shown) -->
                            ${member.requirements && member.requirements.rating !== undefined ? `
                                <div style="background: rgba(255,255,255,0.05); 
                                            border: 1px solid ${member.meetsRequirements ? 'rgba(74,222,128,0.2)' : 'rgba(239,68,68,0.2)'}; 
                                            border-radius: 8px; 
                                            padding: 0.6rem; 
                                            margin-bottom: 0.75rem; 
                                            display: flex;
                                            align-items: center;
                                            justify-content: space-between;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="font-size: 0.75rem; color: rgba(255,255,255,0.7);">
                                             :
                                        </span>
                                        <span style="font-size: 0.8rem; font-weight: 700; color: ${member.meetsRequirements ? '#4ade80' : '#fbbf24'};">
                                            ${member.requirements.rating}
                                        </span>
                                    </div>
                                    <div style="font-size: 1rem;">
                                        ${member.meetsRequirements ? '' : ''}
                                    </div>
                                </div>
                            ` : ''}
                            
                            ${!member.meetsRequirements && !member.requirements.rating ? `
                                <div style="background: rgba(239,68,68,0.1); 
                                            border: 1px solid rgba(239,68,68,0.2); 
                                            border-radius: 8px; 
                                            padding: 0.6rem; 
                                            margin-bottom: 0.75rem; 
                                            font-size: 0.75rem; 
                                            color: #ef4444;
                                            text-align: center;">
                                     ${member.missingRequirements.join(', ')}
                                </div>
                            ` : ''}
                            
                            <!-- Hire Button -->
                            <button onclick="hireMember('${member.id}')" 
                                    ${!canHire ? 'disabled' : ''}
                                    style="width: 100%; 
                                           background: ${canHire ? 'rgba(255,255,255,0.1)' : 'rgba(255,255,255,0.03)'}; 
                                           color: ${canHire ? 'white' : 'rgba(255,255,255,0.4)'}; 
                                           border: 1px solid ${canHire ? 'rgba(255,255,255,0.2)' : 'rgba(255,255,255,0.08)'}; 
                                           padding: 0.75rem; 
                                           border-radius: 10px; 
                                           font-size: 0.85rem;
                                           font-weight: 600; 
                                           cursor: ${canHire ? 'pointer' : 'not-allowed'};">
                                ${!member.canAfford ? '  ' : 
                                  !member.meetsRequirements ? ' ' : 
                                  '  $' + member.hiringCost.toLocaleString()}
                            </button>
                        </div>
                    `;
                });
            });
            
            if (html === '') {
                html = `
                    <div style="text-align: center; padding: 3rem 1rem; opacity: 0.4;">
                        <div style="font-size: 2.5rem; margin-bottom: 0.5rem;"></div>
                        <div style="font-size: 0.9rem;"> </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        function hireMember(memberId) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const result = hireTeamMember(characterData, memberId);
            
            if (result.success) {
                const member = TEAM_MEMBERS[memberId];
                showToast('  ' + member.firstName + ' ' + member.lastName + '!', '', 'success');
                saveGameSync(characterData);
                loadTeamScreen();
            } else {
                showToast(' ', result.error, 'error');
            }
        }
        
        function fireMember(memberType) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const member = characterData.team.members[memberType];
            
            if (confirm(' ' + member.firstName + ' ' + member.lastName + '?')) {
                const result = fireTeamMember(characterData, memberType);
                
                if (result.success) {
                    showToast(' ', '', 'info');
                    saveGameSync(characterData);
                    loadTeamScreen();
                }
            }
        }
        
        function openAchievements() {
            showScreen('achievementsScreen');
            loadAchievements();
        }
        
        function loadAchievements() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            
            // Initialize achievements if not exists
            if (!characterData.gameState.achievements) {
                characterData.gameState.achievements = {
                    completed: [],
                    claimed: [],
                    notified: [],
                    totalClaimed: 0
                };
                saveGameSync(characterData);
            }
            
            // Ensure all arrays exist
            if (!characterData.gameState.achievements.completed) {
                characterData.gameState.achievements.completed = [];
            }
            if (!characterData.gameState.achievements.claimed) {
                characterData.gameState.achievements.claimed = [];
            }
            if (!characterData.gameState.achievements.notified) {
                characterData.gameState.achievements.notified = [];
            }
            if (typeof characterData.gameState.achievements.totalClaimed === 'undefined') {
                characterData.gameState.achievements.totalClaimed = 0;
            }
            
            const achievementsData = characterData.gameState.achievements;
            
            // Check if ACHIEVEMENTS exists
            if (typeof ACHIEVEMENTS === 'undefined') {
                const content = document.getElementById('achievementsContent');
                content.innerHTML = '<div style="text-align: center; padding: 3rem; opacity: 0.7;">   </div>';
                
                const summary = document.getElementById('achievementsSummary');
                summary.innerHTML = '';
                return;
            }
            
            // Check for new completions
            try {
                checkAchievements(characterData);
            } catch (error) {
                console.error('Error checking achievements:', error);
            }
            
            // Count completed and claimed
            const completed = achievementsData.completed.length;
            const claimed = achievementsData.claimed ? achievementsData.claimed.length : 0;
            const total = Object.keys(ACHIEVEMENTS).length;
            const unclaimed = completed - claimed;
            
            // Summary
            const summary = document.getElementById('achievementsSummary');
            summary.innerHTML = `
                <div class="achievement-summary-item">
                    <div class="achievement-summary-value">${completed}/${total}</div>
                    <div class="achievement-summary-label"></div>
                </div>
                <div class="achievement-summary-item">
                    <div class="achievement-summary-value">${claimed}</div>
                    <div class="achievement-summary-label"></div>
                </div>
                <div class="achievement-summary-item">
                    <div class="achievement-summary-value" style="${unclaimed > 0 ? 'color: #4ade80;' : ''}">${unclaimed}</div>
                    <div class="achievement-summary-label"></div>
                </div>
            `;
            
            // Group achievements by category
            const categories = {};
            Object.values(ACHIEVEMENTS).forEach(achievement => {
                if (!categories[achievement.category]) {
                    categories[achievement.category] = [];
                }
                categories[achievement.category].push(achievement);
            });
            
            // Render achievements
            const content = document.getElementById('achievementsContent');
            content.innerHTML = '';
            
            Object.entries(categories).forEach(([category, achievements]) => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'achievement-category';
                
                let categoryHTML = `<div class="achievement-category-title">${category}</div>`;
                
                achievements.forEach(achievement => {
                    const isCompleted = achievementsData.completed.includes(achievement.id);
                    const isClaimed = achievementsData.claimed && achievementsData.claimed.includes(achievement.id);
                    
                    let progress = { current: 0, target: 1, percentage: 0 };
                    try {
                        progress = getAchievementProgress(achievement, characterData);
                    } catch (error) {
                        console.error('Error getting progress for', achievement.id, error);
                    }
                    
                    categoryHTML += `
                        <div class="achievement-item ${isCompleted ? 'completed' : 'locked'}">
                            <div class="achievement-icon">${achievement.icon}</div>
                            <div class="achievement-info">
                                <div class="achievement-name">${achievement.name}</div>
                                <div class="achievement-description">${achievement.description}</div>
                                ${!isCompleted ? `
                                    <div class="achievement-progress">
                                        <div class="achievement-progress-bar">
                                            <div class="achievement-progress-fill" style="width: ${progress.percentage}%"></div>
                                        </div>
                                        <div class="achievement-progress-text">${progress.current}/${progress.target}</div>
                                    </div>
                                ` : ''}
                            </div>
                            <div class="achievement-reward">
                                <div class="achievement-reward-value">
                                    ${achievement.reward.type === 'cash' ? '$' + achievement.reward.amount : '' + achievement.reward.amount}
                                </div>
                                ${isCompleted && !isClaimed ? `
                                    <button class="achievement-claim-btn" onclick="claimAchievement('${achievement.id}')">
                                        
                                    </button>
                                ` : ''}
                                ${isClaimed ? `<div class="achievement-reward-label"> </div>` : ''}
                            </div>
                        </div>
                    `;
                });
                
                categoryDiv.innerHTML = categoryHTML;
                content.appendChild(categoryDiv);
            });
        }
        
        function checkAchievements(characterData) {
            // Initialize achievements if not exists
            if (!characterData.gameState.achievements) {
                characterData.gameState.achievements = {
                    completed: [],
                    claimed: [],
                    notified: [],
                    totalClaimed: 0
                };
            }
            
            const achievementsData = characterData.gameState.achievements;
            
            // Initialize arrays if not exists
            if (!achievementsData.completed) {
                achievementsData.completed = [];
            }
            if (!achievementsData.claimed) {
                achievementsData.claimed = [];
            }
            if (!achievementsData.notified) {
                achievementsData.notified = [];
            }
            if (typeof achievementsData.totalClaimed === 'undefined') {
                achievementsData.totalClaimed = 0;
            }
            
            let hasNewCompletions = false;
            
            // Check if ACHIEVEMENTS object exists
            if (typeof ACHIEVEMENTS === 'undefined') {
                console.log('ACHIEVEMENTS not defined, skipping check');
                return;
            }
            
            Object.values(ACHIEVEMENTS).forEach(achievement => {
                // Skip if already completed
                if (achievementsData.completed.includes(achievement.id)) return;
                
                // Check if completed now
                if (achievement.check(characterData)) {
                    achievementsData.completed.push(achievement.id);
                    hasNewCompletions = true;
                    
                    // Show notification
                    setTimeout(() => {
                        if (typeof showToast === 'function') {
                            showToast(
                                '  !',
                                `${achievement.icon} ${achievement.name}`,
                                'success'
                            );
                        }
                    }, 500);
                }
            });
            
            if (hasNewCompletions) {
                saveGameSync(characterData);
                updateAchievementsBadge();
            }
        }
        
        function getAchievementProgress(achievement, characterData) {
            // Extract target from check function (simplified)
            let current = 0;
            let target = 1;
            
            if (achievement.id.startsWith('wins_')) {
                current = characterData.gameState.totalWins || 0;
                target = parseInt(achievement.id.split('_')[1]);
            } else if (achievement.id.startsWith('trainings_')) {
                current = characterData.gameState.totalTrainings || 0;
                target = parseInt(achievement.id.split('_')[1]);
            } else if (achievement.id.startsWith('money_')) {
                current = characterData.gameState.cash || 0;
                target = parseInt(achievement.id.split('_')[1].replace('k', '000'));
            } else if (achievement.id.startsWith('stat_')) {
                const targetStat = parseInt(achievement.id.split('_')[1]);
                current = Math.max(...characterData.fighters.flatMap(f => [
                    f.stats.power, f.stats.speed, f.stats.stamina, f.stats.defense
                ]));
                target = targetStat;
            } else if (achievement.id === 'second_fighter') {
                current = characterData.fighters.length;
                target = 2;
            } else if (achievement.id === 'daily_7') {
                current = characterData.gameState.dailyRewards?.streak || 0;
                target = 7;
            } else {
                current = achievement.check(characterData) ? 1 : 0;
                target = 1;
            }
            
            return {
                current: Math.min(current, target),
                target: target,
                percentage: Math.min((current / target) * 100, 100)
            };
        }
        
        function claimAchievement(achievementId) {
            hapticHeavy();
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // Initialize achievements if not exists
            if (!gameState.achievements) {
                gameState.achievements = {
                    completed: [],
                    claimed: [],
                    totalClaimed: 0
                };
            }
            
            // Ensure claimed array exists
            if (!gameState.achievements.claimed) {
                gameState.achievements.claimed = [];
            }
            
            // Ensure completed array exists
            if (!gameState.achievements.completed) {
                gameState.achievements.completed = [];
            }
            
            const achievementsData = gameState.achievements;
            const achievement = ACHIEVEMENTS[achievementId];
            
            if (!achievement) {
                console.error('Achievement not found:', achievementId);
                showToast('!', '  ', 'error');
                return;
            }
            
            // Check if already claimed
            if (achievementsData.claimed.includes(achievementId)) {
                showToast(' !', 'error');
                return;
            }
            
            // Check if completed
            if (!achievementsData.completed.includes(achievementId)) {
                showToast(' !', 'error');
                return;
            }
            
            // Apply reward
            if (achievement.reward.type === 'cash') {
                gameState.cash += achievement.reward.amount;
            } else if (achievement.reward.type === 'stars') {
                gameState.stars += achievement.reward.amount;
            }
            
            // Mark as claimed
            achievementsData.claimed.push(achievementId);
            achievementsData.totalClaimed++;
            
            saveGameSync(characterData);
            
            // Show success
            const rewardText = achievement.reward.type === 'cash' 
                ? `$${achievement.reward.amount}`
                : `${achievement.reward.amount}`;
            
            showToast('  !', `${achievement.icon} ${rewardText}`, 'success');
            
            // Reload screen
            setTimeout(() => {
                loadAchievements();
                updateAchievementsBadge();
            }, 500);
        }
        
        function updateAchievementsBadge() {
            try {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                if (!characterData || !characterData.gameState.achievements) return;
                
                const achievementsData = characterData.gameState.achievements;
                const unclaimed = achievementsData.completed.length - achievementsData.claimed.length;
                
                const badge = document.getElementById('achievementsBadge');
                const countEl = document.getElementById('achievementsCount');
                
                if (badge) {
                    badge.style.display = unclaimed > 0 ? 'block' : 'none';
                }
                
                if (countEl) {
                    countEl.textContent = `${achievementsData.claimed.length}/${Object.keys(ACHIEVEMENTS).length}`;
                }
            } catch (error) {
                console.error('Error updating achievements badge:', error);
            }
        }
        
        // ===== END ACHIEVEMENTS SYSTEM =====
        
        // Loading screen - auto show prologue ONLY for new players
        let introTimer = null;
        
        function startIntroSequence() {
            introTimer = setTimeout(() => {
                showPrologue();
            }, 2500);
        }
        
        function cancelIntroSequence() {
            if (introTimer) {
                clearTimeout(introTimer);
                introTimer = null;
                console.log(' Intro sequence cancelled');
            }
        }
        
        function showScreen(screenId) {
            console.log(` showScreen called: ${screenId}`);
            console.trace('Call stack:'); //   
            
            // Haptic feedback
            hapticLight();
            
            // Hide all screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active', 'hiding');
            });
            
            const newScreen = document.getElementById(screenId);
            
            // Reset animations for prologue
            if (screenId === 'prologueScreen') {
                const lines = newScreen.querySelectorAll('.prologue-line');
                lines.forEach(line => {
                    line.classList.remove('fade-in');
                });
            }
            
            // Reset animations for street walk
            if (screenId === 'streetWalkScreen') {
                const lines = newScreen.querySelectorAll('.street-walk-line');
                lines.forEach(line => {
                    line.classList.remove('fade-in');
                });
            }
            
            // Show new screen
            newScreen.classList.add('active');
        }
        
        function showPrologue() {
            showScreen('prologueScreen');
            
            // Cinematic text reveal
            const lines = document.querySelectorAll('.prologue-line');
            const continueBtn = document.getElementById('continueBtn');
            
            lines.forEach((line, index) => {
                setTimeout(() => {
                    line.classList.add('fade-in');
                }, index * 800); // 800ms delay between each line
            });
            
            // Show button after all text
            setTimeout(() => {
                continueBtn.style.animation = 'fadeInButton 1s ease-out forwards';
            }, lines.length * 800 + 500);
        }
        
        function showCharacterCreation() {
            showScreen('characterScreen');
        }
        
        // Check form validity on input
        document.getElementById('managerNameInput').addEventListener('input', checkFormValidity);
        document.getElementById('managerAge').addEventListener('input', checkFormValidity);
        document.getElementById('managerCountry').addEventListener('change', checkFormValidity);
        document.getElementById('managerCity').addEventListener('input', checkFormValidity);
        
        function checkFormValidity() {
            const name = document.getElementById('managerNameInput').value.trim();
            const age = document.getElementById('managerAge').value;
            const country = document.getElementById('managerCountry').value;
            const city = document.getElementById('managerCity').value.trim();
            const startButton = document.getElementById('startButton');
            
            if (name.length >= 2 && age >= 8 && age <= 99 && country && city.length >= 2) {
                startButton.disabled = false;
            } else {
                startButton.disabled = true;
            }
        }
        
        function startGame() {
            const nameInput = document.getElementById('managerNameInput').value.trim();
            const age = document.getElementById('managerAge').value;
            const country = document.getElementById('managerCountry').value;
            const cityInput = document.getElementById('managerCity').value.trim();
            
            // Validate name (must have first and last name)
            const nameParts = nameInput.split(' ').filter(part => part.length > 0);
            if (nameParts.length < 2) {
                alert('  \'    !\n:  ');
                return;
            }
            
            const firstName = nameParts[0];
            const lastName = nameParts.slice(1).join(' ');
            
            if (firstName.length < 2 || lastName.length < 2) {
                alert(' \'      2 !');
                return;
            }
            
            // Validate city (only letters, spaces, and hyphens)
            const cityRegex = /^[A-Za-z--\s\-']+$/;
            if (!cityRegex.test(cityInput)) {
                alert('     !\n: , -');
                return;
            }
            
            if (age < 8 || age > 99 || !country || cityInput.length < 2) {
                alert('  ,    !');
                return;
            }
            
            // Save character data
            const characterData = {
                name: nameInput,
                firstName: firstName,
                lastName: lastName,
                age: parseInt(age),
                country: country,
                city: cityInput,
                createdAt: new Date().toISOString()
            };
            
            // Save to localStorage
            saveGameSync(characterData);
            
            // Send data to Telegram
            tg.sendData(JSON.stringify({
                action: 'character_created',
                data: characterData
            }));
            
            // Show success message
            document.querySelector('.form-container').innerHTML = `
                <div style="text-align: center; padding: 2rem;">
                    <div style="font-family: 'Oswald', sans-serif; font-size: 1.8rem; color: var(--gold); margin-bottom: 1rem;">
                        ${nameInput}
                    </div>
                    <div style="font-size: 1rem; opacity: 0.7; margin-bottom: 0.5rem;">
                        ${age} 
                    </div>
                    <div style="font-size: 1rem; opacity: 0.7; margin-bottom: 2rem;">
                        ${cityInput}, ${country}
                    </div>
                    <div style="font-size: 1.2rem; opacity: 0.8; line-height: 1.8;">
                         !
                    </div>
                </div>
            `;
            
            // Transition to street walk scene
            setTimeout(() => {
                showStreetWalk();
            }, 2000);
        }
        
        // STREET WALK TRANSITION
        function showStreetWalk() {
            showScreen('streetWalkScreen');
            
            // Cinematic text reveal
            const lines = document.querySelectorAll('.street-walk-line');
            
            lines.forEach((line, index) => {
                setTimeout(() => {
                    line.classList.add('fade-in');
                }, index * 900); // 900ms delay between lines
            });
            
            // Transition to fighter selection after all text
            setTimeout(() => {
                showStreetTournament();
            }, lines.length * 900 + 1500);
        }
        
        // STREET TOURNAMENT
        function showStreetTournament() {
            showScreen('streetScreen');
            generateFighters();
        }
        
        function generateFighters() {
            const firstNames = ['', '', '', '', '', '', '', ''];
            const lastNames = ['', '', '', '', '', '', '', ''];
            const nicknames = ['', '', '', '', '', '', '', ''];
            
            // Fighter avatars (different boxer types)
            const avatars = ['', '', '', '', '', ''];
            
            const fighters = [];
            const numFighters = 3; // Generate 3 fighters
            
            for (let i = 0; i < numFighters; i++) {
                // Weighted talent distribution (lower = more common)
                // 3-5: 60% chance (common)
                // 6-7: 30% chance (uncommon)
                // 8-9: 9% chance (rare)
                // 10: 1% chance (legendary)
                let talent;
                const rand = Math.random();
                if (rand < 0.01) {
                    talent = 10; // 1% - legendary
                } else if (rand < 0.10) {
                    talent = Math.random() < 0.5 ? 8 : 9; // 9% - rare
                } else if (rand < 0.40) {
                    talent = Math.random() < 0.5 ? 6 : 7; // 30% - uncommon
                } else {
                    talent = Math.floor(Math.random() * 3) + 3; // 60% - common (3-5)
                }
                
                const age = Math.floor(Math.random() * 8) + 18; // 18-25
                const weight = Math.floor(Math.random() * 20) + 65; // 65-84 kg
                
                // Balanced stats:   =   ( )
                //  10:   ~5-10 ( ,   )
                //  5:   ~15-20 ()
                //  2:   ~20-25 ( ,   )
                const baseStats = 30 - (talent * 2); //   ,   
                const variance = 5;
                
                fighters.push({
                    id: i,
                    firstName: firstNames[Math.floor(Math.random() * firstNames.length)],
                    lastName: lastNames[Math.floor(Math.random() * lastNames.length)],
                    nickname: nicknames[Math.floor(Math.random() * nicknames.length)],
                    avatar: avatars[Math.floor(Math.random() * avatars.length)],
                    age: age,
                    weight: weight,
                    talent: talent,
                    stats: {
                        power: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance))),
                        speed: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance))),
                        stamina: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance))),
                        defense: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance)))
                    }
                });
            }
            
            renderFighters(fighters);
        }
        
        let selectedFighterData = null;
        let generatedOpponents = []; // Store opponents globally
        
        function renderFighters(fighters) {
            const grid = document.getElementById('fightersGrid');
            grid.innerHTML = '';
            
            fighters.forEach(fighter => {
                const talentBonus = getTalentBonus(fighter.talent);
                const card = document.createElement('div');
                card.className = 'fighter-card';
                card.onclick = () => selectFighter(fighter);
                
                card.innerHTML = `
                    <div class="fighter-avatar">${fighter.avatar}</div>
                    <div class="fighter-header">
                        <div>
                            <div class="fighter-name">${fighter.firstName} "${fighter.nickname}" ${fighter.lastName}</div>
                            <div class="fighter-nickname"> </div>
                        </div>
                        <div class="talent-badge">
                             ${fighter.talent}
                        </div>
                    </div>
                    
                    <div class="fighter-basics">
                        <span> ${fighter.age} </span>
                        <span> ${fighter.weight} </span>
                    </div>
                    
                    <div class="fighter-stats">
                        <div>
                            <div class="stat-item">
                                <span class="stat-label"></span>
                                <span class="stat-value">${fighter.stats.power}</span>
                            </div>
                            <div class="stat-bar">
                                <div class="stat-fill" style="width: ${fighter.stats.power}%"></div>
                            </div>
                        </div>
                        
                        <div>
                            <div class="stat-item">
                                <span class="stat-label"></span>
                                <span class="stat-value">${fighter.stats.speed}</span>
                            </div>
                            <div class="stat-bar">
                                <div class="stat-fill" style="width: ${fighter.stats.speed}%"></div>
                            </div>
                        </div>
                        
                        <div>
                            <div class="stat-item">
                                <span class="stat-label"></span>
                                <span class="stat-value">${fighter.stats.stamina}</span>
                            </div>
                            <div class="stat-bar">
                                <div class="stat-fill" style="width: ${fighter.stats.stamina}%"></div>
                            </div>
                        </div>
                        
                        <div>
                            <div class="stat-item">
                                <span class="stat-label"></span>
                                <span class="stat-value">${fighter.stats.defense}</span>
                            </div>
                            <div class="stat-bar">
                                <div class="stat-fill" style="width: ${fighter.stats.defense}%"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="talent-description">
                          <span class="talent-bonus">+${talentBonus}%</span>    
                    </div>
                `;
                
                grid.appendChild(card);
            });
        }
        
        function getTalentBonus(talent) {
            // Calculate bonus based on talent level
            if (talent <= 3) return 10;
            if (talent <= 5) return 25;
            if (talent <= 7) return 45;
            if (talent <= 9) return 70;
            return 100; // talent 10
        }
        
        function selectFighter(fighter) {
            console.log('selectFighter called with:', fighter);
            selectedFighterData = fighter;
            
            // Show confirmation modal
            const modal = document.getElementById('confirmModal');
            console.log('Modal element:', modal);
            
            document.getElementById('modalAvatar').textContent = fighter.avatar;
            document.getElementById('modalFighterName').textContent = 
                `${fighter.firstName} "${fighter.nickname}" ${fighter.lastName}`;
            
            modal.classList.add('active');
            console.log('Modal classList after add:', modal.classList);
        }
        
        function closeModal() {
            document.getElementById('confirmModal').classList.remove('active');
            selectedFighterData = null;
        }
        
        function confirmFighterSelection() {
            if (!selectedFighterData) return;
            
            const fighter = selectedFighterData;
            
            // Initialize gameData for the fighter
            fighter.gameData = {
                record: { wins: 0, losses: 0, draws: 0 },
                rating: 0, // Start at 0, no limit
                form: 100,
                experience: 0
            };
            
            // Initialize fightHistory
            fighter.fightHistory = [];
            
            // Save selected fighter
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            
            // Initialize fighters array and gameState
            characterData.fighters = [fighter];
            characterData.activeFighterIndex = 0;
            characterData.unlockedSlots = 1;
            
            // Welcome VIP bonus - 3 days for new players
            const vipEndTime = Date.now() + (3 * 24 * 60 * 60 * 1000); // 3 
            
            characterData.gameState = {
                cash: 2000,        //   5000
                stars: 50,         //   
                totalWins: 0,
                totalTrainings: 0,
                hardWins: 0,
                winStreak: 0,
                dailyStreak: 0,
                vipUntil: vipEndTime,  // VIP  3 
                isNewPlayer: true       //   
            };
            characterData.achievements = {};
            characterData.team = { members: {}, monthlyCost: 0 };
            
            // IMPORTANT: Save to localStorage
            saveGameSync(characterData);
            
            console.log(' Character data saved:', characterData);
            console.log(' VIP bonus activated until:', new Date(vipEndTime).toLocaleString('uk-UA'));
            
            // Send to Telegram
            tg.sendData(JSON.stringify({
                action: 'fighter_selected',
                data: fighter
            }));
            
            // Close modal
            closeModal();
            
            // Transition to main game
            setTimeout(() => {
                showMainGame();
            }, 2000);
        }
        
        // MAIN GAME SCREEN
        function showMainGame() {
            showScreen('gameScreen');
            loadGameData();
            
            // Show VIP welcome bonus for new players
            setTimeout(() => {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                if (characterData && characterData.gameState && characterData.gameState.isNewPlayer) {
                    const daysLeft = Math.ceil((characterData.gameState.vipUntil - Date.now()) / (24 * 60 * 60 * 1000));
                    
                    console.log(' Showing welcome bonus toast...');
                    
                    showToast(
                        '  !',
                        `VIP   ${daysLeft} \n $2,000 \n 50 \n\n !`,
                        'success'
                    );
                    
                    // Mark as shown
                    characterData.gameState.isNewPlayer = false;
                    saveGameSync(characterData);
                } else {
                    console.log(' No welcome bonus (not new player or data missing)');
                }
            }, 1500);
        }
        
        async function loadGameData() {
            console.log('loadGameData started');
            
            //     Cloud
            showLoading();
            const cloudResult = await loadGame();
            
            let characterData;
            
            if (cloudResult) {
                characterData = cloudResult;
                console.log(' Loaded from Cloud');
            } else {
                // Fallback  localStorage
                characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                console.log(' Loaded from localStorage');
            }
            
            hideLoading();
            
            if (!characterData) {
                alert('  !');
                return;
            }
            
            console.log('Character data loaded:', characterData);
            
            // Initialize fighters array (migrate old data) - DO THIS FIRST!
            if (!characterData.fighters) {
                if (!characterData.fighter) {
                    alert('  !');
                    return;
                }
                characterData.fighters = [characterData.fighter];
                characterData.activeFighterIndex = 0;
                characterData.unlockedSlots = 1;
                saveGameSync(characterData);
            }
            
            console.log('Before initializeAgingSystem');
            // Initialize and check aging system
            initializeAgingSystem();
            
            console.log('Before initializeDailyRewards');
            // Initialize daily rewards
            initializeDailyRewards();
            
            // Initialize achievements
            initializeAchievements();
            
            console.log('After daily rewards init');
            
            // Check if active fighter is retired
            const activeFighter = characterData.fighters[characterData.activeFighterIndex];
            if (activeFighter && activeFighter.retired) {
                alert('     \'!\n\n       .');
            }
            
            // Initialize game state if not exists
            if (!characterData.gameState) {
                characterData.gameState = {
                    cash: 50000, // TEST: Was 1000
                    stars: 1000, // TEST: Was 0
                    totalFighters: characterData.fighters.length,
                    totalWins: 0,
                    vipUntil: 0  // No VIP by default
                };
                
                saveGameSync(characterData);
            }
            
            const gameState = characterData.gameState;
            
            // Migrate old VIP format to new
            if (gameState.isVIP && gameState.vipEndTime) {
                gameState.vipUntil = gameState.vipEndTime;
                delete gameState.isVIP;
                delete gameState.vipEndTime;
                saveGameSync(characterData);
            }
            
            // Initialize VIP fields if missing
            if (gameState.vipUntil === undefined) {
                gameState.vipUntil = 0;
                saveGameSync(characterData);
            }
            
            if (gameState.isNewPlayer === undefined) {
                gameState.isNewPlayer = false;
                saveGameSync(characterData);
            }
            
            // Update MANAGER profile
            document.getElementById('managerAvatar').textContent = '';
            
            // FORCE update name ( )
            const nameElement = document.getElementById('managerName');
            if (nameElement) {
                nameElement.textContent = characterData.name;
                console.log(' Manager profile updated:', characterData.name);
                console.log('   Name element current text:', nameElement.textContent);
            } else {
                console.error(' managerName element not found in loadGameData!');
            }
            
            // Manager level  -  
            document.getElementById('managerLocation').textContent = `${characterData.city}, ${characterData.country}`;
            
            // Update VIP star and status
            const vipStar = document.getElementById('vipStar');
            const vipStatus = document.getElementById('vipStatus');
            
            if (gameState.vipUntil && gameState.vipUntil > Date.now()) {
                // VIP is active
                vipStar.classList.add('active');
                vipStatus.style.display = 'block';
                
                // Calculate remaining time
                const remaining = gameState.vipUntil - Date.now();
                const days = Math.floor(remaining / (24 * 60 * 60 * 1000));
                const hours = Math.floor((remaining % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
                
                if (days > 0) {
                    vipStatus.textContent = ` VIP: ${days}  ${hours} `;
                } else {
                    vipStatus.textContent = ` VIP: ${hours} `;
                }
            } else {
                // VIP is inactive
                vipStar.classList.remove('active');
                vipStatus.style.display = 'none';
                
                // Clean up expired VIP
                if (gameState.vipEndTime && gameState.vipEndTime <= Date.now()) {
                    gameState.isVIP = false;
                    delete gameState.vipEndTime;
                    saveGameSync(characterData);
                }
            }
            
            // Update manager stats
            document.getElementById('managerFighters').textContent = characterData.fighters.filter(f => !f.retired).length;
            document.getElementById('managerWins').textContent = gameState.totalWins;
            
            // Render fighters list
            renderFightersList();
            
            // Update resources
            const currentRating = (activeFighter.gameData && activeFighter.gameData.rating) || 0;
            
            document.getElementById('resourceCash').textContent = formatNumber(gameState.cash);
            document.getElementById('resourceStars').textContent = gameState.stars;
            document.getElementById('resourceRating').textContent = currentRating;
            
            // Update Cloud status
            updateCloudStatus();
            
            // Update daily rewards badge (after DOM is ready)
            setTimeout(() => {
                updateDailyBadge();
                updateAchievementsBadge();
                startInjuryTimer(); // Start injury timer update
            }, 100);
            
            console.log('loadGameData completed');
        }
        
        // Injury timer - updates every second
        let injuryTimerInterval = null;
        
        function startInjuryTimer() {
            // Clear existing timer
            if (injuryTimerInterval) {
                clearInterval(injuryTimerInterval);
            }
            
            // Update immediately
            updateInjuryTimers();
            
            // Then update every second
            injuryTimerInterval = setInterval(() => {
                updateInjuryTimers();
            }, 1000);
        }
        
        function updateInjuryTimers() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            if (!characterData || !characterData.fighters) return;
            
            characterData.fighters.forEach((fighter, index) => {
                if (!fighter || !fighter.injury) return;
                
                const remainingTime = fighter.injury.healTime - Date.now();
                
                if (remainingTime <= 0) {
                    // Injury healed!
                    delete fighter.injury;
                    saveGameSync(characterData);
                    showToast(`${fighter.firstName} ! `, 'success');
                    renderFightersList();
                } else {
                    // Update time display
                    const banners = document.querySelectorAll('.injury-status-banner');
                    banners.forEach(banner => {
                        const timeElement = banner.querySelector('.injury-status-time');
                        if (timeElement) {
                            timeElement.textContent = ` : ${formatInjuryTime(remainingTime)}`;
                        }
                    });
                }
            });
        }
        
        function renderFightersList() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fightersList = document.getElementById('fightersList');
            fightersList.innerHTML = '';
            
            const maxSlots = 2;
            const unlockedSlots = characterData.unlockedSlots || 1;
            
            // Render unlocked slots with fighters
            for (let i = 0; i < unlockedSlots; i++) {
                const fighter = characterData.fighters[i];
                if (fighter) {
                    fightersList.appendChild(createFighterCard(fighter, i, characterData.activeFighterIndex === i));
                }
            }
            
            // Render locked slots
            for (let i = unlockedSlots; i < maxSlots; i++) {
                fightersList.appendChild(createLockedSlotCard(i));
            }
        }
        
        function createFighterCard(fighter, index, isActive) {
            const card = document.createElement('div');
            card.className = 'fighter-slot' + (isActive ? ' active' : '');
            card.onclick = () => switchActiveFighter(index);
            
            // Initialize talent if missing (for old fighters)
            if (!fighter.talent) {
                fighter.talent = Math.floor(Math.random() * 8) + 3; // 3-10
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                saveGameSync(characterData);
            }
            
            if (!fighter.gameData) {
                fighter.gameData = {
                    rating: 1000,
                    form: calculateFormByAge(fighter.age),
                    record: { wins: 0, losses: 0, draws: 0 }
                };
            }
            
            card.innerHTML = `
                <div class="fighter-card-main" style="padding: 0; margin: 0; background: transparent; border: none;">
                    <div class="fighter-card-header">
                        <div class="fighter-card-avatar">${fighter.avatar}</div>
                        <div class="fighter-card-info">
                            <div class="fighter-card-name">${fighter.firstName} "${fighter.nickname}"</div>
                            <div class="fighter-card-stats">
                                <span>${fighter.age} </span>
                                <span>${fighter.weight} </span>
                                <span title="  +${getTalentBonus(fighter.talent)}%  "> ${fighter.talent}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="fighter-quick-stats">
                        <div class="fighter-quick-stat">
                            <div class="fighter-quick-stat-label"></div>
                            <div class="fighter-quick-stat-value">${Math.round((fighter.stats.power + fighter.stats.speed + fighter.stats.stamina + fighter.stats.defense) / 4)}</div>
                        </div>
                        <div class="fighter-quick-stat">
                            <div class="fighter-quick-stat-label"></div>
                            <div class="fighter-quick-stat-value">${fighter.gameData.form}%</div>
                        </div>
                        <div class="fighter-quick-stat">
                            <div class="fighter-quick-stat-label"></div>
                            <div class="fighter-quick-stat-value">${fighter.gameData.record.wins}-${fighter.gameData.record.losses}-${fighter.gameData.record.draws}</div>
                        </div>
                    </div>
                    
                    ${fighter.injury && fighter.injury.healTime > Date.now() ? `
                        <div class="injury-status-banner" onclick="event.stopPropagation(); openTreatmentModal();">
                            <div class="injury-status-header">
                                <div class="injury-status-name">${fighter.injury.name}</div>
                                <div class="injury-status-severity">${
                                    fighter.injury.severity === 'light' ? '' :
                                    fighter.injury.severity === 'medium' ? '' :
                                    fighter.injury.severity === 'heavy' ? '' : ''
                                }</div>
                            </div>
                            <div class="injury-status-time">
                                 : ${formatInjuryTime(fighter.injury.healTime - Date.now())}
                            </div>
                            <div class="injury-status-action">
                                   
                            </div>
                        </div>
                    ` : ''}
                    
                    <div style="background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); border-radius: 8px; padding: 0.8rem; margin: 1rem 0; text-align: center;">
                        <div style="color: rgba(255,255,255,0.7); font-size: 0.85rem; margin-bottom: 0.3rem;">
                              
                        </div>
                        <div style="color: var(--gold); font-size: 1.3rem; font-weight: 700;">
                            $${formatNumber(calculateFighterPrice(fighter))}
                        </div>
                    </div>
                    
                    ${isActive ? `
                        <div class="fighter-card-actions">
                            <button class="fighter-card-btn primary" onclick="event.stopPropagation(); openTraining()">
                                 
                            </button>
                            <button class="fighter-card-btn" onclick="event.stopPropagation(); openFights()">
                                 
                            </button>
                        </div>
                        <div class="fighter-card-actions" style="margin-top: 0.5rem;">
                            <button class="fighter-card-btn" onclick="event.stopPropagation(); openFighterDetails()">
                                 
                            </button>
                            <button class="fighter-card-btn" onclick="event.stopPropagation(); openSellFighterModal(${index})" 
                                    style="background: linear-gradient(135deg, #dc2626, #b91c1c); color: white;">
                                 
                            </button>
                        </div>
                    ` : `
                        <div style="text-align: center; padding: 0.5rem; opacity: 0.6; font-size: 0.85rem;">
                               
                        </div>
                    `}
                </div>
            `;
            
            return card;
        }
        
        function createLockedSlotCard(index) {
            const card = document.createElement('div');
            card.className = 'fighter-slot locked';
            card.id = `lockedSlot${index}`;
            
            card.innerHTML = `
                <div class="slot-locked-content collapsed" id="slotContent${index}">
                    <div class="slot-locked-header" onclick="toggleLockedSlot(${index})">
                        <div class="slot-locked-header-left">
                            <div class="slot-locked-icon"></div>
                            <div class="slot-locked-title"> </div>
                        </div>
                        <div class="slot-expand-icon" id="expandIcon${index}"></div>
                    </div>
                    
                    <div class="slot-locked-details" id="slotDetails${index}">
                        <div class="slot-locked-desc">
                            <strong> :</strong><br>
                            1   ( 100)<br>
                            2    <br>
                            3   <br><br>
                            <strong>:</strong><br>
                                <br>
                               <br>
                              
                        </div>
                        <button class="slot-unlock-button" onclick="event.stopPropagation(); unlockFighterSlot()">
                              100
                        </button>
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function toggleLockedSlot(index) {
            const content = document.getElementById(`slotContent${index}`);
            const details = document.getElementById(`slotDetails${index}`);
            const icon = document.getElementById(`expandIcon${index}`);
            
            content.classList.toggle('collapsed');
            details.classList.toggle('expanded');
            icon.classList.toggle('expanded');
        }
        
        function switchActiveFighter(index) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            
            if (characterData.fighters[index].retired) {
                alert('    \'!\n\n      .');
                return;
            }
            
            characterData.activeFighterIndex = index;
            saveGameSync(characterData);
            
            renderFightersList();
        }
        
        function unlockFighterSlot() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // Check if enough stars
            if (gameState.stars < 100) {
                showToast(' Stars!', `:  100\n :  ${gameState.stars}`, 'error');
                return;
            }
            
            // Check if already unlocked
            if (characterData.unlockedSlots >= 2) {
                showToast('  !', '', 'info');
                return;
            }
            
            // Deduct stars
            gameState.stars -= 100;
            characterData.unlockedSlots = 2;
            
            saveGameSync(characterData);
            
            showToast('  !', '   !\n    " "  " "', 'success');
            
            loadGameData();
            
            // Automatically open Academy after 2 seconds
            setTimeout(() => {
                openAcademy();
            }, 2500);
        }
        
        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }
        
        // Action handlers
        function openTraining() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const activeFighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (!activeFighter || activeFighter.retired) {
                alert('   !\n\n      .');
                return;
            }
            
            showScreen('trainingScreen');
            loadTrainingScreen();
        }
        
        function backToGame() {
            showScreen('gameScreen');
            loadGameData();
        }
        
        function updateResourceBar() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const activeFighter = characterData.fighters[characterData.activeFighterIndex];
            const currentRating = (activeFighter.gameData && activeFighter.gameData.rating) || 0;
            
            document.getElementById('resourceCash').textContent = formatNumber(gameState.cash);
            document.getElementById('resourceStars').textContent = gameState.stars;
            document.getElementById('resourceRating').textContent = currentRating;
        }
        
        // TRAINING SYSTEM - updated to work with active fighter
        
        
        // ========================================
        // RANKING SYSTEM WITH CHAMPIONSHIP BELTS
        // ========================================
        
        // RANKING TIERS
        const RANKING_TIERS = [
            {
                id: 'beginner',
                name: '',
                minRating: 0,
                maxRating: 99,
                icon: '',
                color: '#cd7f32',
                opponents: 3,
                // Fixed stat ranges for opponents - doesn't scale with player!
                opponentStats: {
                    easy: { min: 40, max: 60 },    // 
                    medium: { min: 60, max: 80 },  // 
                    hard: { min: 80, max: 100 }    // 
                }
            },
            {
                id: 'amateur',
                name: '',
                minRating: 100,
                maxRating: 299,
                icon: '',
                color: '#c0c0c0',
                opponents: 3,
                opponentStats: {
                    easy: { min: 100, max: 130 },
                    medium: { min: 130, max: 160 },
                    hard: { min: 160, max: 200 }
                }
            },
            {
                id: 'professional',
                name: '',
                minRating: 300,
                maxRating: 599,
                icon: '',
                color: '#ffd700',
                opponents: 4,
                opponentStats: {
                    easy: { min: 200, max: 250 },
                    medium: { min: 250, max: 300 },
                    hard: { min: 300, max: 370 }
                }
            },
            {
                id: 'contender',
                name: '',
                minRating: 600,
                maxRating: 999,
                icon: '',
                color: '#ff6b6b',
                opponents: 4,
                opponentStats: {
                    easy: { min: 370, max: 450 },
                    medium: { min: 450, max: 530 },
                    hard: { min: 530, max: 620 }
                }
            },
            {
                id: 'champion',
                name: '',
                minRating: 1000,
                maxRating: 9999,
                icon: '',
                color: '#9b59b6',
                opponents: 5,
                opponentStats: {
                    easy: { min: 620, max: 720 },
                    medium: { min: 720, max: 820 },
                    hard: { min: 820, max: 1000 }
                }
            }
        ];

        // CHAMPIONSHIP BELTS
// ========================================
// RANDOM EVENTS SYSTEM
// ========================================

const RANDOM_EVENTS = {
    // POSITIVE EVENTS
    interview: {
        id: 'interview',
        type: 'positive',
        title: '   \'',
        description: '      \'.    !',
        icon: '',
        rarity: 'common', // common, rare, epic, legendary
        choices: [
            {
                text: ' ',
                effects: {
                    time: 2 // hours
                },
                result: ' \'  ! +300 '
            },
            {
                text: ' ',
                effects: {},
                result: '   \''
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 100; // Only if rating 100+
        }
    },
    
    commercial: {
        id: 'commercial',
        type: 'positive',
        title: '  ',
        description: '       .  !',
        icon: '',
        rarity: 'rare',
        choices: [
            {
                text: '  ($8,000)',
                effects: {
                    cash: 8000,
                    time: 4
                },
                result: '   ! +$8,000'
            },
            {
                text: ' ',
                effects: {},
                result: '   '
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 300 && fighter.gameData.record.wins >= 10;
        }
    },
    
    charity: {
        id: 'charity',
        type: 'positive',
        title: '  ',
        description: '    .   ,   !',
        icon: '',
        rarity: 'common',
        choices: [
            {
                text: ' ',
                effects: {
                    time: 3
                },
                result: '    ! +1,000 '
            },
            {
                text: ' ',
                effects: {
                },
                result: '  .    (-200 REP)'
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 200;
        }
    },
    
    birthday: {
        id: 'birthday',
        type: 'positive',
        title: '  !',
        description: '   !      .',
        icon: '',
        rarity: 'epic',
        choices: [
            {
                text: ' ',
                effects: {
                    powerBonus: 5,
                    speedBonus: 5,
                    staminaBonus: 5,
                    defenseBonus: 5,
                    formBonus: 10,
                    duration: 7 // days
                },
                result: '  ! +5     !'
            }
        ],
        condition: (data) => {
            // Check if birthday already happened this year (game year = 365 days of events)
            if (!data.gameState.eventHistory) data.gameState.eventHistory = {};
            const lastBirthday = data.gameState.eventHistory.birthday || 0;
            const daysSinceLastBirthday = (Date.now() - lastBirthday) / (24 * 60 * 60 * 1000);
            return daysSinceLastBirthday > 365 || lastBirthday === 0; // Once per game year
        }
    },
    
    sponsorship: {
        id: 'sponsorship',
        type: 'positive',
        title: '  ',
        description: '     !',
        icon: '',
        rarity: 'epic',
        choices: [
            {
                text: '  ',
                effects: {
                    cash: 25000,
                    sponsor: {
                        name: 'SportTech',
                        duration: 30, // days
                        bonus: 0.15 // +15% cash from fights
                    }
                },
                result: '  ! +$25,000 + 15%      '
            },
            {
                text: ' ',
                effects: {},
                result: '  '
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 500 && fighter.gameData.record.wins >= 20;
        }
    },
    
    // NEGATIVE EVENTS
    scandal: {
        id: 'scandal',
        type: 'negative',
        title: '   ',
        description: '     .  !',
        icon: '',
        rarity: 'rare',
        choices: [
            {
                text: '  ',
                effects: {
                    cash: -5000
                },
                result: '  .  $5,000  500 REP'
            },
            {
                text: '  ($10,000)',
                effects: {
                    cash: -10000,
                },
                result: '  !   (+200),   $10,000'
            },
            {
                text: ' ',
                effects: {
                },
                result: '    . -1,500 '
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 300;
        }
    },
    
    injury_risk: {
        id: 'injury_risk',
        type: 'negative',
        title: '   ',
        description: '      . ,   ?',
        icon: '',
        rarity: 'common',
        choices: [
            {
                text: '    ($2,000)',
                effects: {
                    cash: -2000
                },
                result: '     .  !'
            },
            {
                text: '  ',
                effects: {
                    injuryRisk: 0.3 // 30% chance of injury
                },
                result: '   ...'
            }
        ],
        condition: (data) => true
    },
    
    doping_offer: {
        id: 'doping_offer',
        type: 'negative',
        title: '  ',
        description: '  " "    .  ...',
        icon: '',
        rarity: 'rare',
        choices: [
            {
                text: ' ',
                effects: {
                    powerBonus: 15,
                    speedBonus: 15,
                    staminaBonus: 15,
                    defenseBonus: 15,
                    duration: 14,
                    dopingFlag: true // Will cause issues later
                },
                result: '   ! +15    2 .    ?'
            },
            {
                text: ' ',
                effects: {
                },
                result: '    . +100 '
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 400;
        }
    },
    
    doping_test: {
        id: 'doping_test',
        type: 'negative',
        title: ' -',
        description: ' -!     -  .',
        icon: '',
        rarity: 'epic',
        choices: [
            {
                text: '  ',
                effects: {
                    dopingTest: true
                },
                result: '  ...'
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 500;
        }
    },
    
    // NEUTRAL EVENTS
    tv_show: {
        id: 'tv_show',
        type: 'neutral',
        title: '   -',
        description: ' -     .   !',
        icon: '',
        rarity: 'rare',
        choices: [
            {
                text: '  ',
                effects: {
                    cash: 3000
                },
                result: '   ! +500 REP, +$3,000'
            },
            {
                text: '  ',
                effects: {
                    cash: 5000,
                    hypeBonus: 1.5 // Next fight gets 1.5x attention
                },
                result: ' ! -300 REP,      (+50% )'
            },
            {
                text: '  ',
                effects: {
                    cash: 2000
                },
                result: '  . +100 REP, +$2,000'
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 400;
        }
    },
    
    marathon: {
        id: 'marathon',
        type: 'neutral',
        title: '  ',
        description: '    .    !',
        icon: '',
        rarity: 'common',
        choices: [
            {
                text: '  ',
                effects: {
                    staminaBonus: 8,
                    time: 4
                },
                result: '  ! +8 , +200 REP'
            },
            {
                text: ' ',
                effects: {},
                result: '  '
            }
        ],
        condition: (data) => true
    },
    
    sparring_offer: {
        id: 'sparring_offer',
        type: 'neutral',
        title: '  ',
        description: '    .   ,    .',
        icon: '',
        rarity: 'rare',
        choices: [
            {
                text: ' ',
                effects: {
                    powerBonus: 5,
                    speedBonus: 5,
                    injuryRisk: 0.2 // 20% injury risk
                },
                result: '  ! +5 , +5 , +300 REP'
            },
            {
                text: ' ',
                effects: {},
                result: '   '
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 200;
        }
    }
};

// Event rarity chances
const EVENT_RARITY_CHANCES = {
    common: 0.50,    // 50%
    rare: 0.30,      // 30%
    epic: 0.15,      // 15%
    legendary: 0.05  // 5%
};

// Check if event should trigger
function shouldTriggerEvent() {
    // Base 15% chance per action (fight, training, etc)
    return Math.random() < 0.15;
}

// Get random event based on rarity
function getRandomEvent(characterData) {
    // Determine rarity first
    const rand = Math.random();
    let targetRarity;
    
    if (rand < 0.05) targetRarity = 'legendary';
    else if (rand < 0.20) targetRarity = 'epic';
    else if (rand < 0.50) targetRarity = 'rare';
    else targetRarity = 'common';
    
    // Get all events of that rarity that meet conditions
    const availableEvents = Object.values(RANDOM_EVENTS).filter(event => {
        return event.rarity === targetRarity && 
               (!event.condition || event.condition(characterData));
    });
    
    if (availableEvents.length === 0) {
        // If no events available, try common
        const commonEvents = Object.values(RANDOM_EVENTS).filter(event => {
            return event.rarity === 'common' && 
                   (!event.condition || event.condition(characterData));
        });
        
        if (commonEvents.length === 0) return null;
        return commonEvents[Math.floor(Math.random() * commonEvents.length)];
    }
    
    return availableEvents[Math.floor(Math.random() * availableEvents.length)];
}

// Apply event choice effects
function applyEventEffects(characterData, effects) {
    const gameState = characterData.gameState;
    const fighter = characterData.fighters[characterData.activeFighterIndex];
    
    // Initialize event data if needed
    if (!fighter.eventData) {
        fighter.eventData = {
            activeBuffs: [],
            sponsor: null,
            dopingFlag: false,
            lastEvents: []
        };
    }
    
    // Apply immediate effects
    if (effects.cash) gameState.cash += effects.cash;
    
    // Apply temporary stat buffs
    if (effects.powerBonus || effects.speedBonus || effects.staminaBonus || effects.defenseBonus) {
        const buff = {
            id: Date.now(),
            power: effects.powerBonus || 0,
            speed: effects.speedBonus || 0,
            stamina: effects.staminaBonus || 0,
            defense: effects.defenseBonus || 0,
            form: effects.formBonus || 0,
            expiresAt: Date.now() + (effects.duration || 7) * 24 * 60 * 60 * 1000
        };
        fighter.eventData.activeBuffs.push(buff);
    }
    
    // Apply sponsor
    if (effects.sponsor) {
        fighter.eventData.sponsor = {
            ...effects.sponsor,
            startDate: Date.now(),
            expiresAt: Date.now() + effects.sponsor.duration * 24 * 60 * 60 * 1000
        };
    }
    
    // Set doping flag
    if (effects.dopingFlag) {
        fighter.eventData.dopingFlag = true;
    }
    
    // Handle injury risk
    if (effects.injuryRisk && Math.random() < effects.injuryRisk) {
        // Apply random injury
        const injuries = ['shoulder', 'hand', 'rib', 'nose'];
        const randomInjury = injuries[Math.floor(Math.random() * injuries.length)];
        // This will be handled by existing injury system
        return { injury: randomInjury };
    }
    
    // Handle doping test
    if (effects.dopingTest && fighter.eventData.dopingFlag) {
        // Failed doping test!
        gameState.cash -= 50000;
        fighter.gameData.rating = Math.max(0, fighter.gameData.rating - 200);
        fighter.eventData.dopingFlag = false;
        
        return { dopingFailed: true };
    }
    
    return {};
}

// Get active buffs for fighter
function getActiveBuffs(fighter) {
    if (!fighter.eventData || !fighter.eventData.activeBuffs) return null;
    
    // Remove expired buffs
    const now = Date.now();
    fighter.eventData.activeBuffs = fighter.eventData.activeBuffs.filter(buff => buff.expiresAt > now);
    
    if (fighter.eventData.activeBuffs.length === 0) return null;
    
    // Sum all active buffs
    const totalBuffs = {
        power: 0,
        speed: 0,
        stamina: 0,
        defense: 0,
        form: 0
    };
    
    fighter.eventData.activeBuffs.forEach(buff => {
        totalBuffs.power += buff.power;
        totalBuffs.speed += buff.speed;
        totalBuffs.stamina += buff.stamina;
        totalBuffs.defense += buff.defense;
        totalBuffs.form += buff.form;
    });
    
    return totalBuffs;
}

// Get sponsor bonus
function getSponsorBonus(fighter) {
    if (!fighter.eventData || !fighter.eventData.sponsor) return 0;
    
    const now = Date.now();
    if (fighter.eventData.sponsor.expiresAt < now) {
        fighter.eventData.sponsor = null;
        return 0;
    }
    
    return fighter.eventData.sponsor.bonus;
}
        const CHAMPIONSHIP_BELTS = [
            {
                id: 'regional',
                name: ' ',
                icon: '',
                minRating: 100,
                color: '#cd7f32',
                reward: { cash: 5000, rep: 200, stars: 10 },
                defenseInterval: 30
            },
            {
                id: 'national',
                name: ' ',
                icon: '',
                minRating: 300,
                color: '#c0c0c0',
                reward: { cash: 15000, rep: 500, stars: 25 },
                defenseInterval: 20
            },
            {
                id: 'continental',
                name: ' ',
                icon: '',
                minRating: 600,
                color: '#ffd700',
                reward: { cash: 35000, rep: 1000, stars: 50 },
                defenseInterval: 15
            },
            {
                id: 'world',
                name: ' ',
                icon: '',
                minRating: 1000,
                color: '#9b59b6',
                reward: { cash: 100000, rep: 3000, stars: 150 },
                defenseInterval: 10
            }
        ];

        function getCurrentTier(rating) {
            for (let tier of RANKING_TIERS) {
                if (rating >= tier.minRating && rating <= tier.maxRating) {
                    return tier;
                }
            }
            return RANKING_TIERS[RANKING_TIERS.length - 1];
        }

        function getAvailableBelts(rating) {
            return CHAMPIONSHIP_BELTS.filter(belt => rating >= belt.minRating);
        }

        function canChallengeForBelt(fighter, belt) {
            const rating = fighter.gameData?.rating || 0;
            if (rating < belt.minRating) return false;
            if (fighter.belts && fighter.belts[belt.id]) return false;
            const winsInTier = fighter.gameData?.winsInCurrentTier || 0;
            if (winsInTier < 5) return false;
            return true;
        }

        function generateChampion(belt, playerRating, isGatekeeper = false) {
            const firstNames = ['', '', '', '', '', '', '', '', ''];
            const lastNames = ['', '', '', '', '', '', '', '', ''];
            const nicknames = ['', '', '', '', '', '', '', '', ''];
            
            const firstName = firstNames[Math.floor(Math.random() * firstNames.length)];
            const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
            const nickname = nicknames[Math.floor(Math.random() * nicknames.length)];
            
            // Gatekeeper bosses are balanced - only slightly harder
            // Regular champions are much harder
            const ratingBonus = isGatekeeper ? 50 : 150;
            const championRating = Math.max(playerRating + ratingBonus, belt.minRating + 50);
            
            const wins = Math.floor(Math.random() * 20) + 30;
            const losses = Math.floor(Math.random() * 3);
            const draws = Math.floor(Math.random() * 2);
            
            return {
                firstName,
                lastName,
                nickname,
                avatar: belt.icon,
                rating: championRating,
                record: { wins, losses, draws },
                difficulty: 'champion',
                difficultyLabel: belt.name,
                cashReward: belt.reward.cash,
                repReward: belt.reward.rep,
                starsReward: belt.reward.stars,
                belt: belt,
                isChampion: true,
                stats: calculateChampionStats(playerRating, belt, isGatekeeper)
            };
        }
        
        function calculateChampionStats(playerRating, belt, isGatekeeper) {
            // Get player's approximate stats based on rating
            // Early game: ~50-150 stats
            // Mid game: ~200-400 stats
            // Late game: ~500-800 stats
            const playerApproxStat = Math.min(800, 50 + playerRating * 0.5);
            
            // Gatekeeper: 10-20% stronger than player
            // Regular champion: 30-50% stronger than player
            const multiplier = isGatekeeper ? 1.15 : 1.4;
            const variance = 0.1; // 10% random variance
            
            const baseStat = playerApproxStat * multiplier;
            
            return {
                power: Math.round(baseStat * (1 + (Math.random() * variance * 2 - variance))),
                speed: Math.round(baseStat * (1 + (Math.random() * variance * 2 - variance))),
                stamina: Math.round(baseStat * (1 + (Math.random() * variance * 2 - variance))),
                defense: Math.round(baseStat * (1 + (Math.random() * variance * 2 - variance)))
            };
        }

        function initializeRankingSystem(fighter) {
            if (!fighter.gameData) fighter.gameData = {};
            if (!fighter.gameData.rating) fighter.gameData.rating = 0;
            if (!fighter.gameData.winsInCurrentTier) fighter.gameData.winsInCurrentTier = 0;
            if (!fighter.belts) fighter.belts = {};
            if (!fighter.beltDefenses) fighter.beltDefenses = {};
        }

        function awardBelt(fighter, belt) {
            if (!fighter.belts) fighter.belts = {};
            fighter.belts[belt.id] = {
                wonDate: Date.now(),
                defenses: 0,
                nextDefense: Date.now() + (belt.defenseInterval * 24 * 60 * 60 * 1000)
            };
        }

        function isBeltDefenseDue(fighter, beltId) {
            const belt = fighter.belts[beltId];
            if (!belt) return false;
            return Date.now() >= belt.nextDefense;
        }

        function getBeltsNeedingDefense(fighter) {
            const needDefense = [];
            if (!fighter.belts) return needDefense;
            for (let beltId in fighter.belts) {
                if (isBeltDefenseDue(fighter, beltId)) {
                    const beltData = CHAMPIONSHIP_BELTS.find(b => b.id === beltId);
                    if (beltData) needDefense.push(beltData);
                }
            }
            return needDefense;
        }

        function loseBelt(fighter, beltId) {
            if (fighter.belts && fighter.belts[beltId]) {
                delete fighter.belts[beltId];
            }
        }

        function updateRatingAfterWin(fighter, opponent) {
            console.log('=== UPDATE RATING AFTER WIN ===');
            console.log('Before - Rating:', fighter.gameData.rating);
            console.log('Before - Wins in tier:', fighter.gameData.winsInCurrentTier);
            console.log('Opponent is champion?', opponent.isChampion);
            console.log('Opponent difficulty:', opponent.difficulty);
            
            // Calculate rating gain based on difficulty and champion status
            let ratingGain = 25; // Base for medium/easy
            
            if (opponent.isChampion) {
                // Championship fights give more rating
                ratingGain = 50;
            } else if (opponent.difficulty === 'hard') {
                // Hard opponents give double rating
                ratingGain = 50;
            } else if (opponent.difficulty === 'easy') {
                // Easy opponents give less rating
                ratingGain = 15;
            }
            
            console.log('Rating gain:', ratingGain);
            
            const beforeRating = fighter.gameData.rating;
            fighter.gameData.rating += ratingGain;
            const afterRating = fighter.gameData.rating;
            const actualGain = afterRating - beforeRating;
            
            console.log('After - Rating:', fighter.gameData.rating);
            console.log('VERIFICATION: Should be +' + ratingGain + ', actually +' + actualGain);
            
            if (actualGain !== ratingGain) {
                console.error(' RATING MISMATCH! Expected +' + ratingGain + ' but got +' + actualGain);
            }
            
            if (opponent.belt) awardBelt(fighter, opponent.belt);
            
            // Reset wins when advancing to new tier (gatekeeper boss defeated)
            if (opponent.isGatekeeperBoss) {
                console.log(' Gatekeeper defeated! Advancing to new tier, resetting wins.');
                fighter.gameData.winsInCurrentTier = 0;
            }
            
            if (opponent.isTitleDefense && fighter.belts[opponent.belt.id]) {
                fighter.belts[opponent.belt.id].defenses++;
                fighter.belts[opponent.belt.id].nextDefense = Date.now() + (opponent.belt.defenseInterval * 24 * 60 * 60 * 1000);
            }
        }

        function updateRatingAfterLoss(fighter, opponent) {
            const ratingLoss = 15;
            fighter.gameData.rating = Math.max(0, fighter.gameData.rating - ratingLoss);
            fighter.gameData.winsInCurrentTier = 0;
            if (opponent.isTitleDefense && opponent.belt) {
                loseBelt(fighter, opponent.belt.id);
            }
        }
        
        const TRAINING_TYPES = {
            power: { icon: '', name: '', key: 'power' },
            speed: { icon: '', name: '', key: 'speed' },
            stamina: { icon: '', name: '', key: 'stamina' },
            defense: { icon: '', name: '', key: 'defense' }
        };
        
        const TRAINING_OPTIONS = [
            { time: 30, cost: 100, reward: '5-8', minutes: 30 },
            { time: 120, cost: 500, reward: '10-15', minutes: 120 },
            { time: 360, cost: 2000, reward: '20-30', minutes: 360 }
        ];
        
        // ========================================= 
        // INJURY SYSTEM
        // =========================================
        
        const INJURY_TYPES = {
            bruise: { name: '    ', severity: 'light', duration: 0.5 * 60 * 60 * 1000, statReduction: 0.10, chance: 0.08, healCost: 300, starCost: 5 },
            cut: { name: '  ', severity: 'light', duration: 1 * 60 * 60 * 1000, statReduction: 0.10, chance: 0.06, healCost: 400, starCost: 5 },
            fatigue: { name: '  \'', severity: 'light', duration: 1.5 * 60 * 60 * 1000, statReduction: 0.15, chance: 0.08, healCost: 500, starCost: 8 },
            ribCrack: { name: '  ', severity: 'medium', duration: 3 * 60 * 60 * 1000, statReduction: 0.25, chance: 0.05, healCost: 1000, starCost: 10 },
            brokenNose: { name: '  ', severity: 'medium', duration: 4 * 60 * 60 * 1000, statReduction: 0.20, chance: 0.04, healCost: 1200, starCost: 12 },
            wristSprain: { name: '  \'', severity: 'medium', duration: 5 * 60 * 60 * 1000, statReduction: 0.30, chance: 0.05, healCost: 1500, starCost: 15 },
            concussion: { name: '  ', severity: 'heavy', duration: 8 * 60 * 60 * 1000, statReduction: 0.40, chance: 0.02, healCost: 3000, starCost: 20 },
            fracture: { name: '  ', severity: 'heavy', duration: 10 * 60 * 60 * 1000, statReduction: 0.35, chance: 0.01, healCost: 3500, starCost: 25 },
            eyeDamage: { name: '  ', severity: 'heavy', duration: 12 * 60 * 60 * 1000, statReduction: 0.50, chance: 0.015, healCost: 4000, starCost: 30 },
            severeConcussion: { name: '   ', severity: 'critical', duration: 20 * 60 * 60 * 1000, statReduction: 0.50, chance: 0.005, healCost: 8000, starCost: 50 },
            compoundFracture: { name: '  ', severity: 'critical', duration: 24 * 60 * 60 * 1000, statReduction: 0.50, chance: 0.003, healCost: 10000, starCost: 60 }
        };
        
        const DOCTORS = {
            none: { name: ' ', timeReduction: 0, cost: 0 },
            basic: { name: '  1', timeReduction: 0.25, cost: 500 },
            advanced: { name: '  2', timeReduction: 0.75, cost: 2000 }
        };
        
        function checkForInjury(fighter, opponentDifficulty, fightResult) {
            if (fighter.injury && fighter.injury.healTime > Date.now()) return null;
            let chanceMultiplier = 1.0;
            if (opponentDifficulty === 'hard') chanceMultiplier = 1.5;
            if (opponentDifficulty === 'easy') chanceMultiplier = 0.5;
            if (fightResult === 'loss') chanceMultiplier *= 1.5;
            if (fighter.gameData && fighter.gameData.form < 70) chanceMultiplier *= 1.3;
            const injuries = Object.keys(INJURY_TYPES).reverse();
            for (let injuryKey of injuries) {
                const injury = INJURY_TYPES[injuryKey];
                const finalChance = injury.chance * chanceMultiplier;
                if (Math.random() < finalChance) {
                    return { type: injuryKey, ...injury, receivedAt: Date.now(), healTime: Date.now() + injury.duration };
                }
            }
            return null;
        }
        
        function applyInjuryEffects(fighter) {
            if (!fighter.injury || fighter.injury.healTime <= Date.now()) {
                if (fighter.injury) delete fighter.injury;
                return fighter.stats;
            }
            const reduction = fighter.injury.statReduction;
            return {
                power: Math.floor(fighter.stats.power * (1 - reduction)),
                speed: Math.floor(fighter.stats.speed * (1 - reduction)),
                stamina: Math.floor(fighter.stats.stamina * (1 - reduction)),
                defense: Math.floor(fighter.stats.defense * (1 - reduction))
            };
        }
        
        let isHealing = false; // Flag to prevent multiple clicks
        
        function healInjury(doctorLevel, useStars = false) {
            // Prevent multiple clicks
            if (isHealing) {
                console.log('Already healing, ignoring click');
                return false;
            }
            
            isHealing = true;
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (!fighter || !fighter.injury) { 
                showToast('  !', 'error');
                isHealing = false;
                return false; 
            }
            
            if (useStars) {
                if (gameState.stars < fighter.injury.starCost) { 
                    showToast(' ! ', 'error');
                    isHealing = false;
                    return false; 
                }
                gameState.stars -= fighter.injury.starCost;
                delete fighter.injury;
                saveGameSync(characterData);
                showToast(' ! ', 'success');
                loadGameData();
                closeInjuryModal();
                isHealing = false;
                return true;
            }
            
            const doctor = DOCTORS[doctorLevel];
            if (gameState.cash < doctor.cost) { 
                showToast(' ! ', 'error');
                isHealing = false;
                return false; 
            }
            
            gameState.cash -= doctor.cost;
            const remainingTime = fighter.injury.healTime - Date.now();
            const reducedTime = remainingTime * (1 - doctor.timeReduction);
            fighter.injury.healTime = Date.now() + reducedTime;
            saveGameSync(characterData);
            const hours = Math.floor(reducedTime / (60 * 60 * 1000));
            const minutes = Math.floor((reducedTime % (60 * 60 * 1000)) / (60 * 1000));
            showToast(` ! : ${hours} ${minutes} `, 'success');
            loadGameData();
            closeInjuryModal();
            isHealing = false;
            return true;
        }
        
        function formatInjuryTime(milliseconds) {
            const hours = Math.floor(milliseconds / (60 * 60 * 1000));
            const minutes = Math.floor((milliseconds % (60 * 60 * 1000)) / (60 * 1000));
            if (hours > 0) return `${hours} ${minutes}`;
            return `${minutes}`;
        }
        
        function openTreatmentModal() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const gameState = characterData.gameState;
            if (!fighter.injury) return;
            const injury = fighter.injury;
            const remainingTime = injury.healTime - Date.now();
            const hours = Math.floor(remainingTime / (60 * 60 * 1000));
            const minutes = Math.floor((remainingTime % (60 * 60 * 1000)) / (60 * 1000));
            const timeWithBasic = remainingTime * 0.75;
            const hoursBasic = Math.floor(timeWithBasic / (60 * 60 * 1000));
            const minutesBasic = Math.floor((timeWithBasic % (60 * 60 * 1000)) / (60 * 1000));
            const timeWithAdvanced = remainingTime * 0.25;
            const hoursAdvanced = Math.floor(timeWithAdvanced / (60 * 60 * 1000));
            const minutesAdvanced = Math.floor((timeWithAdvanced % (60 * 60 * 1000)) / (60 * 1000));
            const modal = document.createElement('div');
            modal.id = 'injuryModal';
            modal.className = 'injury-modal';
            modal.innerHTML = `
                <div class="injury-modal-overlay" onclick="closeInjuryModal()"></div>
                <div class="injury-modal-content">
                    <div class="injury-modal-header">
                        <h2>  </h2>
                        <button onclick="closeInjuryModal()" class="injury-close-btn"></button>
                    </div>
                    <div class="injury-info">
                        <div class="injury-name">${injury.name}</div>
                        <div class="injury-severity ${injury.severity}">
                            ${injury.severity === 'light' ? ' ' : injury.severity === 'medium' ? ' ' : injury.severity === 'heavy' ? ' ' : ' '}
                        </div>
                        <div class="injury-effect">  : -${Math.round(injury.statReduction * 100)}%</div>
                        <div class="injury-time">  : ${hours} ${minutes}</div>
                    </div>
                    <div class="treatment-options">
                        <div class="treatment-option">
                            <div class="treatment-header">
                                <span class="treatment-name">   1</span>
                                <span class="treatment-cost">$${DOCTORS.basic.cost}</span>
                            </div>
                            <div class="treatment-time"> ${hoursBasic} ${minutesBasic}</div>
                            <button onclick="this.disabled=true; this.classList.add('disabled'); healInjury('basic'); return false;" 
                                    class="treatment-btn ${gameState.cash < DOCTORS.basic.cost ? 'disabled' : ''}"
                                    ${gameState.cash < DOCTORS.basic.cost ? 'disabled' : ''}>
                                 
                            </button>
                        </div>
                        <div class="treatment-option">
                            <div class="treatment-header">
                                <span class="treatment-name">   2</span>
                                <span class="treatment-cost">$${DOCTORS.advanced.cost}</span>
                            </div>
                            <div class="treatment-time"> ${hoursAdvanced} ${minutesAdvanced}</div>
                            <button onclick="this.disabled=true; this.classList.add('disabled'); healInjury('advanced'); return false;" 
                                    class="treatment-btn ${gameState.cash < DOCTORS.advanced.cost ? 'disabled' : ''}"
                                    ${gameState.cash < DOCTORS.advanced.cost ? 'disabled' : ''}>
                                 
                            </button>
                        </div>
                        <div class="treatment-option instant">
                            <div class="treatment-header">
                                <span class="treatment-name">  </span>
                                <span class="treatment-cost">${injury.starCost} </span>
                            </div>
                            <div class="treatment-time"> </div>
                            <button onclick="this.disabled=true; this.classList.add('disabled'); healInjury('none', true); return false;" 
                                    class="treatment-btn instant ${gameState.stars < injury.starCost ? 'disabled' : ''}"
                                    ${gameState.stars < injury.starCost ? 'disabled' : ''}>
                                 
                            </button>
                        </div>
                    </div>
                    <button onclick="closeInjuryModal()" class="injury-natural-btn">
                          
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
            setTimeout(() => modal.classList.add('active'), 10);
        }
        
        function closeInjuryModal() {
            isHealing = false; // Reset flag
            const modal = document.getElementById('injuryModal');
            if (modal) {
                modal.classList.remove('active');
                setTimeout(() => modal.remove(), 300);
            }
        }
        
        // =========================================
        // TEAM MANAGEMENT SYSTEM - STEP 1: DATA
        // =========================================
        
        const TEAM_MEMBER_TYPES = {
            trainer: {
                id: 'trainer',
                name: '',
                icon: '',
                color: '#4ade80'
            },
            doctor: {
                id: 'doctor',
                name: '',
                icon: '',
                color: '#ef4444'
            },
            manager: {
                id: 'manager',
                name: '',
                icon: '',
                color: '#fbbf24'
            }
        };
        
        const TEAM_MEMBERS = {
            trainer_basic: {
                id: 'trainer_basic',
                type: 'trainer',
                firstName: '',
                lastName: '',
                level: 1,
                salary: 2000,
                hiringCost: 5000,
                bonuses: {
                    trainingBonus: 0.10,
                    powerBonus: 3
                },
                requirements: { rating: 100 }
            },
            doctor_basic: {
                id: 'doctor_basic',
                type: 'doctor',
                firstName: '',
                lastName: '',
                level: 1,
                salary: 1500,
                hiringCost: 4000,
                bonuses: {
                    healingSpeed: 0.80,
                    injuryResistance: 0.10
                },
                requirements: { rating: 200 }
            },
            manager_basic: {
                id: 'manager_basic',
                type: 'manager',
                firstName: '',
                lastName: '',
                level: 1,
                salary: 3000,
                hiringCost: 8000,
                bonuses: {
                    fightEarnings: 0.15
                },
                requirements: { rating: 300 }
            }
        };
        
        // =========================================
        // TEAM MANAGEMENT SYSTEM - STEP 2: FUNCTIONS
        // =========================================
        
        // Initialize team structure
        function initializeTeam(characterData) {
            if (!characterData.team) {
                characterData.team = {
                    members: {},
                    expenses: 0,
                    totalSpent: 0,
                    lastPayment: Date.now()
                };
            }
        }
        
        // Hire team member
        function hireTeamMember(characterData, memberId) {
            const member = TEAM_MEMBERS[memberId];
            if (!member) return { success: false, error: ' ' };
            
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const gameState = characterData.gameState;
            
            // Check if already have this type
            if (characterData.team.members[member.type]) {
                return { success: false, error: '  ' + TEAM_MEMBER_TYPES[member.type].name };
            }
            
            // Check requirements
            if (member.requirements.rating && fighter.gameData.rating < member.requirements.rating) {
                return { success: false, error: '  ' + member.requirements.rating };
            }
            
            // Check money
            if (gameState.cash < member.hiringCost) {
                return { success: false, error: ' ' };
            }
            
            // Hire
            gameState.cash -= member.hiringCost;
            characterData.team.members[member.type] = { ...member, hiredDate: Date.now() };
            updateTeamExpenses(characterData);
            
            return { success: true };
        }
        
        // Fire team member
        function fireTeamMember(characterData, memberType) {
            if (!characterData.team.members[memberType]) {
                return { success: false, error: ' ' };
            }
            
            delete characterData.team.members[memberType];
            updateTeamExpenses(characterData);
            
            return { success: true };
        }
        
        // Update monthly expenses
        function updateTeamExpenses(characterData) {
            let total = 0;
            Object.values(characterData.team.members).forEach(member => {
                total += member.salary;
            });
            characterData.team.expenses = total;
        }
        
        // Get team bonuses
        function getTeamBonuses(characterData) {
            const bonuses = {
                trainingBonus: 0,
                powerBonus: 0,
                healingSpeed: 1.0,
                injuryResistance: 0,
                fightEarnings: 0
            };
            
            if (!characterData.team || !characterData.team.members) return bonuses;
            
            Object.values(characterData.team.members).forEach(member => {
                if (!member.bonuses) return;
                
                if (member.bonuses.trainingBonus) bonuses.trainingBonus += member.bonuses.trainingBonus;
                if (member.bonuses.powerBonus) bonuses.powerBonus += member.bonuses.powerBonus;
                if (member.bonuses.healingSpeed) bonuses.healingSpeed *= member.bonuses.healingSpeed;
                if (member.bonuses.injuryResistance) bonuses.injuryResistance += member.bonuses.injuryResistance;
                if (member.bonuses.fightEarnings) bonuses.fightEarnings += member.bonuses.fightEarnings;
            });
            
            return bonuses;
        }
        
        // Get available members for hiring
        function getAvailableTeamMembers(characterData) {
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            fighter.gameData = fighter.gameData || {};
            const gameState = characterData.gameState;
            const available = {};
            
            // Get rating - same as displayed on main screen
            const currentRating = (fighter.gameData?.rating ?? fighter.rating ?? 0);
            
            Object.entries(TEAM_MEMBERS).forEach(([id, member]) => {
                // Skip if already hired this type
                if (characterData.team.members[member.type]) return;
                
                // Check requirements
                let meetsRequirements = true;
                let missingRequirements = [];
                
                if (member.requirements.rating && currentRating < member.requirements.rating) {
                    meetsRequirements = false;
                    missingRequirements.push(' ' + member.requirements.rating);
                }
                
                if (!available[member.type]) {
                    available[member.type] = [];
                }
                
                available[member.type].push({
                    ...member,
                    meetsRequirements,
                    missingRequirements,
                    canAfford: gameState.cash >= member.hiringCost
                });
            });
            
            return available;
        }
        
        // ========================================= 
        // FIGHTER ECONOMY SYSTEM
        // =========================================
        
        function calculateFighterPrice(fighter) {
            // Base price from talent
            let price = (fighter.talent || 5) * 1000;
            
            // Bonus for stats (overall)
            const overall = Math.round((fighter.stats.power + fighter.stats.speed + fighter.stats.stamina + fighter.stats.defense) / 4);
            price += overall * 10;
            
            // Bonus/penalty for record
            if (fighter.gameData && fighter.gameData.record) {
                const record = fighter.gameData.record;
                price += (record.wins * 500) - (record.losses * 200);
            }
            
            // Age multiplier (younger = more expensive)
            const age = fighter.age || 25;
            let ageMultiplier = 1.0;
            if (age <= 25) ageMultiplier = 1.2;
            else if (age <= 30) ageMultiplier = 1.0;
            else if (age <= 35) ageMultiplier = 0.8;
            else ageMultiplier = 0.5;
            
            price = Math.floor(price * ageMultiplier);
            
            // Penalty for injury
            if (fighter.injury && fighter.injury.healTime > Date.now()) {
                price = Math.floor(price * 0.5);
            }
            
            return Math.max(1000, price); // Minimum $1,000
        }
        
        function getPriceBreakdown(fighter) {
            const talent = (fighter.talent || 5) * 1000;
            const overall = Math.round((fighter.stats.power + fighter.stats.speed + fighter.stats.stamina + fighter.stats.defense) / 4);
            const statsBonus = overall * 10;
            
            let recordBonus = 0;
            if (fighter.gameData && fighter.gameData.record) {
                const record = fighter.gameData.record;
                recordBonus = (record.wins * 500) - (record.losses * 200);
            }
            
            const age = fighter.age || 25;
            let ageLabel = '';
            let ageMultiplier = 1.0;
            if (age <= 25) { ageMultiplier = 1.2; ageLabel = '+20%'; }
            else if (age <= 30) { ageMultiplier = 1.0; ageLabel = '+0%'; }
            else if (age <= 35) { ageMultiplier = 0.8; ageLabel = '-20%'; }
            else { ageMultiplier = 0.5; ageLabel = '-50%'; }
            
            const subtotal = talent + statsBonus + recordBonus;
            const total = Math.floor(subtotal * ageMultiplier);
            
            let injuryPenalty = '';
            if (fighter.injury && fighter.injury.healTime > Date.now()) {
                injuryPenalty = '-50% ()';
            }
            
            return {
                talent,
                statsBonus,
                recordBonus,
                ageLabel,
                ageMultiplier,
                subtotal,
                total: injuryPenalty ? Math.floor(total * 0.5) : total,
                injuryPenalty
            };
        }
        
        function openSellFighterModal(fighterIndex) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[fighterIndex];
            
            // Check if this is the last fighter
            if (characterData.fighters.length === 1) {
                showToast('    ! ', 'error');
                return;
            }
            
            const price = calculateFighterPrice(fighter);
            const breakdown = getPriceBreakdown(fighter);
            const commission = Math.floor(price * 0.1);
            const finalPrice = price - commission;
            
            const modal = document.createElement('div');
            modal.id = 'sellFighterModal';
            modal.className = 'injury-modal';
            modal.innerHTML = `
                <div class="injury-modal-overlay" onclick="closeSellModal()"></div>
                <div class="injury-modal-content">
                    <div class="injury-modal-header">
                        <h2>  ?</h2>
                        <button onclick="closeSellModal()" class="injury-close-btn"></button>
                    </div>
                    
                    <div class="sell-fighter-info">
                        <div style="text-align: center; margin-bottom: 1.5rem;">
                            <div style="font-size: 3rem; margin-bottom: 0.5rem;">${fighter.avatar}</div>
                            <div style="font-size: 1.3rem; font-weight: bold; color: white;">
                                ${fighter.firstName} "${fighter.nickname}" ${fighter.lastName}
                            </div>
                            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 0.5rem; flex-wrap: wrap;">
                                <span>  ${fighter.talent}</span>
                                <span>  ${Math.round((fighter.stats.power + fighter.stats.speed + fighter.stats.stamina + fighter.stats.defense) / 4)}</span>
                                <span> ${fighter.gameData.record.wins}-${fighter.gameData.record.losses}-${fighter.gameData.record.draws}</span>
                                <span> ${fighter.age} </span>
                            </div>
                        </div>
                        
                        <div style="background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem;">
                            <div style="text-align: center; font-size: 0.9rem; color: rgba(255,255,255,0.7); margin-bottom: 1rem;">
                                 
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.7);"> ():</span>
                                    <span style="color: white; font-weight: 600;">$${formatNumber(breakdown.talent)}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.7);"> :</span>
                                    <span style="color: #4ade80; font-weight: 600;">+$${formatNumber(breakdown.statsBonus)}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.7);"> :</span>
                                    <span style="color: ${breakdown.recordBonus >= 0 ? '#4ade80' : '#f87171'}; font-weight: 600;">
                                        ${breakdown.recordBonus >= 0 ? '+' : ''}$${formatNumber(breakdown.recordBonus)}
                                    </span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.7);"> (${fighter.age} ):</span>
                                    <span style="color: ${breakdown.ageMultiplier >= 1 ? '#4ade80' : '#f87171'}; font-weight: 600;">
                                        ${breakdown.ageLabel}
                                    </span>
                                </div>
                                ${breakdown.injuryPenalty ? `
                                    <div style="display: flex; justify-content: space-between;">
                                        <span style="color: rgba(255,255,255,0.7);">:</span>
                                        <span style="color: #f87171; font-weight: 600;">${breakdown.injuryPenalty}</span>
                                    </div>
                                ` : ''}
                                <div style="height: 1px; background: rgba(255,215,0,0.3); margin: 0.5rem 0;"></div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.7);"> :</span>
                                    <span style="color: white; font-weight: 600;">$${formatNumber(price)}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.7);"> (10%):</span>
                                    <span style="color: #f87171; font-weight: 600;">-$${formatNumber(commission)}</span>
                                </div>
                                <div style="height: 1px; background: rgba(255,215,0,0.5); margin: 0.5rem 0;"></div>
                                <div style="display: flex; justify-content: space-between; font-size: 1.2rem;">
                                    <span style="color: var(--gold); font-weight: 700;">:</span>
                                    <span style="color: var(--gold); font-weight: 700;">$${formatNumber(finalPrice)}</span>
                                </div>
                            </div>
                        </div>
                        
                        <div style="background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; text-align: center;">
                            <span style="color: #f87171;">  !    .</span>
                        </div>
                        
                        <div style="display: flex; gap: 1rem;">
                            <button onclick="closeSellModal()" class="injury-natural-btn" style="flex: 1;">
                                 
                            </button>
                            <button onclick="confirmSellFighter(${fighterIndex}, ${finalPrice})" 
                                    class="treatment-btn" style="flex: 1;">
                                   $${formatNumber(finalPrice)}
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            setTimeout(() => modal.classList.add('active'), 10);
        }
        
        function closeSellModal() {
            const modal = document.getElementById('sellFighterModal');
            if (modal) {
                modal.classList.remove('active');
                setTimeout(() => modal.remove(), 300);
            }
        }
        
        function confirmSellFighter(fighterIndex, price) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[fighterIndex];
            
            // Add money
            characterData.gameState.cash += price;
            
            // Remove fighter
            characterData.fighters.splice(fighterIndex, 1);
            
            // Update active fighter index if needed
            if (characterData.activeFighterIndex >= characterData.fighters.length) {
                characterData.activeFighterIndex = characterData.fighters.length - 1;
            }
            
            saveGameSync(characterData);
            
            showToast(`${fighter.firstName} "${fighter.nickname}"   $${formatNumber(price)}! `, 'success');
            
            closeSellModal();
            loadGameData();
        }
        
        let selectedTraining = {};
        let trainingTimers = {};
        
        function loadTrainingScreen() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const gameState = characterData.gameState;
            
            // Initialize training state if not exists
            if (!fighter.training) {
                fighter.training = {};
            }
            
            const content = document.getElementById('trainingContent');
            content.innerHTML = '';
            
            // Add talent info banner at the top
            const talent = fighter.talent || 5;
            const talentBonus = getTalentBonus(talent);
            const talentBanner = document.createElement('div');
            talentBanner.style.cssText = 'background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); border-radius: 8px; padding: 0.8rem; margin-bottom: 1rem; text-align: center;';
            talentBanner.innerHTML = `<div style="color: #FFD700; font-weight: 600; font-size: 0.9rem;">  ${talent}   +${talentBonus}%   </div>`;
            content.appendChild(talentBanner);
            
            Object.keys(TRAINING_TYPES).forEach(type => {
                const typeData = TRAINING_TYPES[type];
                const currentValue = fighter.stats[typeData.key];
                const isTraining = fighter.training[type] && fighter.training[type].endTime > Date.now();
                
                const card = document.createElement('div');
                card.className = 'training-card' + (isTraining ? ' active' : '');
                card.innerHTML = `
                    <div class="training-card-header">
                        <div class="training-stat-name">
                            <span class="training-stat-icon">${typeData.icon}</span>
                            <span>${typeData.name}</span>
                        </div>
                        <div class="training-stat-value">${currentValue}/1000</div>
                    </div>
                    
                    <div class="training-progress">
                        <div class="training-progress-bar">
                            <div class="training-progress-fill" style="width: ${(currentValue / 1000 * 100)}%"></div>
                        </div>
                    </div>
                    
                    ${isTraining ? generateTrainingTimer(type, fighter.training[type]) : generateTrainingOptions(type, gameState)}
                `;
                
                content.appendChild(card);
            });
            
            // Start timers for active trainings
            Object.keys(fighter.training).forEach(type => {
                if (fighter.training[type] && fighter.training[type].endTime > Date.now()) {
                    startTrainingTimer(type);
                }
            });
            
            saveGameSync(characterData);
        }
        
        function generateTrainingOptions(type, gameState) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const talent = fighter.talent || 5;
            const talentBonus = getTalentBonus(talent);
            
            return `
                <div class="training-options">
                    ${TRAINING_OPTIONS.map((opt, idx) => {
                        const [min, max] = opt.reward.split('-').map(Number);
                        const avgReward = Math.floor((min + max) / 2);
                        const withBonus = Math.floor(avgReward * (1 + talentBonus / 100));
                        
                        return `
                        <div class="training-option ${selectedTraining[type] === idx ? 'selected' : ''}" 
                             onclick="selectTrainingOption('${type}', ${idx})">
                            <div class="training-option-time"> ${opt.time < 60 ? opt.time + ' ' : (opt.time / 60) + ' '}</div>
                            <div class="training-option-cost"> $${opt.cost}</div>
                            <div class="training-option-reward">
                                +${opt.reward}
                                <div style="font-size: 0.75rem; color: #FFD700; margin-top: 2px;">
                                    ~${withBonus}  
                                </div>
                            </div>
                        </div>
                    `}).join('')}
                </div>
                <button class="training-button" onclick="startTraining('${type}')" 
                        ${!selectedTraining[type] && selectedTraining[type] !== 0 ? 'disabled' : ''}>
                     
                </button>
            `;
        }
        
        function generateTrainingTimer(type, trainingData) {
            const remaining = Math.max(0, trainingData.endTime - Date.now());
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            
            return `
                <div class="training-timer">
                    <div class="training-timer-label">  ...</div>
                    <div class="training-timer-value" id="timer-${type}">
                        ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}
                    </div>
                    <button class="training-boost-button" onclick="boostTraining('${type}')">
                          ( 10)
                    </button>
                </div>
            `;
        }
        
        function selectTrainingOption(type, optionIndex) {
            selectedTraining[type] = optionIndex;
            loadTrainingScreen();
        }
        
        function startTraining(type) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (selectedTraining[type] === undefined) return;
            
            // Check if already training something
            if (fighter.training) {
                for (const trainingType in fighter.training) {
                    if (fighter.training[trainingType] && fighter.training[trainingType].endTime > Date.now()) {
                        showToast(' !', `${fighter.firstName}   ${TRAINING_TYPES[trainingType].name}.  .`, 'warning');
                        return;
                    }
                }
            }
            
            const option = TRAINING_OPTIONS[selectedTraining[type]];
            
            // Check if enough money
            if (gameState.cash < option.cost) {
                showToast(' !', ` $${option.cost}`, 'error');
                return;
            }
            
            // Deduct cost
            gameState.cash -= option.cost;
            
            // Apply VIP time bonus
            const timeMultiplier = getVIPMultiplier('time');
            const trainingTime = Math.floor(option.minutes * timeMultiplier);
            
            // Initialize training object if not exists
            if (!fighter.training) fighter.training = {};
            
            // Set training
            const endTime = Date.now() + (trainingTime * 60 * 1000);
            fighter.training[type] = {
                endTime: endTime,
                reward: option.reward,
                statKey: TRAINING_TYPES[type].key,
                originalMinutes: option.minutes,
                actualMinutes: trainingTime
            };
            
            saveGameSync(characterData);
            
            // Show VIP bonus toast if applicable
            if (timeMultiplier < 1) {
                setTimeout(() => {
                    showToast(' VIP !', `: ${trainingTime}  ( ${option.minutes} )\n: ${option.minutes - trainingTime} `, 'success');
                }, 500);
            }
            
            // Reload screen
            loadTrainingScreen();
        }
        
        function startTrainingTimer(type) {
            if (trainingTimers[type]) {
                clearInterval(trainingTimers[type]);
            }
            
            console.log(`Starting training timer for ${type}`);
            
            trainingTimers[type] = setInterval(() => {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                const fighter = characterData.fighters[characterData.activeFighterIndex];
                
                if (!fighter || !fighter.training || !fighter.training[type]) {
                    console.log(`No training data for ${type}, clearing timer`);
                    clearInterval(trainingTimers[type]);
                    return;
                }
                
                const training = fighter.training[type];
                const remaining = Math.max(0, training.endTime - Date.now());
                
                if (remaining <= 0) {
                    // Training complete!
                    console.log(`Training ${type} completed!`);
                    completeTraining(type);
                    clearInterval(trainingTimers[type]);
                    return;
                }
                
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                
                const timerEl = document.getElementById(`timer-${type}`);
                if (timerEl) {
                    timerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                } else {
                    console.log(`Timer element not found: timer-${type}`);
                }
            }, 1000);
        }
        
        function completeTraining(type) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const training = fighter.training[type];
            const gameState = characterData.gameState;
            
            // Calculate reward
            const [min, max] = training.reward.split('-').map(Number);
            let reward = Math.floor(Math.random() * (max - min + 1)) + min;
            
            // Apply talent bonus
            const talent = fighter.talent || 5; // Default to 5 if not set
            const talentBonus = getTalentBonus(talent);
            console.log('Training - Talent:', talent, 'Bonus:', talentBonus + '%', 'Base reward:', reward);
            
            reward = Math.floor(reward * (1 + talentBonus / 100));
            console.log('After talent bonus:', reward);
            
            // Apply TEAM bonus (trainer)
            initializeTeam(characterData);
            const teamBonuses = getTeamBonuses(characterData);
            if (teamBonuses.trainingBonus > 0) {
                const beforeTeam = reward;
                reward = Math.floor(reward * (1 + teamBonuses.trainingBonus));
                console.log('Team training bonus: +' + Math.round(teamBonuses.trainingBonus * 100) + '%, ' + beforeTeam + '  ' + reward);
            }
            
            // Apply VIP bonus
            const vipMultiplier = getVIPMultiplier('training');
            if (vipMultiplier > 1) {
                reward = Math.floor(reward * vipMultiplier);
                console.log('After VIP bonus:', reward);
            }
            
            // Apply FORM bonus/penalty
            const form = fighter.gameData.form || 100;
            reward = applyFormToTraining(reward, form);
            console.log('After form adjustment:', reward);
            
            // Update stat
            const statKey = training.statKey;
            fighter.stats[statKey] = Math.min(1000, fighter.stats[statKey] + reward);
            
            // Track training completion
            gameState.totalTrainings = (gameState.totalTrainings || 0) + 1;
            
            // Clear training
            delete fighter.training[type];
            
            saveGameSync(characterData);
            
            // Check achievements
            checkAchievements(characterData);
            
            // Build toast message
            let toastMessage = `${TRAINING_TYPES[type].icon} ${TRAINING_TYPES[type].name} +${reward}`;
            if (talentBonus > 0) {
                toastMessage += `\n : +${talentBonus}%`;
            }
            if (teamBonuses.trainingBonus > 0) {
                toastMessage += `\n : +${Math.round(teamBonuses.trainingBonus * 100)}%`;
            }
            if (vipMultiplier > 1) {
                toastMessage += '\n VIP : +20%';
            }
            if (form < 100) {
                toastMessage += `\n  ${form}%`;
            }
            
            showToast('  !', toastMessage, 'success');
            
            loadTrainingScreen();
            updateResourceBar(); // Update rating display
            
            // Check for random event after training
            triggerRandomEventCheck();
        }
        
        function boostTraining(type) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            if (gameState.stars < 10) {
                alert(' Stars!   10');
                return;
            }
            
            // Deduct stars
            gameState.stars -= 10;
            
            // Complete training instantly
            saveGameSync(characterData);
            completeTraining(type);
        }
        
        function getTalentBonus(talent) {
            if (talent <= 3) return 10;
            if (talent <= 5) return 25;
            if (talent <= 7) return 45;
            if (talent <= 9) return 70;
            return 100;
        }
        
        function openFights() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const activeFighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (!activeFighter || activeFighter.retired) {
                alert('   !\n\n      .');
                return;
            }
            
            showScreen('fightsScreen');
            loadFightsScreen();
        }
        
        // FIGHTS SYSTEM
        let fightCooldownTimer = null;
        
        function loadFightsScreen() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const gameState = characterData.gameState;
            
            // Check cooldown for this specific fighter
            if (!fighter.fightCooldown) {
                fighter.fightCooldown = {};
            }
            
            if (fighter.fightCooldown.nextAvailable && fighter.fightCooldown.nextAvailable > Date.now()) {
                showFightCooldown(fighter.fightCooldown.nextAvailable);
                return;
            }
            
            // Hide cooldown, show fights
            document.getElementById('fightsCooldown').style.display = 'none';
            document.getElementById('fightsContent').style.display = 'block';
            
            // Generate 3 opponents
            const opponents = generateOpponents(fighter, gameState);
            renderOpponents(opponents);
        }
        
        function showFightCooldown(endTime) {
            const cooldownDiv = document.getElementById('fightsCooldown');
            const fightsContent = document.getElementById('fightsContent');
            
            cooldownDiv.style.display = 'block';
            fightsContent.style.display = 'none';
            
            cooldownDiv.innerHTML = `
                <div class="fights-cooldown">
                    <div class="cooldown-text">   </div>
                    <div class="cooldown-timer" id="cooldownTimer">00:00</div>
                    <button class="cooldown-skip-btn" onclick="skipFightCooldown()">
                          ( 10)
                    </button>
                </div>
            `;
            
            // Start cooldown timer
            if (fightCooldownTimer) clearInterval(fightCooldownTimer);
            
            fightCooldownTimer = setInterval(() => {
                const remaining = Math.max(0, endTime - Date.now());
                
                if (remaining <= 0) {
                    clearInterval(fightCooldownTimer);
                    loadFightsScreen();
                    return;
                }
                
                const hours = Math.floor(remaining / 3600000);
                const minutes = Math.floor((remaining % 3600000) / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                
                const timerEl = document.getElementById('cooldownTimer');
                if (timerEl) {
                    timerEl.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
            }, 1000);
        }
        
        function skipFightCooldown() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (gameState.stars < 10) {
                alert(' Stars!   10');
                return;
            }
            
            gameState.stars -= 10;
            
            // Clear fighter's cooldown
            if (fighter.fightCooldown) {
                delete fighter.fightCooldown.nextAvailable;
            }
            
            saveGameSync(characterData);
            
            if (fightCooldownTimer) clearInterval(fightCooldownTimer);
            loadFightsScreen();
        }
        
        function generateOpponents(fighter, gameState) {
            // Initialize ranking system
            initializeRankingSystem(fighter);
            
            console.log('=== GENERATE OPPONENTS ===');
            console.log('Fighter rating:', fighter.gameData.rating);
            console.log('Wins in tier:', fighter.gameData.winsInCurrentTier);
            
            const firstNames = ['', '', '', '', '', '', '', ''];
            const lastNames = ['', '', '', '', '', '', '', ''];
            const nicknames = ['', '', '', '', '', '', '', ''];
            const avatars = ['', '', ''];
            
            const playerRating = fighter.gameData.rating || 0;
            const currentTier = getCurrentTier(playerRating);
            
            console.log('Current tier:', currentTier.name);
            
            // Check if player is close to tier limit and needs to fight boss
            const isNearTierLimit = playerRating >= (currentTier.maxRating - 25);
            const hasRequiredWins = (fighter.gameData.winsInCurrentTier || 0) >= 3;
            
            console.log('Near tier limit?', isNearTierLimit, `(${playerRating} >= ${currentTier.maxRating - 25})`);
            console.log('Has required wins?', hasRequiredWins);
            
            // Find the belt for the NEXT tier (first belt with minRating > current tier max)
            const nextTierBelt = CHAMPIONSHIP_BELTS.find(b => b.minRating > playerRating && b.minRating <= currentTier.maxRating + 200);
            
            console.log('Next tier belt:', nextTierBelt?.name || 'none');
            
            // Check if player already has this belt
            const alreadyHasBelt = nextTierBelt && fighter.belts && fighter.belts[nextTierBelt.id];
            const needsBossFight = isNearTierLimit && hasRequiredWins && nextTierBelt && !alreadyHasBelt;
            
            console.log('Already has belt?', alreadyHasBelt);
            console.log('Needs boss fight?', needsBossFight);
            
            // If player needs to fight boss - ONLY show the boss
            if (needsBossFight) {
                console.log(' BOSS FIGHT REQUIRED! Only showing:', nextTierBelt.name);
                const boss = generateChampion(nextTierBelt, playerRating, true); // true = isGatekeeper
                boss.isGatekeeperBoss = true; // Special flag
                return [boss];
            }
            
            // Generate regular opponents
            // Calculate reward multiplier based on tier
            // NOTE: older builds didn't have `currentTier.number`, so compute it by index.
            const tierNumber = Math.max(1, (RANKING_TIERS.findIndex(t => t.id === currentTier.id) + 1));
            const tierMultiplier = 1 + (tierNumber * 0.5); // Tier 1=1.5x, Tier 2=2x, Tier 3=2.5x...
            
            const difficulties = [
                { name: 'easy', ratingDiff: -50, baseReward: 500, rep: 50, difficulty: '' },
                { name: 'medium', ratingDiff: 0, baseReward: 1000, rep: 100, difficulty: '' },
                { name: 'hard', ratingDiff: 100, baseReward: 2000, rep: 200, difficulty: '' }
            ];
            
            const opponents = difficulties.map(diff => {
                const wins = Math.floor(Math.random() * 20) + 5;
                const losses = Math.floor(Math.random() * 10);
                const draws = Math.floor(Math.random() * 3);
                
                // Calculate reward with tier multiplier (guard against NaN)
                const reward = Math.max(0, Math.floor((diff.baseReward || 0) * (isFinite(tierMultiplier) ? tierMultiplier : 1)));
                
                return {
                    firstName: firstNames[Math.floor(Math.random() * firstNames.length)],
                    lastName: lastNames[Math.floor(Math.random() * lastNames.length)],
                    nickname: nicknames[Math.floor(Math.random() * nicknames.length)],
                    avatar: avatars[Math.floor(Math.random() * avatars.length)],
                    rating: Math.max(0, playerRating + diff.ratingDiff + Math.floor(Math.random() * 50 - 25)),
                    record: { wins, losses, draws },
                    difficulty: diff.name,
                    difficultyLabel: diff.difficulty,
                    cashReward: reward, //  !
                    repReward: diff.rep,
                    stats: calculateOpponentStats(currentTier, diff.name), // Use tier and difficulty name
                    isChampion: false
                };
            });
            
            // Add championship challenges if player already passed the gatekeeper
            const availableBelts = getAvailableBelts(playerRating);
            console.log('Available belts:', availableBelts.map(b => b.name));
            
            for (let belt of availableBelts) {
                // Skip the gatekeeper belt - it only appears when needed
                const isGatekeeperBelt = belt.minRating === currentTier.maxRating + 1;
                if (isGatekeeperBelt) continue;
                
                console.log(`Checking belt: ${belt.name}`);
                console.log(`  Min rating: ${belt.minRating}, Player rating: ${playerRating}`);
                console.log(`  Wins in tier: ${fighter.gameData?.winsInCurrentTier || 0}`);
                console.log(`  Has belt already: ${fighter.belts && fighter.belts[belt.id]}`);
                
                if (canChallengeForBelt(fighter, belt)) {
                    console.log(`   CAN CHALLENGE FOR ${belt.name}!`);
                    const champion = generateChampion(belt, playerRating);
                    opponents.push(champion);
                } else {
                    console.log(`   Cannot challenge yet`);
                }
            }
            
            // Add mandatory title defenses
            const beltsNeedingDefense = getBeltsNeedingDefense(fighter);
            console.log('Belts needing defense:', beltsNeedingDefense.length);
            
            for (let belt of beltsNeedingDefense) {
                const challenger = generateChampion(belt, playerRating);
                challenger.difficultyLabel = ` ${belt.name}`;
                challenger.isTitleDefense = true;
                challenger.cashReward = belt.reward.cash * 0.5;
                opponents.push(challenger);
            }
            
            console.log('Total opponents:', opponents.length);
            console.log('Champions:', opponents.filter(o => o.isChampion).length);
            
            return opponents;
        }
        
        function calculateOpponentStats(currentTier, difficulty) {
            // Use fixed stat ranges from tier configuration
            const statRange = currentTier.opponentStats[difficulty];
            
            if (!statRange) {
                // Fallback if no range defined
                console.error('No stat range for difficulty:', difficulty);
                return { power: 50, speed: 50, stamina: 50, defense: 50 };
            }
            
            // Generate random stats within the fixed range
            const generateStat = () => {
                return Math.floor(Math.random() * (statRange.max - statRange.min + 1)) + statRange.min;
            };
            
            return {
                power: generateStat(),
                speed: generateStat(),
                stamina: generateStat(),
                defense: generateStat()
            };
        }
        
        function renderOpponents(opponents) {
            // Store opponents globally
            generatedOpponents = opponents;
            
            const content = document.getElementById('fightsContent');
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const playerRating = fighter.gameData?.rating || 0;
            const currentTier = getCurrentTier(playerRating);
            
            // Add tier badge at top
            content.innerHTML = `
                <div style="background: linear-gradient(135deg, ${currentTier.color}20, ${currentTier.color}10); 
                            border: 1px solid ${currentTier.color}40; border-radius: 12px; 
                            padding: 1rem; margin-bottom: 1.5rem; text-align: center;">
                    <div style="font-size: 2rem; margin-bottom: 0.5rem;">${currentTier.icon}</div>
                    <div style="color: ${currentTier.color}; font-weight: 700; font-size: 1.1rem; margin-bottom: 0.3rem;">
                        ${currentTier.name}
                    </div>
                    <div style="color: rgba(255,255,255,0.7); font-size: 0.9rem; margin-bottom: 0.5rem;">
                        : ${playerRating} |   : ${fighter.gameData?.winsInCurrentTier || 0}
                    </div>
                    
                    ${currentTier.opponentStats ? `
                        <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 0.7rem; margin-top: 0.7rem;">
                            <div style="color: rgba(255,255,255,0.9); font-size: 0.85rem; font-weight: 600; margin-bottom: 0.4rem;">
                                  :
                            </div>
                            <div style="display: flex; gap: 0.7rem; font-size: 0.75rem;">
                                <div style="flex: 1;">
                                    <span style="color: #4ade80;">:</span>
                                    <span style="color: rgba(255,255,255,0.7);">${currentTier.opponentStats.easy.min}-${currentTier.opponentStats.easy.max}</span>
                                </div>
                                <div style="flex: 1;">
                                    <span style="color: #fbbf24;">:</span>
                                    <span style="color: rgba(255,255,255,0.7);">${currentTier.opponentStats.medium.min}-${currentTier.opponentStats.medium.max}</span>
                                </div>
                                <div style="flex: 1;">
                                    <span style="color: #ef4444;">:</span>
                                    <span style="color: rgba(255,255,255,0.7);">${currentTier.opponentStats.hard.min}-${currentTier.opponentStats.hard.max}</span>
                                </div>
                            </div>
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem; margin-top: 0.4rem; text-align: center;">
                                    -   !
                            </div>
                        </div>
                    ` : ''}
                    
                    ${fighter.belts && Object.keys(fighter.belts).length > 0 ? `
                        <div style="margin-top: 0.8rem; padding-top: 0.8rem; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="color: var(--gold); font-weight: 600; margin-bottom: 0.5rem;">  :</div>
                            <div style="display: flex; gap: 0.8rem; justify-content: center; flex-wrap: wrap;">
                                ${Object.keys(fighter.belts).map(beltId => {
                                    const belt = CHAMPIONSHIP_BELTS.find(b => b.id === beltId);
                                    const beltData = fighter.belts[beltId];
                                    return belt ? `
                                        <div style="background: rgba(255,215,0,0.1); padding: 0.5rem 1rem; border-radius: 8px; border: 1px solid rgba(255,215,0,0.3);">
                                            <div style="font-size: 1.3rem;">${belt.icon}</div>
                                            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.8);">${belt.name}</div>
                                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.6);">: ${beltData.defenses}</div>
                                        </div>
                                    ` : '';
                                }).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            opponents.forEach((opp, index) => {
                const card = document.createElement('div');
                card.className = 'opponent-card';
                
                // Special styling for champions
                if (opp.isChampion) {
                    card.style.border = `2px solid ${opp.belt.color}`;
                    card.style.background = `linear-gradient(135deg, ${opp.belt.color}10, rgba(0,0,0,0))`;
                }
                
                const ratingDiff = opp.rating - playerRating;
                const ratingClass = ratingDiff > 0 ? 'positive' : ratingDiff < 0 ? 'negative' : '';
                const ratingSign = ratingDiff > 0 ? '+' : '';
                
                card.innerHTML = `
                    <div class="opponent-header">
                        <div class="opponent-avatar" style="${opp.isChampion ? `font-size: 2.5rem; filter: drop-shadow(0 0 10px ${opp.belt.color});` : ''}">${opp.avatar}</div>
                        <div class="opponent-info">
                            <div class="opponent-name">${opp.firstName} "${opp.nickname}" ${opp.lastName}</div>
                            ${opp.isChampion ? `
                                <div style="color: ${opp.belt.color}; font-weight: 700; font-size: 0.9rem; margin-top: 0.2rem;">
                                    ${opp.belt.icon} ${opp.belt.name}
                                </div>
                            ` : ''}
                            <div class="opponent-details">
                                <span>: ${opp.record.wins}-${opp.record.losses}-${opp.record.draws}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="difficulty-badge difficulty-${opp.difficulty}" style="${opp.isChampion ? `background: ${opp.belt.color}; color: white;` : ''}">
                        ${opp.isTitleDefense ? ' ' : ''}${opp.difficultyLabel}
                    </div>
                    
                    <div class="opponent-stats">
                        <div class="opponent-stat">
                            <div class="opponent-stat-label"></div>
                            <div class="opponent-stat-value ${ratingClass}">${opp.rating} (${ratingSign}${ratingDiff})</div>
                        </div>
                        <div class="opponent-stat">
                            <div class="opponent-stat-label"></div>
                            <div class="opponent-stat-value">${Math.floor((opp.stats.power + opp.stats.speed + opp.stats.stamina + opp.stats.defense) / 4)}</div>
                        </div>
                    </div>
                    
                    <div class="opponent-rewards">
                        <div class="rewards-label">  :</div>
                        <div class="rewards-values">
                            <span> $${formatNumber(opp.cashReward)}</span>
                            <span> +${opp.isChampion ? 50 : (opp.difficulty === 'hard' ? 50 : (opp.difficulty === 'easy' ? 15 : 25))} </span>
                            ${opp.starsReward ? `<span> +${opp.starsReward}</span>` : ''}
                        </div>
                    </div>
                    
                    ${opp.isChampion && !opp.isTitleDefense ? `
                        <div style="background: ${opp.isGatekeeperBoss ? 'rgba(239,68,68,0.15)' : 'rgba(255,215,0,0.1)'}; 
                                    border: 1px solid ${opp.isGatekeeperBoss ? 'rgba(239,68,68,0.4)' : 'rgba(255,215,0,0.3)'}; 
                                    border-radius: 8px; padding: 0.8rem; margin-bottom: 1rem; text-align: center;">
                            ${opp.isGatekeeperBoss ? `
                                <div style="color: #f87171; font-weight: 700; margin-bottom: 0.3rem; font-size: 1.1rem;">
                                     ' !
                                </div>
                                <div style="font-size: 0.85rem; color: rgba(255,255,255,0.8); line-height: 1.4;">
                                        ,   !<br>
                                    <strong>:</strong>   +  ${opp.belt.name}<br>
                                    <strong>:</strong>    
                                </div>
                            ` : `
                                <div style="color: var(--gold); font-weight: 600; margin-bottom: 0.3rem;">  !</div>
                                <div style="font-size: 0.85rem; color: rgba(255,255,255,0.7);">
                                       ${opp.belt.name}
                                </div>
                            `}
                        </div>
                    ` : ''}
                    
                    ${opp.isTitleDefense ? `
                        <div style="background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); border-radius: 8px; padding: 0.8rem; margin-bottom: 1rem; text-align: center;">
                            <div style="color: #f87171; font-weight: 600; margin-bottom: 0.3rem;"> ' !</div>
                            <div style="font-size: 0.85rem; color: rgba(255,255,255,0.7);">
                                 =  
                            </div>
                        </div>
                    ` : ''}
                    
                    <button class="fight-button" onclick="startFightByIndex(${index})" 
                            style="${opp.isChampion ? `background: linear-gradient(135deg, ${opp.belt.color}, ${opp.belt.color}dd); border: none; font-weight: 700;` : ''}">
                        ${opp.isTitleDefense ? '  ' : '   '}
                    </button>
                `;
                
                content.appendChild(card);
            });
        }
        
        // ===== NEW FIGHT SYSTEM (SIMPLE & WORKING) =====
        
        function startFightByIndex(index) {
            console.log('Fight button clicked, index:', index);
            const opponent = generatedOpponents[index];
            if (!opponent) {
                console.error('Opponent not found');
                return;
            }
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            // Check for injury
            if (fighter.injury && fighter.injury.healTime > Date.now()) {
                showToast(' !     ! ', 'error');
                openTreatmentModal();
                return;
            }
            
            console.log('Starting fight:', fighter.firstName, 'vs', opponent.firstName);
            
            // Show fight screen
            showScreen('fightSimScreen');
            
            // Start simulation
            runFightSimulation(fighter, opponent);
        }
        
        function runFightSimulation(player, opponent) {
            try {
                console.log('=== Fight simulation started ===');
                
                // Setup display
                document.getElementById('simPlayerAvatar').textContent = player.avatar;
                document.getElementById('simPlayerName').textContent = `${player.firstName} "${player.nickname}"`;
                document.getElementById('simOpponentAvatar').textContent = opponent.avatar;
                document.getElementById('simOpponentName').textContent = `${opponent.firstName} "${opponent.nickname}"`;
                
                // Clear log
                const log = document.getElementById('fightLog');
                log.innerHTML = '';
                
                // Fight variables
                let playerHP = 100;
                let opponentHP = 100;
                let currentRound = 1;
                const maxRounds = 12;
                
                // NEW: Combat mechanics variables
                let playerCombo = 0;
                let opponentCombo = 0;
                let playerStamina = 100;
                let opponentStamina = 100;
                let fightStats = {
                    playerHits: 0,
                    opponentHits: 0,
                    playerCrits: 0,
                    opponentCrits: 0,
                    playerBlocks: 0,
                    opponentBlocks: 0,
                    knockdowns: 0
                };
                
                // Get player form
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                const activeFighter = characterData.fighters[characterData.activeFighterIndex];
                
                // Initialize gameData if doesn't exist
                if (!activeFighter.gameData) {
                    activeFighter.gameData = { form: 100 };
                }
                
                const playerForm = activeFighter.gameData.form || 100;
                
                // Apply injury effects to stats
                const playerStats = applyInjuryEffects(player);
                
                // Add intro log entry
                log.innerHTML += `<div class="fight-log-entry neutral" style="font-weight: bold; font-size: 1.1em;">  !</div>`;
                log.innerHTML += `<div class="fight-log-entry neutral" style="opacity: 0.7;"> ${player.firstName} (: ${Math.round((playerStats.power + playerStats.speed + playerStats.stamina + playerStats.defense) / 4)})</div>`;
                log.innerHTML += `<div class="fight-log-entry neutral" style="opacity: 0.7;"> ${opponent.firstName} (: ${Math.round((opponent.stats.power + opponent.stats.speed + opponent.stats.stamina + opponent.stats.defense) / 4)})</div>`;
                
                // Attack types with different properties
                const attackTypes = [
                    { name: '', icon: '', damage: 0.8, speed: 1.3, stamina: 5 },
                    { name: '', icon: '', damage: 1.2, speed: 1.0, stamina: 10 },
                    { name: '', icon: '', damage: 1.5, speed: 0.7, stamina: 15 }
                ];
                
                // Helper function to get attack type based on stats
                function chooseAttack(stats, stamina) {
                    if (stamina < 30) return attackTypes[0]; // Low stamina = jabs only
                    const roll = Math.random();
                    if (stats.speed > 80 && roll < 0.5) return attackTypes[0]; // Fast fighters = more jabs
                    if (stats.power > 80 && roll < 0.3) return attackTypes[2]; // Strong fighters = more uppercuts
                    return attackTypes[Math.floor(Math.random() * 3)];
                }
                
                // Helper function to add colored log entry
                function addLog(message, type = 'neutral', isSpecial = false) {
                    const style = isSpecial ? 'font-weight: bold; font-size: 1.05em; animation: pulse 0.3s;' : '';
                    log.innerHTML += `<div class="fight-log-entry ${type}" style="${style}">${message}</div>`;
                    log.scrollTop = log.scrollHeight;
                }
                
                // Start fight loop
                console.log('Starting fight interval...');
                const fightInterval = setInterval(() => {
                    console.log('Round', currentRound);
                    
                    // Check if fight should end
                    if (currentRound > maxRounds || playerHP <= 0 || opponentHP <= 0) {
                        clearInterval(fightInterval);
                        console.log('Fight ended');
                        
                        // Show final stats
                        addLog('', 'neutral');
                        addLog(` :  ${fightStats.playerHits}-${fightStats.opponentHits} |  ${fightStats.playerCrits}-${fightStats.opponentCrits} |  ${fightStats.playerBlocks}-${fightStats.opponentBlocks}`, 'neutral');
                        
                        finishFight(playerHP, opponentHP, player, opponent);
                        return;
                    }
                    
                    // Show round number
                    document.getElementById('simRound').textContent = ` ${currentRound}`;
                    addLog(`  ${currentRound} `, 'neutral', true);
                    
                    // Restore some stamina between rounds
                    playerStamina = Math.min(100, playerStamina + 15);
                    opponentStamina = Math.min(100, opponentStamina + 15);
                    
                    // === PLAYER ATTACK ===
                    const playerAttack = chooseAttack(playerStats, playerStamina);
                    playerStamina -= playerAttack.stamina;
                    
                    // Calculate hit chance based on speed
                    const playerHitChance = 0.6 + (playerStats.speed / 1000) * 0.3;
                    const playerHits = Math.random() < (playerHitChance * playerAttack.speed);
                    
                    if (playerHits) {
                        // Check for opponent block
                        const blockChance = (opponent.stats.defense / 1000) * 0.3;
                        const opponentBlocks = Math.random() < blockChance;
                        
                        if (opponentBlocks) {
                            fightStats.opponentBlocks++;
                            addLog(`${playerAttack.icon} ${player.firstName}  (${playerAttack.name}) -  ${opponent.firstName} !`, 'neutral');
                        } else {
                            // Calculate damage - more predictable based on stats
                            // Base damage: depends on power stat
                            // Random variance: 20% instead of huge random range
                            const baseDamage = (playerStats.power / 20) * playerAttack.damage;
                            const variance = 0.2; // 20%
                            let damage = Math.floor(baseDamage * (1 + (Math.random() * variance * 2 - variance)));
                            
                            // Stamina affects damage (50%-100%)
                            damage = Math.floor(damage * (playerStamina / 100 * 0.5 + 0.5));
                            
                            // Check for critical hit (10% chance + speed bonus)
                            const critChance = 0.10 + (playerStats.speed / 1000) * 0.1;
                            const isCrit = Math.random() < critChance;
                            
                            if (isCrit) {
                                damage = Math.floor(damage * 2);
                                fightStats.playerCrits++;
                                addLog(`${playerAttack.icon} ${player.firstName} ${playerAttack.name} -   ! -${damage} HP`, 'player', true);
                                playerCombo++;
                            } else {
                                addLog(`${playerAttack.icon} ${player.firstName} ${playerAttack.name} - ${damage} HP`, 'player');
                                playerCombo++;
                            }
                            
                            opponentHP -= damage;
                            opponentHP = Math.max(0, opponentHP); // Ensure HP doesn't go below 0
                            fightStats.playerHits++;
                            
                            // Check if opponent knocked out
                            if (opponentHP <= 0) {
                                addLog(` ${opponent.firstName} !`, 'player', true);
                                clearInterval(fightInterval);
                                addLog('', 'neutral');
                                addLog(` :  ${fightStats.playerHits}-${fightStats.opponentHits} |  ${fightStats.playerCrits}-${fightStats.opponentCrits} |  ${fightStats.playerBlocks}-${fightStats.opponentBlocks}`, 'neutral');
                                finishFight(playerHP, opponentHP, player, opponent);
                                return;
                            }
                            
                            // Combo bonus
                            if (playerCombo >= 3) {
                                const comboBonus = 5;
                                opponentHP -= comboBonus;
                                opponentHP = Math.max(0, opponentHP);
                                addLog(`  x${playerCombo}!  -${comboBonus} HP`, 'player', true);
                                
                                // Check again after combo
                                if (opponentHP <= 0) {
                                    addLog(` ${opponent.firstName} !`, 'player', true);
                                    clearInterval(fightInterval);
                                    addLog('', 'neutral');
                                    addLog(` :  ${fightStats.playerHits}-${fightStats.opponentHits} |  ${fightStats.playerCrits}-${fightStats.opponentCrits} |  ${fightStats.playerBlocks}-${fightStats.opponentBlocks}`, 'neutral');
                                    finishFight(playerHP, opponentHP, player, opponent);
                                    return;
                                }
                            }
                        }
                    } else {
                        addLog(`${playerAttack.icon} ${player.firstName} ${playerAttack.name} - `, 'player');
                        playerCombo = 0; // Reset combo on miss
                        
                        // Counter-attack chance on miss
                        if (Math.random() < 0.3) {
                            const counterDamage = Math.floor(5 + opponent.stats.power / 100);
                            playerHP -= counterDamage;
                            playerHP = Math.max(0, playerHP);
                            addLog(` ${opponent.firstName} ! -${counterDamage} HP`, 'opponent', true);
                            
                            // Check if player knocked out
                            if (playerHP <= 0) {
                                addLog(` ${player.firstName} !`, 'opponent', true);
                                clearInterval(fightInterval);
                                addLog('', 'neutral');
                                addLog(` :  ${fightStats.playerHits}-${fightStats.opponentHits} |  ${fightStats.playerCrits}-${fightStats.opponentCrits} |  ${fightStats.playerBlocks}-${fightStats.opponentBlocks}`, 'neutral');
                                finishFight(playerHP, opponentHP, player, opponent);
                                return;
                            }
                        }
                    }
                    
                    // === OPPONENT ATTACK ===
                    const opponentAttack = chooseAttack(opponent.stats, opponentStamina);
                    opponentStamina -= opponentAttack.stamina;
                    
                    const opponentHitChance = 0.6 + (opponent.stats.speed / 1000) * 0.3;
                    const opponentHitsPlayer = Math.random() < (opponentHitChance * opponentAttack.speed);
                    
                    if (opponentHitsPlayer) {
                        const playerBlockChance = (playerStats.defense / 1000) * 0.3;
                        const playerBlocksHit = Math.random() < playerBlockChance;
                        
                        if (playerBlocksHit) {
                            fightStats.playerBlocks++;
                            addLog(`${opponentAttack.icon} ${opponent.firstName}  (${opponentAttack.name}) -  ${player.firstName} !`, 'neutral');
                        } else {
                            // Calculate damage - more predictable based on stats
                            const baseDamage = (opponent.stats.power / 20) * opponentAttack.damage;
                            const variance = 0.2; // 20%
                            let damage = Math.floor(baseDamage * (1 + (Math.random() * variance * 2 - variance)));
                            
                            // Stamina affects damage (50%-100%)
                            damage = Math.floor(damage * (opponentStamina / 100 * 0.5 + 0.5));
                            
                            const critChance = 0.10 + (opponent.stats.speed / 1000) * 0.1;
                            const isCrit = Math.random() < critChance;
                            
                            if (isCrit) {
                                damage = Math.floor(damage * 2);
                                fightStats.opponentCrits++;
                                addLog(`${opponentAttack.icon} ${opponent.firstName} ${opponentAttack.name} -   ! -${damage} HP`, 'opponent', true);
                                opponentCombo++;
                            } else {
                                addLog(`${opponentAttack.icon} ${opponent.firstName} ${opponentAttack.name} - ${damage} HP`, 'opponent');
                                opponentCombo++;
                            }
                            
                            playerHP -= damage;
                            playerHP = Math.max(0, playerHP);
                            fightStats.opponentHits++;
                            
                            // Check if player knocked out
                            if (playerHP <= 0) {
                                addLog(` ${player.firstName} !`, 'opponent', true);
                                clearInterval(fightInterval);
                                addLog('', 'neutral');
                                addLog(` :  ${fightStats.playerHits}-${fightStats.opponentHits} |  ${fightStats.playerCrits}-${fightStats.opponentCrits} |  ${fightStats.playerBlocks}-${fightStats.opponentBlocks}`, 'neutral');
                                finishFight(playerHP, opponentHP, player, opponent);
                                return;
                            }
                            
                            if (opponentCombo >= 3) {
                                const comboBonus = 5;
                                playerHP -= comboBonus;
                                playerHP = Math.max(0, playerHP);
                                addLog(`  x${opponentCombo}!  -${comboBonus} HP`, 'opponent', true);
                                
                                // Check again after combo
                                if (playerHP <= 0) {
                                    addLog(` ${player.firstName} !`, 'opponent', true);
                                    clearInterval(fightInterval);
                                    addLog('', 'neutral');
                                    addLog(` :  ${fightStats.playerHits}-${fightStats.opponentHits} |  ${fightStats.playerCrits}-${fightStats.opponentCrits} |  ${fightStats.playerBlocks}-${fightStats.opponentBlocks}`, 'neutral');
                                    finishFight(playerHP, opponentHP, player, opponent);
                                    return;
                                }
                            }
                        }
                    } else {
                        addLog(`${opponentAttack.icon} ${opponent.firstName} ${opponentAttack.name} - `, 'opponent');
                        opponentCombo = 0;
                    }
                    
                    // Ensure HP doesn't go below 0
                    if (opponentHP < 0) opponentHP = 0;
                    if (playerHP < 0) playerHP = 0;
                    
                    // === SPECIAL MOMENTS ===
                    
                    // Knockdown check (when HP drops below 20)
                    if (playerHP < 20 && playerHP > 0 && Math.random() < 0.3) {
                        addLog(` ${player.firstName} !  ...`, 'opponent', true);
                        fightStats.knockdowns++;
                        playerHP -= 5;
                        playerHP = Math.max(0, playerHP);
                        
                        if (playerHP <= 0) {
                            addLog(` ${player.firstName}  ! !`, 'opponent', true);
                            clearInterval(fightInterval);
                            addLog('', 'neutral');
                            addLog(` :  ${fightStats.playerHits}-${fightStats.opponentHits} |  ${fightStats.playerCrits}-${fightStats.opponentCrits} |  ${fightStats.playerBlocks}-${fightStats.opponentBlocks}`, 'neutral');
                            finishFight(playerHP, opponentHP, player, opponent);
                            return;
                        }
                    }
                    
                    if (opponentHP < 20 && opponentHP > 0 && Math.random() < 0.3) {
                        addLog(` ${opponent.firstName} !  ...`, 'player', true);
                        fightStats.knockdowns++;
                        opponentHP -= 5;
                        opponentHP = Math.max(0, opponentHP);
                        
                        if (opponentHP <= 0) {
                            addLog(` ${opponent.firstName}  ! !`, 'player', true);
                            clearInterval(fightInterval);
                            addLog('', 'neutral');
                            addLog(` :  ${fightStats.playerHits}-${fightStats.opponentHits} |  ${fightStats.playerCrits}-${fightStats.opponentCrits} |  ${fightStats.playerBlocks}-${fightStats.opponentBlocks}`, 'neutral');
                            finishFight(playerHP, opponentHP, player, opponent);
                            return;
                        }
                    }
                    
                    // Second wind (below 30% HP)
                    if (playerHP < 30 && playerHP > 0 && currentRound > 6 && Math.random() < 0.15) {
                        addLog(` ${player.firstName}  !  !`, 'player', true);
                        playerStamina = Math.min(100, playerStamina + 30);
                    }
                    
                    if (opponentHP < 30 && opponentHP > 0 && currentRound > 6 && Math.random() < 0.15) {
                        addLog(` ${opponent.firstName}  !  !`, 'opponent', true);
                        opponentStamina = Math.min(100, opponentStamina + 30);
                    }
                    
                    // Update health bars
                    const playerBar = document.getElementById('simPlayerHealth');
                    const opponentBar = document.getElementById('simOpponentHealth');
                    
                    if (playerBar && opponentBar) {
                        playerBar.style.width = playerHP + '%';
                        opponentBar.style.width = opponentHP + '%';
                        
                        // Color health bars (keep base class)
                        playerBar.className = 'fighter-health-fill';
                        opponentBar.className = 'fighter-health-fill';
                        
                        if (playerHP < 30) playerBar.classList.add('critical');
                        else if (playerHP < 60) playerBar.classList.add('low');
                        
                        if (opponentHP < 30) opponentBar.classList.add('critical');
                        else if (opponentHP < 60) opponentBar.classList.add('low');
                    }
                    
                    currentRound++;
                }, 2500); // 2.5 seconds per round for better readability
                
            } catch (error) {
                console.error('Error in runFightSimulation:', error);
                showToast('  ', 'error');
            }
        }
        
        function finishFight(playerHP, opponentHP, player, opponent) {
            console.log('=== FINISH FIGHT CALLED ===');
            console.log('Player HP:', playerHP);
            console.log('Opponent HP:', opponentHP);
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            let result, icon, cash = 0, rep = 0;
            
            // Determine winner
            if (playerHP > opponentHP) {
                result = '!';
                icon = '';
                const baseCash = opponent.cashReward;
                cash = baseCash;
                
                // Apply MANAGER bonus first
                initializeTeam(characterData);
                const teamBonuses = getTeamBonuses(characterData);
                let managerBonus = 0;
                
                if (teamBonuses.fightEarnings > 0) {
                    const cashWithManager = Math.floor(cash * (1 + teamBonuses.fightEarnings));
                    managerBonus = cashWithManager - cash;
                    cash = cashWithManager;
                }
                
                // Check VIP status
                const isVIPActive = gameState.vipUntil && gameState.vipUntil > Date.now();
                let vipBonus = 0;
                let potentialVipBonus = 0;
                
                if (isVIPActive) {
                    // Apply VIP bonus (+15%)
                    const vipMultiplier = getVIPMultiplier('cash');
                    cash = Math.floor(baseCash * vipMultiplier);
                    vipBonus = cash - baseCash;
                } else {
                    // Calculate what VIP would give (+15%)
                    const potentialCash = Math.floor(baseCash * 1.15);
                    potentialVipBonus = potentialCash - baseCash;
                }
                
                gameState.cash += cash;
                gameState.totalWins = (gameState.totalWins || 0) + 1;
                
                // Track hard opponent wins
                if (opponent.difficulty === 'hard') {
                    gameState.hardWins = (gameState.hardWins || 0) + 1;
                }
                
                // Track win streak
                gameState.winStreak = (gameState.winStreak || 0) + 1;
                
                if (!fighter.gameData) fighter.gameData = {};
                if (!fighter.gameData.record) {
                    fighter.gameData.record = { wins: 0, losses: 0, draws: 0 };
                }
                if (!fighter.gameData.rating) fighter.gameData.rating = 0;
                
                fighter.gameData.record.wins++;
                
                // Use new ranking system
                updateRatingAfterWin(fighter, opponent);
                
                // Show rating change toast
                setTimeout(() => {
                    // Calculate same rating as updateRatingAfterWin
                    let ratingGained = 25;
                    if (opponent.isChampion) {
                        ratingGained = 50;
                    } else if (opponent.difficulty === 'hard') {
                        ratingGained = 50;
                    } else if (opponent.difficulty === 'easy') {
                        ratingGained = 15;
                    }
                    showToast(`  +${ratingGained}`, `: ${fighter.gameData.rating}`, 'success');
                }, 2000);
                
                // Award stars if it was championship fight
                if (opponent.starsReward) {
                    gameState.stars += opponent.starsReward;
                }
                
                // Calculate rating gain for display (same logic as updateRatingAfterWin)
                let displayRatingGain = 25;
                if (opponent.isChampion) {
                    displayRatingGain = 50;
                } else if (opponent.difficulty === 'hard') {
                    displayRatingGain = 50;
                } else if (opponent.difficulty === 'easy') {
                    displayRatingGain = 15;
                }
                
                // Store for result display
                fighter._lastFightRewards = {
                    cash: cash,
                    baseCash: baseCash,
                    ratingGain: displayRatingGain,
                    currentRating: fighter.gameData.rating,
                    vipBonus: vipBonus,
                    potentialVipBonus: potentialVipBonus,
                    managerBonus: managerBonus,
                    isVIPActive: isVIPActive,
                    starsReward: opponent.starsReward || 0,
                    beltWon: opponent.belt || null
                };
                
            } else if (opponentHP > playerHP) {
                result = '';
                icon = '';
                
                // Reset win streak on loss
                gameState.winStreak = 0;
                
                if (!fighter.gameData) fighter.gameData = {};
                if (!fighter.gameData.record) {
                    fighter.gameData.record = { wins: 0, losses: 0, draws: 0 };
                }
                if (!fighter.gameData.rating) fighter.gameData.rating = 0;
                
                fighter.gameData.record.losses++;
                
                // Use new ranking system
                updateRatingAfterLoss(fighter, opponent);
                
                fighter._lastFightRewards = null;
                
            } else {
                result = '';
                icon = '';
                const baseCash = Math.floor(opponent.cashReward * 0.3);
                cash = baseCash;
                
                // Check VIP for draw
                const isVIPActive = gameState.isVIP && gameState.vipEndTime > Date.now();
                let vipBonus = 0;
                let potentialVipBonus = 0;
                
                if (isVIPActive) {
                    const vipMultiplier = getVIPMultiplier('cash');
                    cash = Math.floor(baseCash * vipMultiplier);
                    vipBonus = cash - baseCash;
                } else {
                    const potentialCash = Math.floor(baseCash * 1.15);
                    potentialVipBonus = potentialCash - baseCash;
                }
                
                gameState.cash += cash;
                
                if (!fighter.gameData) fighter.gameData = {};
                if (!fighter.gameData.record) {
                    fighter.gameData.record = { wins: 0, losses: 0, draws: 0 };
                }
                if (!fighter.gameData.rating) fighter.gameData.rating = 0;
                
                fighter.gameData.record.draws++;
                
                fighter._lastFightRewards = {
                    cash: cash,
                    baseCash: baseCash,
                    vipBonus: vipBonus,
                    potentialVipBonus: potentialVipBonus,
                    isVIPActive: isVIPActive
                };
            }
            
            // ADD FIGHT TO HISTORY
            if (!fighter.fightHistory) fighter.fightHistory = [];
            
            const fightResult = playerHP > opponentHP ? 'win' : (opponentHP > playerHP ? 'loss' : 'draw');
            fighter.fightHistory.push({
                date: Date.now(),
                opponentName: `${opponent.firstName} "${opponent.nickname}"`,
                difficulty: opponent.difficulty,
                result: fightResult
            });
            
            if (fighter.fightHistory.length > 50) {
                fighter.fightHistory = fighter.fightHistory.slice(-50);
            }
            
            // Set cooldown
            if (!fighter.fightCooldown) fighter.fightCooldown = {};
            fighter.fightCooldown.nextAvailable = Date.now() + (2 * 60 * 60 * 1000);
            
            // CHECK FOR INJURY
            const injury = checkForInjury(fighter, opponent.difficulty, fightResult);
            if (injury) {
                fighter.injury = injury;
                console.log('Fighter injured:', injury.name);
            }
            
            // Save
            saveGameSync(characterData);
            updateResourceBar(); // Update rating display after fight
            
            // Check achievements - wrapped in try-catch to prevent breaking
            try {
                if (typeof checkAchievements === 'function') {
                    checkAchievements(characterData);
                }
            } catch (error) {
                console.error('Achievement check error (non-critical):', error);
            }
            
            // === THIS IS THE WORKING CODE FROM TEST FILE ===
            console.log('HIDING simulation...');
            const simContent = document.getElementById('fightSimContent');
            console.log('simContent element:', simContent);
            simContent.style.display = 'none';
            console.log('simContent hidden! display =', simContent.style.display);
            
            console.log('SHOWING result...');
            const resultDiv = document.getElementById('fightResultDisplay');
            console.log('resultDiv element:', resultDiv);
            
            let rewardsHTML = '';
            if (fighter._lastFightRewards) {
                const rewards = fighter._lastFightRewards;
                
                rewardsHTML = `
                    ${rewards.beltWon ? `
                        <div style="background: linear-gradient(135deg, ${rewards.beltWon.color}20, ${rewards.beltWon.color}10); 
                                    border: 2px solid ${rewards.beltWon.color}; border-radius: 12px; 
                                    padding: 1.5rem; margin-bottom: 1.5rem; text-align: center; animation: pulse 0.5s;">
                            <div style="font-size: 3rem; margin-bottom: 0.5rem; 
                                        filter: drop-shadow(0 0 15px ${rewards.beltWon.color});">
                                ${rewards.beltWon.icon}
                            </div>
                            <div style="color: ${rewards.beltWon.color}; font-weight: 700; font-size: 1.3rem; margin-bottom: 0.3rem;">
                                 !
                            </div>
                            <div style="color: white; font-size: 1rem;">
                                ${rewards.beltWon.name}
                            </div>
                        </div>
                    ` : ''}
                    <div class="result-rewards">
                        ${rewards.cash > 0 ? `
                            <div class="reward-item">
                                <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                                    <span style="font-size: 1.2rem;"> +$${formatNumber(rewards.cash)}</span>
                                </div>
                                ${rewards.managerBonus > 0 ? `
                                    <div style="font-size: 0.85rem; color: #fbbf24; margin-top: 0.3rem;">
                                         : +$${formatNumber(rewards.managerBonus)}
                                    </div>
                                ` : ''}
                                ${rewards.isVIPActive ? `
                                    <div style="font-size: 0.85rem; color: var(--gold); margin-top: 0.3rem;">
                                         VIP : +$${formatNumber(rewards.vipBonus)}
                                    </div>
                                ` : `
                                    <div style="font-size: 0.8rem; color: rgba(255,215,0,0.6); margin-top: 0.3rem;">
                                          VIP: +$${formatNumber(rewards.potentialVipBonus)} 
                                    </div>
                                `}
                            </div>
                        ` : ''}
                        ${rewards.ratingGain > 0 ? `<div class="reward-item">  +${rewards.ratingGain} (${rewards.currentRating})</div>` : ''}
                        ${rewards.starsReward > 0 ? `<div class="reward-item"> +${rewards.starsReward}</div>` : ''}
                    </div>
                `;
            }
            
            resultDiv.innerHTML = `
                <div class="result-icon">${icon}</div>
                <div class="result-title">${result}</div>
                <div class="result-subtitle">vs ${opponent.firstName} "${opponent.nickname}"</div>
                ${rewardsHTML}
                <button class="continue-btn" onclick="closeFightResult()">
                    
                </button>
            `;
            
            resultDiv.classList.add('show');
            console.log('Result classList:', resultDiv.classList);
            console.log('Result display:', window.getComputedStyle(resultDiv).display);
            console.log('=== RESULT SHOULD BE VISIBLE NOW ===');
            
            // Show injury modal if injured
            if (injury) {
                setTimeout(() => {
                    showToast(` ! ${injury.name}`, 'error');
                    setTimeout(() => {
                        openTreatmentModal();
                    }, 1500);
                }, 2000);
            }
        }
        
        function closeFightResult() {
            // Check if belt was won
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (fighter._lastFightRewards && fighter._lastFightRewards.beltWon) {
                const belt = fighter._lastFightRewards.beltWon;
                
                // Show belt celebration toast
                setTimeout(() => {
                    showToast(`  ! ${belt.name}!`, 'success');
                }, 500);
            }
            
            // Hide result
            document.getElementById('fightResultDisplay').classList.remove('show');
            
            // Show simulation content again (for next fight)
            document.getElementById('fightSimContent').style.display = 'block';
            
            // Go back to fights screen
            showScreen('fightsScreen');
            loadFightsScreen();
            
            // Check for random event after fight
            triggerRandomEventCheck();
        }
        
        // ===== RANDOM EVENTS SYSTEM =====
        
        function getModifiedStats(fighter) {
            const baseStats = { ...fighter.stats };
            const buffs = getActiveBuffs(fighter);
            
            if (buffs) {
                baseStats.power += buffs.power;
                baseStats.speed += buffs.speed;
                baseStats.stamina += buffs.stamina;
                baseStats.defense += buffs.defense;
            }
            
            return baseStats;
        }
        
        function getBuffsDisplay(fighter) {
            const buffs = getActiveBuffs(fighter);
            if (!buffs) return '';
            
            const buffItems = [];
            if (buffs.power > 0) buffItems.push(` +${buffs.power}`);
            if (buffs.speed > 0) buffItems.push(` +${buffs.speed}`);
            if (buffs.stamina > 0) buffItems.push(` +${buffs.stamina}`);
            if (buffs.defense > 0) buffItems.push(` +${buffs.defense}`);
            if (buffs.form > 0) buffItems.push(` +${buffs.form}%`);
            
            return buffItems.join(' ');
        }
        
        function getSponsorDisplay(fighter) {
            const sponsorBonus = getSponsorBonus(fighter);
            if (sponsorBonus === 0) return '';
            
            return ` : +${Math.round(sponsorBonus * 100)}%  `;
        }
        
        function triggerRandomEventCheck() {
            if (!shouldTriggerEvent()) return;
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const event = getRandomEvent(characterData);
            
            if (event) {
                setTimeout(() => showRandomEvent(event), 1000);
            }
        }
        
        function showRandomEvent(event) {
            const overlay = document.getElementById('eventOverlay');
            const icon = document.getElementById('eventIcon');
            const title = document.getElementById('eventTitle');
            const description = document.getElementById('eventDescription');
            const choices = document.getElementById('eventChoices');
            
            icon.textContent = event.icon;
            title.textContent = event.title;
            description.textContent = event.description;
            
            // Generate choice buttons
            choices.innerHTML = event.choices.map((choice, index) => `
                <button class="event-choice-btn" 
                        onclick="handleEventChoice('${event.id}', ${index})"
                        style="background: linear-gradient(135deg, #4ade80, #22c55e); 
                               color: white; 
                               border: none; 
                               padding: 1rem 1.5rem; 
                               border-radius: 12px; 
                               font-size: 1rem; 
                               font-weight: 600; 
                               cursor: pointer;
                               transition: all 0.3s;
                               box-shadow: 0 4px 15px rgba(74, 222, 128, 0.3);">
                    ${choice.text}
                </button>
            `).join('');
            
            overlay.style.display = 'flex';
            hapticMedium();
        }
        
        function handleEventChoice(eventId, choiceIndex) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const event = RANDOM_EVENTS[eventId];
            const choice = event.choices[choiceIndex];
            
            // Record event in history (for once-per-year events like birthday)
            if (!characterData.gameState.eventHistory) {
                characterData.gameState.eventHistory = {};
            }
            characterData.gameState.eventHistory[eventId] = Date.now();
            
            // Apply effects
            const specialResults = applyEventEffects(characterData, choice.effects);
            
            // Save
            saveGameSync(characterData);
            
            // Close event
            document.getElementById('eventOverlay').style.display = 'none';
            
            // Show result
            let resultMessage = choice.result;
            
            if (specialResults.injury) {
                resultMessage += '\n  !';
            }
            
            if (specialResults.dopingFailed) {
                resultMessage = ' - !\n\n: -$50,000\n: -5,000\n: -200\n\n \'  !';
            }
            
            showToast(resultMessage, specialResults.dopingFailed ? 'error' : 'success');
            
            // Refresh current screen
            const currentScreen = document.querySelector('.screen.active');
            if (currentScreen) {
                const screenId = currentScreen.id;
                if (screenId === 'managerScreen') loadManagerScreen();
                if (screenId === 'fightsScreen') loadFightsScreen();
            }
        }
        
        // ===== END NEW FIGHT SYSTEM =====
        
        
        function openAcademy() {
            showScreen('academyScreen');
            currentAcademyTab = 'rookies';
            document.getElementById('academyTabRookies').classList.add('active');
            document.getElementById('academyTabMarket').classList.remove('active');
            loadAcademyScreen();
        }
        
        function openMarket() {
            showScreen('academyScreen');
            currentAcademyTab = 'market';
            document.getElementById('academyTabRookies').classList.remove('active');
            document.getElementById('academyTabMarket').classList.add('active');
            loadMarketScreen();
        }
        
        // ACADEMY SYSTEM
        let academyTimer = null;
        
        function loadAcademyScreen() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // Initialize academy data
            if (!gameState.academyData) {
                gameState.academyData = {
                    lastRefresh: Date.now(),
                    candidates: generateCandidates()
                };
                saveGameSync(characterData);
            }
            
            const academyData = gameState.academyData;
            const content = document.getElementById('academyContent');
            
            // Check if refresh is needed (3 days = 72 hours)
            const refreshTime = 3 * 24 * 60 * 60 * 1000; // 3 days
            const timeSinceRefresh = Date.now() - academyData.lastRefresh;
            
            let html = '';
            
            // Timer card
            if (timeSinceRefresh < refreshTime) {
                const remaining = refreshTime - timeSinceRefresh;
                html += `
                    <div class="academy-timer-card">
                        <div class="academy-timer-label">   :</div>
                        <div class="academy-timer-value" id="academyTimerDisplay">...</div>
                        <button class="academy-refresh-button" onclick="refreshAcademyCandidates()">
                                30
                        </button>
                    </div>
                `;
            } else {
                html += `
                    <div class="academy-timer-card">
                        <div class="academy-timer-label">   !</div>
                        <button class="academy-refresh-button" onclick="autoRefreshAcademy()" style="background: linear-gradient(135deg, var(--gold), #FFA500); border: none; color: var(--dark-bg);">
                               
                        </button>
                    </div>
                `;
            }
            
            // Candidates
            html += `
                <div class="academy-candidates">
                    <div class="academy-candidates-title">  </div>
                    ${academyData.candidates.map((candidate, idx) => createCandidateCard(candidate, idx, gameState)).join('')}
                </div>
            `;
            
            content.innerHTML = html;
            
            // Start timer if needed
            if (timeSinceRefresh < refreshTime) {
                startAcademyTimer(academyData.lastRefresh + refreshTime);
            }
        }
        
        function generateCandidates() {
            const firstNames = ['', '', '', '', '', '', '', '', ''];
            const lastNames = ['', '', '', '', '', '', '', '', ''];
            const nicknames = ['', '', '', '', '', '', '', '', ''];
            const avatars = ['', '', ''];
            
            const candidates = [];
            
            for (let i = 0; i < 3; i++) {
                // Generate talent (weighted random)
                let talent;
                const rand = Math.random();
                if (rand < 0.01) talent = 10; // 1% chance
                else if (rand < 0.05) talent = 9; // 4% chance
                else if (rand < 0.15) talent = 8; // 10% chance
                else if (rand < 0.30) talent = 7; // 15% chance
                else if (rand < 0.50) talent = 6; // 20% chance
                else if (rand < 0.70) talent = 5; // 20% chance
                else if (rand < 0.85) talent = 4; // 15% chance
                else talent = 3; // 15% chance
                
                const age = Math.floor(Math.random() * 3) + 16; // 16-18
                const weight = Math.floor(Math.random() * 15) + 65; // 65-79 (young fighters)
                
                // Balanced stats:   =   ( )
                //        
                const baseStats = 30 - (talent * 2); //   =  
                const variance = 5;
                
                const candidate = {
                    firstName: firstNames[Math.floor(Math.random() * firstNames.length)],
                    lastName: lastNames[Math.floor(Math.random() * lastNames.length)],
                    nickname: nicknames[Math.floor(Math.random() * nicknames.length)],
                    avatar: avatars[Math.floor(Math.random() * avatars.length)],
                    age: age,
                    weight: weight,
                    talent: talent,
                    stats: {
                        power: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance))),
                        speed: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance))),
                        stamina: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance))),
                        defense: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance)))
                    },
                    price: calculateCandidatePrice(talent)
                };
                
                candidates.push(candidate);
            }
            
            // Sort by talent (highest first)
            return candidates.sort((a, b) => b.talent - a.talent);
        }
        
        function calculateCandidatePrice(talent) {
            if (talent <= 4) return 3000;
            if (talent <= 6) return 10000;
            if (talent <= 8) return 25000;
            if (talent === 9) return 60000;
            return 150000; // talent 10
        }
        
        function createCandidateCard(candidate, index, gameState) {
            const avgStat = Math.floor((candidate.stats.power + candidate.stats.speed + candidate.stats.stamina + candidate.stats.defense) / 4);
            const canAfford = gameState.cash >= candidate.price;
            
            return `
                <div class="candidate-card">
                    <div class="candidate-header">
                        <div class="candidate-avatar">${candidate.avatar}</div>
                        <div class="candidate-info">
                            <div class="candidate-name">${candidate.firstName} "${candidate.nickname}" ${candidate.lastName}</div>
                            <div class="candidate-details">${candidate.age} , ${candidate.weight} </div>
                        </div>
                        <div class="candidate-talent-badge"> ${candidate.talent}</div>
                    </div>
                    
                    <div class="candidate-stats">
                        <div class="candidate-stat">
                            <div class="candidate-stat-label"></div>
                            <div class="candidate-stat-value">${candidate.stats.power}</div>
                        </div>
                        <div class="candidate-stat">
                            <div class="candidate-stat-label"></div>
                            <div class="candidate-stat-value">${candidate.stats.speed}</div>
                        </div>
                        <div class="candidate-stat">
                            <div class="candidate-stat-label"></div>
                            <div class="candidate-stat-value">${candidate.stats.stamina}</div>
                        </div>
                        <div class="candidate-stat">
                            <div class="candidate-stat-label"></div>
                            <div class="candidate-stat-value">${candidate.stats.defense}</div>
                        </div>
                    </div>
                    
                    <div class="candidate-price">
                        <div class="candidate-price-label"> :</div>
                        <div class="candidate-price-value"> $${candidate.price.toLocaleString()}</div>
                    </div>
                    
                    <button class="candidate-hire-button" 
                            onclick="hireCandidate(${index})"
                            ${!canAfford ? 'disabled' : ''}>
                        ${!canAfford ? ' ' : ''}
                    </button>
                </div>
            `;
        }
        
        function startAcademyTimer(endTime) {
            if (academyTimer) clearInterval(academyTimer);
            
            academyTimer = setInterval(() => {
                const remaining = Math.max(0, endTime - Date.now());
                
                if (remaining <= 0) {
                    clearInterval(academyTimer);
                    loadAcademyScreen();
                    return;
                }
                
                const days = Math.floor(remaining / (24 * 60 * 60 * 1000));
                const hours = Math.floor((remaining % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
                const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
                
                const timerEl = document.getElementById('academyTimerDisplay');
                if (timerEl) {
                    timerEl.textContent = `${days}  ${hours}  ${minutes} `;
                }
            }, 1000);
        }
        
        function refreshAcademyCandidates() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // Check if enough stars
            if (gameState.stars < 30) {
                alert('  Stars!\n\n:  30\n :  ' + gameState.stars);
                return;
            }
            
            // Deduct stars
            gameState.stars -= 30;
            
            // Generate new candidates
            gameState.academyData.candidates = generateCandidates();
            gameState.academyData.lastRefresh = Date.now();
            
            saveGameSync(characterData);
            
            alert('  !\n\n  !');
            
            if (academyTimer) clearInterval(academyTimer);
            loadAcademyScreen();
        }
        
        function autoRefreshAcademy() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // Generate new candidates (free auto-refresh)
            gameState.academyData.candidates = generateCandidates();
            gameState.academyData.lastRefresh = Date.now();
            
            saveGameSync(characterData);
            
            if (academyTimer) clearInterval(academyTimer);
            loadAcademyScreen();
        }
        
        function hireCandidate(index) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const candidate = gameState.academyData.candidates[index];
            
            // Check if enough money
            if (gameState.cash < candidate.price) {
                showToast(' !', `: $${candidate.price.toLocaleString()}\n : $${gameState.cash.toLocaleString()}`, 'error');
                return;
            }
            
            // Check if has free slot
            const availableSlots = characterData.unlockedSlots || 1;
            const activeFighters = characterData.fighters.filter(f => !f.retired).length;
            
            if (activeFighters >= availableSlots) {
                showToast('  !', '     100 Stars', 'warning');
                return;
            }
            
            // Show loading
            showLoading();
            
            // Deduct money
            gameState.cash -= candidate.price;
            
            // Initialize candidate as fighter
            candidate.gameData = {
                rating: 1000,
                form: calculateFormByAge(candidate.age),
                record: { wins: 0, losses: 0, draws: 0 }
            };
            candidate.agingData = {
                lastCheckDate: Date.now(),
                monthsPlayed: 0,
                birthdayMonth: new Date().getMonth()
            };
            
            // Add to fighters
            characterData.fighters.push(candidate);
            gameState.totalFighters++;
            
            // Set as active if first fighter or only active one is retired
            if (characterData.fighters.filter(f => !f.retired).length === 1) {
                characterData.activeFighterIndex = characterData.fighters.length - 1;
            }
            
            saveGameSync(characterData);
            
            hideLoading();
            
            showToast('  !', `${candidate.firstName} "${candidate.nickname}"\n : ${candidate.talent}`, 'success');
            
            setTimeout(() => {
                backToGame();
            }, 1500);
        }
// MARKET FUNCTIONS TO ADD AFTER hireCandidate function

let currentAcademyTab = 'rookies';

function switchAcademyTab(tab) {
    currentAcademyTab = tab;
    document.getElementById('academyTabRookies').classList.toggle('active', tab === 'rookies');
    document.getElementById('academyTabMarket').classList.toggle('active', tab === 'market');
    
    if (tab === 'rookies') {
        loadAcademyScreen();
    } else {
        loadMarketScreen();
    }
}

function loadMarketScreen() {
    const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
    const gameState = characterData.gameState;
    
    if (!gameState.marketData || Date.now() - gameState.marketData.lastRefresh > 6 * 60 * 60 * 1000) {
        gameState.marketData = { lastRefresh: Date.now(), fighters: generateMarketFighters() };
        saveGameSync(characterData);
    }
    
    const content = document.getElementById('academyContent');
    const remaining = (gameState.marketData.lastRefresh + 6 * 60 * 60 * 1000) - Date.now();
    const hours = Math.floor(remaining / (60 * 60 * 1000));
    const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
    
    content.innerHTML = `
        <div class="academy-timer-card">
            <div class="academy-timer-label">   : ${hours} ${minutes}</div>
            <button class="academy-refresh-button" onclick="refreshMarket()">   50</button>
        </div>
        <div class="academy-candidates">
            <div class="academy-candidates-title">  </div>
            ${gameState.marketData.fighters.map((f, i) => createMarketCard(f, i, gameState)).join('')}
        </div>
    `;
}

function generateMarketFighters() {
    const names = ['', '', '', '', ''];
    const last = ['', '', '', ''];
    const nicks = ['', '', '', '', ''];
    const ava = ['', '', ''];
    
    return Array(3).fill().map(() => {
        // Weighted talent (Academy fighters are slightly better: 4-10)
        let talent;
        const rand = Math.random();
        if (rand < 0.02) {
            talent = 10; // 2% - legendary
        } else if (rand < 0.12) {
            talent = Math.random() < 0.5 ? 8 : 9; // 10% - rare
        } else if (rand < 0.40) {
            talent = Math.random() < 0.5 ? 6 : 7; // 28% - uncommon
        } else {
            talent = Math.random() < 0.5 ? 4 : 5; // 60% - common (4-5)
        }
        
        const age = Math.floor(Math.random() * 12) + 20;
        const overall = Math.floor(Math.random() * 200) + 150;
        
        return {
            firstName: names[Math.floor(Math.random() * names.length)],
            lastName: last[Math.floor(Math.random() * last.length)],
            nickname: nicks[Math.floor(Math.random() * nicks.length)],
            avatar: ava[Math.floor(Math.random() * ava.length)],
            age, weight: 65 + Math.floor(Math.random() * 30), talent,
            stats: { power: overall + Math.floor(Math.random() * 30), speed: overall + Math.floor(Math.random() * 30), 
                    stamina: overall + Math.floor(Math.random() * 30), defense: overall + Math.floor(Math.random() * 30) },
            gameData: { record: { wins: 5 + Math.floor(Math.random() * 20), losses: Math.floor(Math.random() * 5), 
                                 draws: Math.floor(Math.random() * 3) }, form: 100 }
        };
    });
}

function createMarketCard(f, index, gameState) {
    const overall = Math.round((f.stats.power + f.stats.speed + f.stats.stamina + f.stats.defense) / 4);
    const price = calculateFighterPrice(f);
    const comm = Math.floor(price * 0.1);
    const total = price + comm;
    const canAfford = gameState.cash >= total;
    
    return `
        <div class="candidate-card">
            <div class="candidate-header">
                <div class="candidate-avatar">${f.avatar}</div>
                <div class="candidate-info">
                    <div class="candidate-name">${f.firstName} "${f.nickname}" ${f.lastName}</div>
                    <div class="candidate-details">${f.age} , ${f.weight} </div>
                </div>
                <div class="candidate-talent-badge"> ${f.talent}</div>
            </div>
            <div style="background: rgba(255,215,0,0.1); padding: 0.8rem; border-radius: 8px; margin: 1rem 0;">
                <div style="display: flex; justify-content: space-between;"><span>:</span><span style="color: var(--gold); font-weight: 700;">${overall}</span></div>
                <div style="display: flex; justify-content: space-between;"><span>:</span><span>${f.gameData.record.wins}-${f.gameData.record.losses}-${f.gameData.record.draws}</span></div>
            </div>
            <div class="candidate-stats">
                <div class="candidate-stat"><div class="candidate-stat-label"></div><div class="candidate-stat-value">${f.stats.power}</div></div>
                <div class="candidate-stat"><div class="candidate-stat-label"></div><div class="candidate-stat-value">${f.stats.speed}</div></div>
                <div class="candidate-stat"><div class="candidate-stat-label"></div><div class="candidate-stat-value">${f.stats.stamina}</div></div>
                <div class="candidate-stat"><div class="candidate-stat-label"></div><div class="candidate-stat-value">${f.stats.defense}</div></div>
            </div>
            <div class="candidate-price">
                <div class="candidate-price-label">:</div>
                <div class="candidate-price-value">$${formatNumber(total)}</div>
                <div style="font-size: 0.8rem; opacity: 0.5;">($${formatNumber(price)} + $${formatNumber(comm)} )</div>
            </div>
            <button class="candidate-hire-button" onclick="buyMarketFighter(${index})" ${!canAfford ? 'disabled' : ''}>
                ${!canAfford ? ` $${formatNumber(total)}` : ``}
            </button>
        </div>
    `;
}

function buyMarketFighter(index) {
    const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
    const gameState = characterData.gameState;
    const f = gameState.marketData.fighters[index];
    
    const price = calculateFighterPrice(f);
    const total = price + Math.floor(price * 0.1);
    
    if (gameState.cash < total) { showToast(' ! ', 'error'); return; }
    if (characterData.fighters.length >= (characterData.unlockedSlots || 1)) { 
        showToast('  ! ', 'error'); return; 
    }
    
    gameState.cash -= total;
    characterData.fighters.push(f);
    gameState.marketData.fighters.splice(index, 1);
    
    saveGameSync(characterData);
    
    showToast(`${f.firstName} "${f.nickname}" ! `, 'success');
    loadMarketScreen();
    loadGameData();
}

function refreshMarket() {
    const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
    const gameState = characterData.gameState;
    
    if (gameState.stars < 50) { showToast(' !   50', 'error'); return; }
    
    gameState.stars -= 50;
    gameState.marketData = { lastRefresh: Date.now(), fighters: generateMarketFighters() };
    saveGameSync(characterData);
    
    showToast(' ! ', 'success');
    loadMarketScreen();
}
        
        function openVIP() {
            showScreen('vipScreen');
            loadVIPScreen();
        }
        
        // VIP SYSTEM
        let vipTimer = null;
        
        const VIP_PACKAGES = [
            { days: 7, stars: 50, name: '7 ' },
            { days: 30, stars: 150, name: '30 ', recommended: true, save: ' 50 Stars!' }
        ];
        
        const VIP_BENEFITS = [
            { icon: '', title: '+20%  ', desc: '  ' },
            { icon: '', title: '+15%  ', desc: '   ' },
            { icon: '', title: '-10%  ', desc: '  ' },
            { icon: '', title: '+1 ', desc: '   ' }
        ];
        
        function loadVIPScreen() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            const content = document.getElementById('vipContent');
            
            // Check if VIP is active
            const isVIPActive = gameState.vipEndTime && gameState.vipEndTime > Date.now();
            
            let html = '';
            
            // VIP Status Card
            if (isVIPActive) {
                html += `
                    <div class="vip-status-card vip-status-active">
                        <div class="vip-status-label"> VIP </div>
                        <div class="vip-status-value"></div>
                        <div class="vip-timer" id="vipTimerDisplay">...</div>
                    </div>
                `;
            } else {
                html += `
                    <div class="vip-status-card">
                        <div class="vip-status-label">VIP </div>
                        <div class="vip-status-value"> </div>
                    </div>
                `;
            }
            
            // VIP Benefits
            html += `
                <div class="vip-benefits">
                    <div class="vip-benefits-title"> VIP </div>
            `;
            
            VIP_BENEFITS.forEach(benefit => {
                html += `
                    <div class="vip-benefit-item">
                        <div class="vip-benefit-icon">${benefit.icon}</div>
                        <div class="vip-benefit-text">
                            <div class="vip-benefit-title">${benefit.title}</div>
                            <div class="vip-benefit-desc">${benefit.desc}</div>
                        </div>
                    </div>
                `;
            });
            
            html += `</div>`;
            
            // VIP Packages
            html += `
                <div class="vip-packages">
                    <div class="vip-packages-title">  VIP</div>
            `;
            
            VIP_PACKAGES.forEach(pkg => {
                const hasEnoughStars = gameState.stars >= pkg.stars;
                
                html += `
                    <div class="vip-package ${pkg.recommended ? 'recommended' : ''}">
                        ${pkg.recommended ? '<div class="vip-package-badge"> </div>' : ''}
                        <div class="vip-package-duration">${pkg.name}</div>
                        <div class="vip-package-price"> ${pkg.stars} Stars</div>
                        ${pkg.save ? `<div class="vip-package-save">${pkg.save}</div>` : ''}
                        <button class="vip-buy-button" 
                                onclick="buyVIP(${pkg.days}, ${pkg.stars})"
                                ${!hasEnoughStars || isVIPActive ? 'disabled' : ''}>
                            ${!hasEnoughStars ? ' STARS' : isVIPActive ? 'VIP  ' : ' VIP'}
                        </button>
                    </div>
                `;
            });
            
            html += `</div>`;
            
            // Note
            html += `
                <div class="vip-note">
                    VIP     .<br>
                     VIP   .
                </div>
            `;
            
            content.innerHTML = html;
            
            // Start VIP timer if active
            if (isVIPActive) {
                startVIPTimer(gameState.vipEndTime);
            }
        }
        
        function buyVIP(days, stars) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // Check if enough stars
            if (gameState.stars < stars) {
                showToast(' Stars!', `:  ${stars}\n :  ${gameState.stars}`, 'error');
                return;
            }
            
            // Check if VIP already active
            if (gameState.vipEndTime && gameState.vipEndTime > Date.now()) {
                showToast('VIP  !', '', 'info');
                return;
            }
            
            // Deduct stars
            gameState.stars -= stars;
            
            // Activate VIP
            const endTime = Date.now() + (days * 24 * 60 * 60 * 1000);
            gameState.vipEndTime = endTime;
            gameState.isVIP = true;
            
            saveGameSync(characterData);
            
            showToast(' VIP !', `${days}  VIP \n +20% \n +15% \n -10% `, 'success');
            
            loadVIPScreen();
        }
        
        function startVIPTimer(endTime) {
            if (vipTimer) clearInterval(vipTimer);
            
            vipTimer = setInterval(() => {
                const remaining = Math.max(0, endTime - Date.now());
                
                if (remaining <= 0) {
                    // VIP expired
                    clearInterval(vipTimer);
                    expireVIP();
                    return;
                }
                
                const days = Math.floor(remaining / (24 * 60 * 60 * 1000));
                const hours = Math.floor((remaining % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
                const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
                
                const timerEl = document.getElementById('vipTimerDisplay');
                if (timerEl) {
                    if (days > 0) {
                        timerEl.textContent = `${days}  ${hours}  `;
                    } else {
                        timerEl.textContent = `${hours}  ${minutes}  `;
                    }
                }
            }, 1000);
        }
        
        function expireVIP() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            gameState.isVIP = false;
            delete gameState.vipEndTime;
            
            saveGameSync(characterData);
            
            alert(' VIP  !\n\n .\n VIP    !');
            
            // Reload VIP screen if open
            const vipScreen = document.getElementById('vipScreen');
            if (vipScreen.classList.contains('active')) {
                loadVIPScreen();
            }
            
            // Update game screen if open
            const gameScreen = document.getElementById('gameScreen');
            if (gameScreen.classList.contains('active')) {
                loadGameData();
            }
        }
        
        // Apply VIP bonuses
        function getVIPMultiplier(type) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            console.log('=== VIP CHECK ===');
            console.log('isVIP:', gameState.isVIP);
            console.log('vipEndTime:', gameState.vipEndTime);
            console.log('Current time:', Date.now());
            console.log('VIP active?', gameState.vipEndTime > Date.now());
            
            // Check if VIP is active
            if (!gameState.isVIP || !gameState.vipEndTime || gameState.vipEndTime <= Date.now()) {
                console.log('VIP NOT ACTIVE - returning multiplier 1');
                return 1;
            }
            
            console.log('VIP ACTIVE - applying bonus for type:', type);
            
            switch(type) {
                case 'training':
                    console.log('Training multiplier: 1.2');
                    return 1.2; // +20%
                case 'cash':
                    console.log('Cash multiplier: 1.15');
                    return 1.15; // +15%
                case 'time':
                    console.log('Time multiplier: 0.9');
                    return 0.9; // -10%
                default:
                    return 1;
            }
        }
        
        // AGING SYSTEM
        function initializeAgingSystem() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            
            if (!characterData.fighters) return;
            
            // Initialize aging for all fighters
            characterData.fighters.forEach(fighter => {
                if (!fighter.agingData) {
                    fighter.agingData = {
                        lastCheckDate: Date.now(),
                        monthsPlayed: 0,
                        birthdayMonth: new Date().getMonth()
                    };
                }
                
                if (!fighter.gameData) {
                    fighter.gameData = {
                        form: calculateFormByAge(fighter.age),
                        rating: 1000,
                        record: { wins: 0, losses: 0, draws: 0 }
                    };
                }
            });
            
            saveGameSync(characterData);
            
            // Check aging every time game loads
            checkAging();
        }
        
        function checkAging() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            
            if (!characterData.fighters) return;
            
            characterData.fighters.forEach(fighter => {
                if (!fighter.agingData) return;
                
                const now = Date.now();
                const lastCheck = fighter.agingData.lastCheckDate;
                const monthsPassed = Math.floor((now - lastCheck) / (30 * 24 * 60 * 60 * 1000));
                
                if (monthsPassed >= 1) {
                    for (let i = 0; i < monthsPassed; i++) {
                        ageFighter(characterData, fighter);
                    }
                    
                    fighter.agingData.lastCheckDate = now;
                    fighter.agingData.monthsPlayed += monthsPassed;
                }
            });
            
            saveGameSync(characterData);
        }
        
        function ageFighter(characterData, fighter) {
            const oldAge = fighter.age;
            fighter.age += 1;
            
            // Calculate form based on age
            const newForm = calculateFormByAge(fighter.age);
            const oldForm = fighter.gameData.form;
            fighter.gameData.form = newForm;
            
            // Check for retirement (40-45 years)
            if (fighter.age >= 40 && fighter.age < 45) {
                const retirementChance = getRetirementChance(fighter.age);
                if (Math.random() < retirementChance) {
                    retireFighter(fighter);
                    return;
                }
            } else if (fighter.age >= 45) {
                retireFighter(fighter);
                return;
            }
            
            // Show birthday message
            let message = `  !\n\n${fighter.firstName} "${fighter.nickname}" ${fighter.lastName}\n ${fighter.age} \n\n`;
            
            if (newForm < oldForm) {
                message += `  : ${oldForm}%  ${newForm}%\n`;
            } else if (newForm > oldForm) {
                message += `  : ${oldForm}%  ${newForm}%\n`;
            } else {
                message += `    : ${newForm}%\n`;
            }
            
            if (fighter.age === 33) {
                message += `\n     '.   .`;
            } else if (fighter.age === 37) {
                message += `\n   !   .`;
            } else if (fighter.age === 40) {
                message += `\n ! '    - !`;
            } else if (fighter.age >= 41) {
                message += `\n !    '!`;
            }
            
            alert(message);
        }
        
        function calculateFormByAge(age) {
            if (age <= 25) {
                // Growing: 80% at 18  100% at 25
                const yearsFromStart = age - 18;
                return Math.min(100, 80 + (yearsFromStart * 2));
            } else if (age <= 32) {
                // Peak: 100%
                return 100;
            } else if (age <= 36) {
                // Decline: -5% per year
                const yearsAfterPeak = age - 32;
                return Math.max(50, 100 - (yearsAfterPeak * 5));
            } else if (age <= 39) {
                // Steep decline: -10% per year
                const yearsAfterPeak = age - 32;
                const declineTo36 = 100 - (4 * 5); // 80% at 36
                const declineAfter36 = (age - 36) * 10;
                return Math.max(30, declineTo36 - declineAfter36);
            } else {
                // Critical: very low form
                const yearsAfterPeak = age - 32;
                const declineTo36 = 100 - (4 * 5); // 80% at 36
                const declineTo39 = declineTo36 - (3 * 10); // 50% at 39
                const declineAfter39 = (age - 39) * 10;
                return Math.max(20, declineTo39 - declineAfter39);
            }
        }
        
        function getRetirementChance(age) {
            // Retirement probability per month
            if (age === 40) return 0.10; // 10% per month
            if (age === 41 || age === 42) return 0.20; // 20% per month
            if (age === 43 || age === 44) return 0.40; // 40% per month
            return 1.0; // 100% at 45
        }
        
        function retireFighter(fighter) {
            const record = fighter.gameData.record;
            
            let message = `  '\n\n`;
            message += `${fighter.firstName} "${fighter.nickname}" ${fighter.lastName}\n`;
            message += `: ${fighter.age} \n\n`;
            message += `  :\n`;
            message += ` : ${record.wins}\n`;
            message += ` : ${record.losses}\n`;
            message += ` : ${record.draws}\n`;
            message += ` : ${fighter.gameData.rating}\n\n`;
            
            if (fighter.age >= 45) {
                message += `    .\n`;
            } else {
                message += `    '.\n`;
            }
            
            message += `\n      !`;
            
            alert(message);
            
            // Mark fighter as retired
            fighter.retired = true;
            fighter.retirementDate = Date.now();
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            saveGameSync(characterData);
        }
        
        function applyFormToTraining(baseReward, form) {
            // Form affects training results
            const formMultiplier = form / 100;
            return Math.floor(baseReward * formMultiplier);
        }
        
        function applyFormToDamage(baseDamage, form) {
            // Form affects fight damage
            const formMultiplier = form / 100;
            return Math.floor(baseDamage * formMultiplier);
        }
        
        function openFighterDetails() {
            hapticMedium();
            showScreen('fighterStatsScreen');
            loadFighterStats();
        }
        
        function loadFighterStats() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (!fighter) {
                showToast('!', '  ', 'error');
                backToGame();
                return;
            }
            
            // Fighter card header
            const card = document.getElementById('statsFighterCard');
            card.innerHTML = `
                <div class="stats-fighter-avatar">${fighter.avatar}</div>
                <div class="stats-fighter-info">
                    <div class="stats-fighter-name">${fighter.firstName} "${fighter.nickname}" ${fighter.lastName}</div>
                    <div class="stats-fighter-details">
                        <span>${fighter.age} </span>
                        <span>${fighter.weight} </span>
                        <span> ${fighter.talent}</span>
                    </div>
                    <div class="stats-fighter-record">
                        ${fighter.gameData.record.wins}-${fighter.gameData.record.losses}-${fighter.gameData.record.draws}
                    </div>
                </div>
            `;
            
            // Stats content
            const content = document.getElementById('statsContent');
            
            // Calculate stats
            const totalFights = fighter.gameData.record.wins + fighter.gameData.record.losses + fighter.gameData.record.draws;
            const winRate = totalFights > 0 ? Math.round((fighter.gameData.record.wins / totalFights) * 100) : 0;
            const avgStat = Math.round((fighter.stats.power + fighter.stats.speed + fighter.stats.stamina + fighter.stats.defense) / 4);
            
            // Age status
            let ageStatus = '';
            let ageColor = '';
            if (fighter.age < 26) {
                ageStatus = ' ';
                ageColor = '#4ade80';
            } else if (fighter.age < 33) {
                ageStatus = ' ';
                ageColor = '#fbbf24';
            } else if (fighter.age < 37) {
                ageStatus = ' ';
                ageColor = '#fb923c';
            } else {
                ageStatus = ' ';
                ageColor = '#ef4444';
            }
            
            content.innerHTML = `
                <!-- Championship Belts -->
                ${fighter.belts && Object.keys(fighter.belts).length > 0 ? `
                    <div class="stats-section">
                        <div class="stats-section-title">  </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
                            ${Object.keys(fighter.belts).map(beltId => {
                                const belt = CHAMPIONSHIP_BELTS.find(b => b.id === beltId);
                                const beltData = fighter.belts[beltId];
                                if (!belt) return '';
                                
                                return `
                                    <div style="background: linear-gradient(135deg, ${belt.color}20, ${belt.color}10); 
                                                border: 2px solid ${belt.color}; border-radius: 12px; 
                                                padding: 1rem; text-align: center;">
                                        <div style="font-size: 2.5rem; margin-bottom: 0.5rem; 
                                                    filter: drop-shadow(0 0 10px ${belt.color});">
                                            ${belt.icon}
                                        </div>
                                        <div style="color: ${belt.color}; font-weight: 700; font-size: 0.9rem; margin-bottom: 0.3rem;">
                                            ${belt.name}
                                        </div>
                                        <div style="color: rgba(255,255,255,0.7); font-size: 0.75rem;">
                                            : ${beltData.defenses}
                                        </div>
                                        <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem; margin-top: 0.3rem;">
                                            ${new Date(beltData.wonDate).toLocaleDateString('uk-UA')}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                ` : ''}
                
                <!-- Overview Stats -->
                <div class="stats-section">
                    <div class="stats-section-title">  </div>
                    <div class="stats-grid">
                        <div class="stats-box highlight">
                            <div class="stats-box-label"></div>
                            <div class="stats-box-value">${fighter.gameData.rating}</div>
                        </div>
                        <div class="stats-box">
                            <div class="stats-box-label"></div>
                            <div class="stats-box-value">${fighter.gameData.form}%</div>
                        </div>
                        <div class="stats-box">
                            <div class="stats-box-label"> </div>
                            <div class="stats-box-value">${totalFights}</div>
                        </div>
                        <div class="stats-box">
                            <div class="stats-box-label">% </div>
                            <div class="stats-box-value">${winRate}%</div>
                        </div>
                        <div class="stats-box">
                            <div class="stats-box-label"> </div>
                            <div class="stats-box-value">${avgStat}</div>
                        </div>
                        <div class="stats-box">
                            <div class="stats-box-label"></div>
                            <div class="stats-box-value" style="color: ${ageColor}">${ageStatus}</div>
                        </div>
                    </div>
                </div>
                
                <!-- Fighting Stats -->
                <div class="stats-section">
                    <div class="stats-section-title">  </div>
                    <div class="stats-bar-item">
                        <div class="stats-bar-header">
                            <span class="stats-bar-label"> </span>
                            <span class="stats-bar-value">${fighter.stats.power}/1000</span>
                        </div>
                        <div class="stats-bar-container">
                            <div class="stats-bar-fill" style="width: ${(fighter.stats.power / 1000 * 100)}%"></div>
                        </div>
                    </div>
                    <div class="stats-bar-item">
                        <div class="stats-bar-header">
                            <span class="stats-bar-label"> </span>
                            <span class="stats-bar-value">${fighter.stats.speed}/1000</span>
                        </div>
                        <div class="stats-bar-container">
                            <div class="stats-bar-fill" style="width: ${(fighter.stats.speed / 1000 * 100)}%"></div>
                        </div>
                    </div>
                    <div class="stats-bar-item">
                        <div class="stats-bar-header">
                            <span class="stats-bar-label"> </span>
                            <span class="stats-bar-value">${fighter.stats.stamina}/1000</span>
                        </div>
                        <div class="stats-bar-container">
                            <div class="stats-bar-fill" style="width: ${(fighter.stats.stamina / 1000 * 100)}%"></div>
                        </div>
                    </div>
                    <div class="stats-bar-item">
                        <div class="stats-bar-header">
                            <span class="stats-bar-label"> </span>
                            <span class="stats-bar-value">${fighter.stats.defense}/1000</span>
                        </div>
                        <div class="stats-bar-container">
                            <div class="stats-bar-fill" style="width: ${(fighter.stats.defense / 1000 * 100)}%"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Fight History -->
                <div class="stats-section">
                    <div class="stats-section-title">  </div>
                    ${generateFightHistory(fighter)}
                </div>
                
                <!-- Badges/Achievements -->
                <div class="stats-section">
                    <div class="stats-section-title"> </div>
                    ${generateBadges(fighter)}
                </div>
            `;
        }
        
        function generateFightHistory(fighter) {
            if (!fighter.fightHistory || fighter.fightHistory.length === 0) {
                return '<div class="stats-empty">   <br>  !</div>';
            }
            
            // Show last 10 fights
            const recentFights = fighter.fightHistory.slice(-10).reverse();
            
            return `
                <div class="fight-history-list">
                    ${recentFights.map(fight => {
                        const resultIcon = fight.result === 'win' ? '' : fight.result === 'loss' ? '' : '';
                        const date = new Date(fight.date).toLocaleDateString('uk-UA', { 
                            day: 'numeric', 
                            month: 'short' 
                        });
                        
                        return `
                            <div class="fight-history-item ${fight.result}">
                                <div class="fight-history-result">${resultIcon}</div>
                                <div class="fight-history-info">
                                    <div class="fight-history-opponent">
                                        vs ${fight.opponentName}
                                    </div>
                                    <div class="fight-history-date">${date}  ${fight.difficulty}</div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        function generateBadges(fighter) {
            const badges = [];
            const record = fighter.gameData.record;
            const totalFights = record.wins + record.losses + record.draws;
            
            // First Fight
            if (totalFights > 0) {
                badges.push({ icon: '', label: ' ' });
            }
            
            // Win milestones
            if (record.wins >= 1) badges.push({ icon: '', label: ' ' });
            if (record.wins >= 10) badges.push({ icon: '', label: '10 ' });
            if (record.wins >= 25) badges.push({ icon: '', label: '25 ' });
            if (record.wins >= 50) badges.push({ icon: '', label: '' });
            if (record.wins >= 100) badges.push({ icon: '', label: '' });
            
            // Perfect stats
            if (fighter.stats.power === 1000) badges.push({ icon: '', label: ' ' });
            if (fighter.stats.speed === 1000) badges.push({ icon: '', label: '' });
            if (fighter.stats.stamina === 1000) badges.push({ icon: '', label: ' ' });
            if (fighter.stats.defense === 1000) badges.push({ icon: '', label: '' });
            
            // Veteran
            if (fighter.age >= 35) badges.push({ icon: '', label: '' });
            
            // High talent
            if (fighter.talent >= 9) badges.push({ icon: '', label: '' });
            
            if (badges.length === 0) {
                return '<div class="stats-empty">   <br>   !</div>';
            }
            
            return `
                <div class="stats-badges">
                    ${badges.map(badge => `
                        <div class="stats-badge">
                            <span class="stats-badge-icon">${badge.icon}</span>
                            <span>${badge.label}</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        // Handle back button
        tg.BackButton.onClick(() => {
            const currentScreen = document.querySelector('.screen.active').id;
            
            if (currentScreen === 'characterScreen') {
                showPrologue();
            } else if (currentScreen === 'prologueScreen') {
                showScreen('loadingScreen');
            }
        });
        
        // Show back button on character screen
        const observer = new MutationObserver(() => {
            const characterScreen = document.getElementById('characterScreen');
            if (characterScreen.classList.contains('active')) {
                tg.BackButton.show();
            } else {
                tg.BackButton.hide();
            }
        });
        
        observer.observe(document.getElementById('characterScreen'), {
            attributes: true,
            attributeFilter: ['class']
        });
        
        // ===== GAME INITIALIZATION =====
        
        // Async initialization on page load
        (async function initializeGame() {
            console.log(' Game initializing...');
            
            try {
                //    Cloud
                let result = await gameStorage.loadCharacter();
                // Normalize saved data (backward compatibility)
                if (result && result.data) { result.data = normalizeCharacterData(result.data); }

                
                //  Cloud   ,  localStorage
                if (!result.data) {
                    const localData = localStorage.getItem('boxingManager_character');
                    if (localData) {
                        try {
                            const parsed = JSON.parse(localData);
                            result = { data: normalizeCharacterData(parsed), source: 'local_direct' };
                            console.log(' Loaded from localStorage (direct)');
                        } catch (e) {
                            console.warn(' Corrupted localStorage save (boxingManager_character):', e);
                        }
                    }

                    //    /   backup
                    if (!result.data) {
                        const backupData = localStorage.getItem('boxingManager_character_backup');
                        if (backupData) {
                            try {
                                const parsedBackup = JSON.parse(backupData);
                                result = { data: normalizeCharacterData(parsedBackup), source: 'local_backup' };
                                console.log(' Loaded from localStorage (backup)');
                            } catch (e) {
                                console.warn(' Corrupted backup save (boxingManager_character_backup):', e);
                            }
                        }
                    }
                }

if (result.data) {
                    console.log(` Game loaded from ${result.source}`);
                    console.log(' Data structure:', {
                        hasFighters: !!(result.data.fighters),
                        fightersLength: result.data.fighters?.length,
                        fightersData: result.data.fighters
                    });
                    
                    //   localStorage  sync 
                    try { localStorage.setItem('boxingManager_character', JSON.stringify(result.data)); } catch (e) { console.error(' LocalStorage cache write failed:', e); }
                    
                    //     ( )
                    if (result.data.fighters && result.data.fighters.length > 0) {
                        console.log(' Returning player - loading game...');
                        
                        // Cancel intro sequence for returning players
                        cancelIntroSequence();
                        
                        //   '   (   )
                        if (result.data.name) {
                            console.log(' Setting manager name IMMEDIATELY:', result.data.name);
                            //  setTimeout(0)    DOM 
                            setTimeout(() => {
                                const nameElement = document.getElementById('managerName');
                                if (nameElement) {
                                    nameElement.textContent = result.data.name;
                                    console.log(' Manager name set:', result.data.name);
                                } else {
                                    console.error(' managerName element not found!');
                                }
                            }, 0);
                        }
                        
                        //   
                        showScreen('gameScreen');
                        
                        //    (async)
                        await loadGameData();
                        
                        // Welcome message  -   
                        //    :
                        // setTimeout(() => {
                        //     const telegramUser = tg.initDataUnsafe?.user;
                        //     const userName = telegramUser ? telegramUser.first_name : result.data.name;
                        //     showToast(`  , ${userName}!`, '', 'success');
                        // }, 1000);
                    } else {
                        console.log(' Player data exists but no fighters - showing intro...');
                        console.log('   fighters:', result.data.fighters);
                        //  ,    -  
                        startIntroSequence(); // Start intro for incomplete registration
                    }
                } else {
                    console.log(' No saved data found - new game');
                    //    -  
                    startIntroSequence(); // Start intro for new players
                }
                
                // Update Cloud status
                updateCloudStatus();
                
            } catch (error) {
                console.error('Initialization error:', error);
                
                // Fallback:  localStorage  
                try {
                    const localData = localStorage.getItem('boxingManager_character');
                    if (localData) {
                        const data = normalizeCharacterData(JSON.parse(localData));
                        if (data.fighters && data.fighters.length > 0) {
                            console.log(' Error but found localStorage - loading...');
                            cancelIntroSequence(); // Cancel intro
                            
                            //  ' 
                            if (data.name) {
                                setTimeout(() => {
                                    const nameElement = document.getElementById('managerName');
                                    if (nameElement) {
                                        nameElement.textContent = data.name;
                                        console.log(' Manager name set (fallback):', data.name);
                                    }
                                }, 0);
                            }
                            
                            showScreen('gameScreen'); //  
                            await loadGameData(); //  
                            return;
                        }
                    }
                } catch (e) {
                    console.error('Fallback error:', e);
                }
                
                showToast(' ', '   ', 'warning');

                //        .
                //       .
                try {
                    showScreen('loadingScreen');
                    const loadingText = document.querySelector('#loadingScreen .loading-text');
                    if (loadingText) {
                        loadingText.textContent = ' . ,    .';
                    }
                    const loadingContent = document.querySelector('#loadingScreen .loading-content');
                    if (loadingContent && !loadingContent.dataset.retryBound) {
                        loadingContent.dataset.retryBound = '1';
                        loadingContent.style.cursor = 'pointer';
                        loadingContent.addEventListener('click', () => window.location.reload());
                    }
                } catch (e) {
                    console.error('Failed to show load error UI:', e);
                }
}
        })();
    
</script>

    <!-- TRAINING SCREEN -->
    <div id="trainingScreen" class="screen">
        <div class="game-header">
            <div class="header-top">
                <div class="fighter-name-display"> </div>
            </div>
        </div>
        <div class="game-content">
            <div class="main-actions">
                <div class="action-card" onclick="train('power')">
                    <span class="action-icon"></span>
                    <div class="action-title"></div>
                    <div class="action-desc">+2-5   200</div>
                </div>
                <div class="action-card" onclick="train('speed')">
                    <span class="action-icon"></span>
                    <div class="action-title"></div>
                    <div class="action-desc">+2-5   200</div>
                </div>
                <div class="action-card" onclick="train('stamina')">
                    <span class="action-icon"></span>
                    <div class="action-title"></div>
                    <div class="action-desc">+2-5   200</div>
                </div>
                <div class="action-card" onclick="train('defense')">
                    <span class="action-icon"></span>
                    <div class="action-title"></div>
                    <div class="action-desc">+2-5   200</div>
                </div>
            </div>
            <div class="info-section">
                <div class="info-title">  </div>
                <div class="info-grid" id="trainingStatsGrid">
                    <div class="info-item">
                        <span class="info-item-label"> </span>
                        <span class="info-item-value" id="trainPowerDisplay"></span>
                    </div>
                    <div class="info-item">
                        <span class="info-item-label"> </span>
                        <span class="info-item-value" id="trainSpeedDisplay"></span>
                    </div>
                    <div class="info-item">
                        <span class="info-item-label"> </span>
                        <span class="info-item-value" id="trainStaminaDisplay"></span>
                    </div>
                    <div class="info-item">
                        <span class="info-item-label"> </span>
                        <span class="info-item-value" id="trainDefenseDisplay"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- VIP SCREEN -->
    <div id="vipScreen" class="screen">
        <div class="game-header">
            <div class="header-top">
                <div class="fighter-name-display"> VIP </div>
            </div>
            <div class="header-stats">
                <div class="header-stat" style="grid-column: span 3;">
                    <span class="header-stat-label"></span>
                    <span class="header-stat-value" id="vipCurrentStatus"> VIP</span>
                </div>
            </div>
        </div>
        <div class="game-content">
            <div class="info-section" id="vipBronze" style="border-color: #CD7F32;">
                <div class="info-title" style="color: #CD7F32;">    10</div>
                <div style="opacity: 0.8; margin-bottom: 1rem; font-size: 0.9rem;">
                     +10%    <br>
                     +5%  
                </div>
                <button class="start-button" onclick="purchaseVIP('bronze')" style="padding: 0.7rem;"></button>
            </div>
            <div class="info-section" id="vipSilver" style="border-color: #C0C0C0;">
                <div class="info-title" style="color: #C0C0C0;">    25</div>
                <div style="opacity: 0.8; margin-bottom: 1rem; font-size: 0.9rem;">
                     +20%    <br>
                     +10%  <br>
                        (x1.5)
                </div>
                <button class="start-button" onclick="purchaseVIP('silver')" style="padding: 0.7rem;"></button>
            </div>
            <div class="info-section" id="vipGold" style="border-color: #FFD700;">
                <div class="info-title" style="color: #FFD700;">    50</div>
                <div style="opacity: 0.8; margin-bottom: 1rem; font-size: 0.9rem;">
                     +30%    <br>
                     +20%  <br>
                        (x2)
                </div>
                <button class="start-button" onclick="purchaseVIP('gold')" style="padding: 0.7rem;"></button>
            </div>
        </div>
    </div>

    <!-- ACADEMY SCREEN -->
    <div id="academyScreen" class="screen">
        <div class="game-header">
            <div class="header-top">
                <div class="fighter-name-display"> </div>
            </div>
        </div>
        <div class="game-content" id="academyContent">
            <!-- Generated dynamically -->
        </div>
    </div>

    <!-- RANDOM EVENT POPUP -->
    <div class="event-overlay" id="eventOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); justify-content: center; align-items: center; z-index: 10001; padding: 1rem;">
        <div class="event-modal" style="background: linear-gradient(135deg, #1a1a2e, #16213e); border: 2px solid var(--gold); padding: 2rem; max-width: 500px; width: 100%; border-radius: 16px; box-shadow: 0 0 50px rgba(255,215,0,0.3);">
            <div id="eventIcon" style="font-size: 4rem; text-align: center; margin-bottom: 1rem; filter: drop-shadow(0 0 20px rgba(255,215,0,0.5));"></div>
            <div id="eventTitle" style="font-size: 1.5rem; font-weight: 700; color: var(--gold); text-align: center; margin-bottom: 1rem;"></div>
            <div id="eventDescription" style="font-size: 1rem; color: rgba(255,255,255,0.9); text-align: center; line-height: 1.6; margin-bottom: 2rem; padding: 0 1rem;"></div>
            <div id="eventChoices" style="display: flex; flex-direction: column; gap: 1rem;"></div>
        </div>
    </div>

    <!-- DAILY REWARDS POPUP -->
    <div class="daily-rewards-overlay" id="dailyRewardsOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); justify-content: center; align-items: center; z-index: 10000;">
        <div style="background: var(--dark-bg); border: 2px solid var(--gold); padding: 2rem; max-width: 400px; width: 90%; border-radius: 8px; text-align: center;">
            <div style="font-size: 4rem; margin-bottom: 1rem;"></div>
            <div style="font-size: 1.5rem; font-weight: 700; color: var(--gold); margin-bottom: 1rem;"> !</div>
            <div id="dailyRewardAmount" style="font-size: 2.5rem; font-weight: 700; color: var(--gold); margin-bottom: 0.5rem;"> 500</div>
            <div style="opacity: 0.7; margin-bottom: 1.5rem;">    !</div>
            <button class="start-button" onclick="closeDailyRewards()"></button>
        </div>
    </div>

</body>
</html>