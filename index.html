<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Boxing Manager 0.20 Alpha - Red Marker</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Oswald:wght@300;400;600;700&display=swap');
        
        :root {
            --blood-red: #8B0000;
            --ring-red: #C41E3A;
            --gold: #FFD700;
            --dark-bg: #0a0a0a;
            --canvas-white: #F5F5DC;
            --rope-blue: #1E3A8A;
            --steel: #4A5568;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Oswald', sans-serif;
            background: var(--dark-bg);
            color: var(--canvas-white);
            overflow: hidden;
            height: 100vh;
            position: relative;
        }
        
        /* Noise texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0,0,0,.03) 2px,
                    rgba(0,0,0,.03) 4px
                );
            pointer-events: none;
            z-index: 1000;
            opacity: 0.3;
        }
        
        .screen {
            display: none;
            width: 100%;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .screen.active {
            display: flex;
            flex-direction: column;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* LOADING SCREEN */
        #loadingScreen {
            justify-content: center;
            align-items: center;
            background: var(--dark-bg);
        }
        
        .loading-content {
            text-align: center;
            position: relative;
            z-index: 2;
        }
        
        .game-logo {
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(2rem, 8vw, 3rem);
            letter-spacing: 0.2rem;
            margin-bottom: 1rem;
            text-transform: uppercase;
            color: var(--canvas-white);
        }
        
        .game-subtitle {
            font-size: clamp(0.8rem, 3vw, 1rem);
            letter-spacing: 0.3rem;
            color: var(--canvas-white);
            opacity: 0.5;
            font-weight: 300;
        }
        
        .loading-bar-container {
            width: min(250px, 80vw);
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            margin: 2.5rem auto 1rem;
            overflow: hidden;
            position: relative;
        }
        
        .loading-bar {
            height: 100%;
            background: var(--canvas-white);
            animation: loading 2s ease-in-out;
            width: 0%;
        }
        
        @keyframes loading {
            0% { width: 0%; }
            100% { width: 100%; }
        }
        
        .loading-text {
            font-size: clamp(0.8rem, 3vw, 0.9rem);
            opacity: 0.6;
            margin-top: 1rem;
            letter-spacing: 0.2rem;
        }
        
        /* PROLOGUE SCREEN */
        #prologueScreen {
            background: var(--dark-bg);
            padding: 1.5rem;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* Cinematic vignette effect */
        #prologueScreen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.7) 100%);
            pointer-events: none;
        }
        
        .prologue-content {
            max-width: 500px;
            text-align: center;
            position: relative;
            padding: 0 1rem;
            z-index: 1;
        }
        
        .prologue-text {
            font-size: clamp(1.1rem, 4vw, 1.5rem);
            line-height: 2;
            font-weight: 300;
            opacity: 1;
            text-align: center;
        }
        
        .prologue-line {
            opacity: 0;
            transform: translateY(10px);
            display: block;
            margin-bottom: 0.8rem;
        }
        
        .prologue-line.highlight {
            color: var(--gold);
            font-weight: 400;
        }
        
        .prologue-line.fade-in {
            animation: fadeInLine 1.2s ease-out forwards;
        }
        
        @keyframes fadeInLine {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .prologue-highlight {
            color: var(--gold);
            font-weight: 400;
        }
        
        .continue-button {
            margin-top: 2rem;
            padding: 0.9rem 2rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: var(--canvas-white);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            letter-spacing: 0.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        @keyframes fadeInButton {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .continue-button:active {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--gold);
        }
        
        /* CHARACTER CREATION SCREEN */
        #characterScreen {
            padding: 1.5rem;
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .character-header {
            text-align: center;
            margin-bottom: 2.5rem;
        }
        
        .character-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.8rem);
            font-weight: 300;
            letter-spacing: 0.1rem;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .character-subtitle {
            font-size: clamp(0.8rem, 3vw, 0.9rem);
            opacity: 0.5;
            letter-spacing: 0.05rem;
            font-weight: 300;
        }
        
        .form-container {
            max-width: 500px;
            margin: 0 auto;
        }
        
        .form-group {
            margin-bottom: 2rem;
        }
        
        .form-label {
            display: block;
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            letter-spacing: 0.05rem;
            color: var(--canvas-white);
            margin-bottom: 1rem;
            opacity: 0.7;
            font-weight: 300;
        }
        
        .form-input,
        .form-select {
            width: 100%;
            padding: 0.9rem 0.5rem;
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0;
            color: var(--canvas-white);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 4vw, 1.2rem);
            transition: all 0.3s ease;
        }
        
        .form-select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23F5F5DC' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            padding-right: 2rem;
        }
        
        .form-select option {
            background: var(--dark-bg);
            color: var(--canvas-white);
        }
        
        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-bottom-color: var(--gold);
        }
        
        .start-button {
            width: 100%;
            margin-top: 2.5rem;
            padding: 0.9rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: var(--canvas-white);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            letter-spacing: 0.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
        }
        
        .start-button:active:not(:disabled) {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--gold);
        }
        
        .start-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        /* Mobile optimizations for small screens */
        @media screen and (max-width: 375px) {
            .prologue-text {
                font-size: 1.1rem;
                line-height: 1.8;
                margin-bottom: 2rem;
            }
            
            .form-group {
                margin-bottom: 1.5rem;
            }
            
            .character-header {
                margin-bottom: 2rem;
            }
        }
        
        /* Ensure touch targets are large enough */
        @media (pointer: coarse) {
            .continue-button,
            .start-button {
                min-height: 44px;
            }
        }
        
        /* STREET WALK TRANSITION SCREEN */
        #streetWalkScreen {
            background: var(--dark-bg);
            padding: 1.5rem;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* Cinematic vignette */
        #streetWalkScreen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.7) 100%);
            pointer-events: none;
        }
        
        .street-walk-content {
            max-width: 500px;
            text-align: center;
            position: relative;
            padding: 0 1rem;
            z-index: 1;
        }
        
        .street-walk-text {
            font-size: clamp(1.1rem, 4vw, 1.4rem);
            line-height: 2;
            font-weight: 300;
            opacity: 1;
            text-align: center;
        }
        
        .street-walk-line {
            opacity: 0;
            transform: translateY(10px);
            display: block;
            margin-bottom: 0.8rem;
        }
        
        .street-walk-line.highlight {
            color: var(--gold);
            font-weight: 400;
        }
        
        .street-walk-line.fade-in {
            animation: fadeInLine 1.2s ease-out forwards;
        }
        
        /* STREET TOURNAMENT SCREEN */
        #streetScreen {
            background: var(--dark-bg);
            padding: 1.5rem;
            overflow-y: auto;
        }
        
        .street-header {
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .street-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 2rem);
            font-weight: 300;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .street-subtitle {
            font-size: clamp(0.85rem, 3vw, 1rem);
            opacity: 0.6;
            line-height: 1.6;
            font-weight: 300;
        }
        
        .fighters-grid {
            display: grid;
            gap: 1.5rem;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .fighter-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .fighter-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .fighter-card:active::before {
            opacity: 1;
        }
        
        .fighter-card:active {
            border-color: var(--gold);
            transform: scale(0.98);
        }
        
        .fighter-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1.2rem;
        }
        
        .fighter-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 4.5vw, 1.6rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
        }
        
        .fighter-nickname {
            font-size: clamp(0.85rem, 3vw, 0.95rem);
            opacity: 0.5;
            font-style: italic;
        }
        
        .talent-badge {
            background: linear-gradient(135deg, var(--gold), #FFA500);
            color: var(--dark-bg);
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            box-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
        }
        
        .fighter-basics {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1.2rem;
            font-size: clamp(0.85rem, 3vw, 0.95rem);
            opacity: 0.7;
        }
        
        .fighter-basics span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .fighter-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.8rem;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
        }
        
        .stat-label {
            opacity: 0.6;
            font-weight: 300;
        }
        
        .stat-value {
            font-weight: 400;
            color: var(--canvas-white);
        }
        
        .stat-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.3rem;
        }
        
        .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--gold), #FFA500);
            transition: width 0.5s ease;
        }
        
        .talent-description {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            font-size: clamp(0.8rem, 2.8vw, 0.85rem);
            opacity: 0.5;
            line-height: 1.5;
        }
        
        .talent-bonus {
            color: var(--gold);
            font-weight: 400;
        }
        
        /* CONFIRMATION MODAL */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 1.5rem;
        }
        
        .modal-overlay.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }
        
        .modal-content {
            background: var(--dark-bg);
            border: 1px solid var(--gold);
            border-radius: 8px;
            padding: 2rem 1.5rem;
            max-width: 400px;
            width: 100%;
            text-align: center;
            animation: slideUp 0.3s ease;
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .modal-fighter-avatar {
            font-size: 4rem;
            margin-bottom: 1rem;
        }
        
        .modal-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.4rem, 5vw, 1.8rem);
            color: var(--gold);
            margin-bottom: 0.5rem;
        }
        
        .modal-subtitle {
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            opacity: 0.7;
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .modal-buttons {
            display: flex;
            gap: 1rem;
        }
        
        .modal-button {
            flex: 1;
            padding: 0.9rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: var(--canvas-white);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            letter-spacing: 0.05rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
        }
        
        .modal-button.confirm {
            border-color: var(--gold);
            color: var(--gold);
        }
        
        .modal-button:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.05);
        }
        
        .modal-button.confirm:active {
            background: rgba(255, 215, 0, 0.1);
        }
        
        /* TACTICS MODAL */
        .tactics-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 1rem;
        }
        
        .tactics-modal-overlay.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }
        
        .tactics-modal-content {
            background: var(--dark-bg);
            border: 2px solid var(--gold);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease;
        }
        
        .tactics-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }
        
        .tactics-title {
            font-family: 'Oswald', sans-serif;
            font-size: 1.8rem;
            color: var(--gold);
            margin-bottom: 0.5rem;
        }
        
        .tactics-subtitle {
            font-size: 0.9rem;
            opacity: 0.7;
        }
        
        .tactics-grid {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .tactic-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tactic-card:hover {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.1);
            transform: translateY(-2px);
        }
        
        .tactic-card.selected {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.15);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        .tactic-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        
        .tactic-icon {
            font-size: 2rem;
        }
        
        .tactic-name {
            font-family: 'Oswald', sans-serif;
            font-size: 1.3rem;
            color: var(--gold);
        }
        
        .tactic-description {
            font-size: 0.85rem;
            opacity: 0.7;
            margin-bottom: 0.75rem;
            line-height: 1.5;
        }
        
        .tactic-effects {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .tactic-effect {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.6rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 0.75rem;
            white-space: nowrap;
        }
        
        .tactic-effect.positive {
            color: #4ade80;
        }
        
        .tactic-effect.negative {
            color: #ef4444;
        }
        
        .tactics-confirm-btn {
            width: 100%;
            padding: 1rem;
            background: var(--gold);
            color: var(--dark-bg);
            border: none;
            border-radius: 8px;
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tactics-confirm-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        .tactics-confirm-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .fighter-avatar {
            font-size: 3rem;
            text-align: center;
            margin-bottom: 1rem;
        }
        
        /* MAIN GAME SCREEN */
        #gameScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        /* Manager Profile Section */
        .manager-profile {
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem;
            flex-shrink: 0;
        }
        
        .manager-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.8rem;
        }
        
        .vip-star-container {
            position: relative;
            flex-shrink: 0;
        }
        
        .vip-star {
            position: absolute;
            top: -5px;
            left: -5px;
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            filter: grayscale(100%) brightness(0.5);
            opacity: 0.5;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .vip-star.active {
            filter: grayscale(0%) brightness(1);
            opacity: 1;
            animation: vipPulse 2s ease-in-out infinite;
        }
        
        @keyframes vipPulse {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
            }
            50% { 
                transform: scale(1.1) rotate(10deg);
            }
        }
        
        .manager-avatar {
            font-size: clamp(2.5rem, 8vw, 3rem);
            width: clamp(60px, 15vw, 70px);
            height: clamp(60px, 15vw, 70px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 50%;
        }
        
        .vip-status {
            font-size: clamp(0.75rem, 2.8vw, 0.8rem);
            opacity: 0.7;
            margin-top: 0.2rem;
            color: var(--gold);
        }
        
        .vip-quick-btn {
            padding: 0.6rem 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.85rem, 3vw, 0.95rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .vip-quick-btn:active {
            transform: scale(0.95);
        }
        
        .manager-info {
            flex: 1;
        }
        
        .manager-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.6rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .vip-badge {
            background: linear-gradient(135deg, var(--gold), #FFA500);
            color: var(--dark-bg);
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: clamp(0.7rem, 2.5vw, 0.8rem);
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
        }
        
        .manager-details {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
            display: flex;
            gap: 0.8rem;
            flex-wrap: wrap;
        }
        
        .manager-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.6rem;
        }
        
        .manager-stat-box {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 0.6rem;
            text-align: center;
        }
        
        .manager-stat-label {
            font-size: clamp(0.7rem, 2.5vw, 0.75rem);
            opacity: 0.5;
            margin-bottom: 0.2rem;
        }
        
        .manager-stat-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.8vw, 1.2rem);
            color: var(--gold);
            font-weight: 400;
        }
        
        .manager-stat-box.clickable {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .manager-stat-box.clickable:active {
            transform: scale(0.95);
            background: rgba(255, 215, 0, 0.1);
        }
        
        /* Fighter Card (compact) */
        .fighter-card-main {
            margin: 1rem;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
        }
        
        .fighter-card-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .fighter-card-avatar {
            font-size: clamp(2rem, 7vw, 2.5rem);
            width: clamp(50px, 12vw, 60px);
            height: clamp(50px, 12vw, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.2);
            border-radius: 50%;
        }
        
        .fighter-card-info {
            flex: 1;
        }
        
        .fighter-card-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.2rem;
        }
        
        .fighter-card-stats {
            font-size: clamp(0.8rem, 3vw, 0.85rem);
            opacity: 0.6;
            display: flex;
            gap: 0.8rem;
        }
        
        .fighter-quick-stats {
            display: flex;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .fighter-quick-stat {
            flex: 1;
            text-align: center;
        }
        
        .fighter-quick-stat-label {
            font-size: clamp(0.75rem, 2.5vw, 0.8rem);
            opacity: 0.5;
            margin-bottom: 0.2rem;
        }
        
        .fighter-quick-stat-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            color: var(--canvas-white);
        }
        
        .fighter-next-fight {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 6px;
            padding: 0.6rem;
            text-align: center;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            margin-bottom: 1rem;
        }
        
        .fighter-card-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.6rem;
        }
        
        .fighter-card-btn {
            padding: 0.7rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--canvas-white);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3vw, 0.95rem);
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px;
        }
        
        .fighter-card-btn.primary {
            border-color: var(--gold);
            color: var(--gold);
        }
        
        .fighter-card-btn:active {
            transform: scale(0.97);
            background: rgba(255, 255, 255, 0.05);
        }
        
        /* Main Content */
        /* TOP RESOURCE BAR */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, var(--dark-bg) 0%, rgba(10, 10, 10, 0.95) 100%);
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
            padding: 0.8rem 1rem;
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        /* SCROLLABLE CONTENT */
        .game-scroll-content {
            flex: 1;
            overflow-y: auto;
            padding-top: 60px;
            padding-bottom: 80px;
        }
        
        /* BOTTOM NAVIGATION */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(0deg, var(--dark-bg) 0%, rgba(10, 10, 10, 0.95) 100%);
            border-top: 1px solid rgba(255, 215, 0, 0.2);
            padding: 0.5rem 0.5rem calc(env(safe-area-inset-bottom) + 0.5rem);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            padding: 0.4rem 0.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 8px;
            position: relative;
            min-width: 0;
        }
        
        .nav-item:active {
            background: rgba(255, 215, 0, 0.1);
            transform: scale(0.95);
        }
        
        .nav-icon {
            font-size: clamp(1.3rem, 4.5vw, 1.6rem);
            filter: grayscale(0.3);
            transition: all 0.2s ease;
        }
        
        .nav-item:active .nav-icon {
            filter: grayscale(0);
            transform: scale(1.1);
        }
        
        .nav-label {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.6rem, 2.2vw, 0.7rem);
            color: var(--canvas-white);
            opacity: 0.8;
            letter-spacing: 0.02rem;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }
        
        .nav-badge {
            position: absolute;
            top: 0.3rem;
            right: 0.5rem;
            background: #ef4444;
            color: white;
            font-size: 0.6rem;
            font-weight: 600;
            padding: 0.15rem 0.4rem;
            border-radius: 10px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        .resource-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .resource-icon {
            font-size: clamp(1.2rem, 4vw, 1.4rem);
        }
        
        .resource-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            color: var(--canvas-white);
            font-weight: 400;
        }
        
        /* TRAINING SCREEN */
        #trainingScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .training-header {
            padding: 1rem;
            padding-left: 1rem;
            padding-right: 1rem;
            margin-top: 50px;  /* Відступ зверху для кнопки назад */
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
            text-align: center;  /* Центруємо текст */
        }
        
        .training-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .training-subtitle {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
        }
        
        .training-content {
            padding: 1rem;
        }
        
        .training-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1.2rem;
            margin-bottom: 1rem;
        }
        
        .training-card.active {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.05);
        }
        
        .training-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .training-stat-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            font-weight: 400;
            color: var(--canvas-white);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .training-stat-icon {
            font-size: clamp(1.5rem, 5vw, 1.8rem);
        }
        
        .training-stat-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            color: var(--gold);
        }
        
        .training-progress {
            margin-bottom: 1rem;
        }
        
        .training-progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        
        .training-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--gold), #FFA500);
            transition: width 0.3s ease;
        }
        
        .training-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.6rem;
            margin-bottom: 1rem;
        }
        
        .training-option {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 0.8rem 0.4rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .training-option.selected {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.1);
        }
        
        .training-option:active {
            transform: scale(0.95);
        }
        
        .training-option-time {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            color: var(--canvas-white);
            margin-bottom: 0.2rem;
        }
        
        .training-option-cost {
            font-size: clamp(0.75rem, 2.8vw, 0.8rem);
            opacity: 0.6;
        }
        
        .training-option-reward {
            font-size: clamp(0.7rem, 2.5vw, 0.75rem);
            color: var(--gold);
            margin-top: 0.2rem;
        }
        
        .training-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            letter-spacing: 0.05rem;
        }
        
        .training-button:active {
            transform: scale(0.98);
        }
        
        .training-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .training-timer {
            text-align: center;
            padding: 1.5rem;
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        
        .training-timer-label {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        
        .training-timer-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(2rem, 7vw, 2.5rem);
            color: var(--gold);
            font-weight: 400;
            margin-bottom: 1rem;
        }
        
        .training-boost-button {
            padding: 0.8rem 1.5rem;
            background: transparent;
            border: 1px solid var(--gold);
            color: var(--gold);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3vw, 1rem);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .training-boost-button:active {
            background: rgba(255, 215, 0, 0.1);
        }
        
        .back-button {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--canvas-white);
            font-size: 1.5rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .back-button:active {
            background: rgba(255, 255, 255, 0.05);
            transform: scale(0.95);
        }
        
        /* FIGHTS SCREEN */
        #fightsScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .fights-header {
            padding: 1rem;
            margin-top: 50px;  /* Відступ зверху для кнопки назад */
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
            text-align: center;  /* Центруємо текст */
        }
        
        .fights-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .fights-subtitle {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
        }
        
        .fights-cooldown {
            margin: 1rem;
            padding: 1rem;
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            text-align: center;
        }
        
        .cooldown-text {
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            opacity: 0.8;
            margin-bottom: 0.5rem;
        }
        
        .cooldown-timer {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            color: var(--gold);
            margin-bottom: 0.8rem;
        }
        
        .cooldown-skip-btn {
            padding: 0.7rem 1.5rem;
            background: transparent;
            border: 1px solid var(--gold);
            color: var(--gold);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3vw, 1rem);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .cooldown-skip-btn:active {
            background: rgba(255, 215, 0, 0.1);
        }
        
        .fights-content {
            padding: 1rem;
        }
        
        .opponent-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1.2rem;
            margin-bottom: 1rem;
        }
        
        .opponent-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .opponent-avatar {
            font-size: clamp(2rem, 7vw, 2.5rem);
            width: clamp(50px, 12vw, 60px);
            height: clamp(50px, 12vw, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.2);
            border-radius: 50%;
        }
        
        .opponent-info {
            flex: 1;
        }
        
        .opponent-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
        }
        
        .opponent-details {
            font-size: clamp(0.8rem, 3vw, 0.85rem);
            opacity: 0.6;
            display: flex;
            gap: 0.8rem;
        }
        
        .opponent-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .opponent-stat {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 0.6rem;
        }
        
        .opponent-stat-label {
            font-size: clamp(0.75rem, 2.5vw, 0.8rem);
            opacity: 0.5;
            margin-bottom: 0.2rem;
        }
        
        .opponent-stat-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            color: var(--canvas-white);
        }
        
        .opponent-stat-value.positive {
            color: #4ade80;
        }
        
        .opponent-stat-value.negative {
            color: #f87171;
        }
        
        .difficulty-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 12px;
            font-size: clamp(0.75rem, 2.5vw, 0.8rem);
            font-weight: 600;
            margin-bottom: 0.8rem;
        }
        
        .difficulty-easy {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid #4ade80;
        }
        
        .difficulty-medium {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid #fbbf24;
        }
        
        .difficulty-hard {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            border: 1px solid #f87171;
        }
        
        .opponent-rewards {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 6px;
            padding: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .rewards-label {
            font-size: clamp(0.75rem, 2.5vw, 0.8rem);
            opacity: 0.6;
            margin-bottom: 0.4rem;
        }
        
        .rewards-values {
            display: flex;
            gap: 1rem;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
        }
        
        .fight-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            letter-spacing: 0.05rem;
        }
        
        .fight-button:active {
            transform: scale(0.98);
        }
        
        /* FIGHT SIMULATION SCREEN */
        #fightSimScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .fight-sim-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
            text-align: center;
        }
        
        .fight-sim-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.6rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .fight-sim-round {
            font-size: clamp(0.9rem, 3vw, 1rem);
            opacity: 0.6;
        }
        
        .fight-sim-content {
            padding: 1rem;
        }
        
        .fighters-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            gap: 1rem;
        }
        
        .fighter-display {
            flex: 1;
            text-align: center;
        }
        
        .fighter-display-avatar {
            font-size: clamp(2.5rem, 8vw, 3rem);
            margin-bottom: 0.5rem;
        }
        
        .fighter-display-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .fighter-health-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .fighter-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 0.5s ease;
        }
        
        .fighter-health-fill.low {
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
        }
        
        .fighter-health-fill.critical {
            background: linear-gradient(90deg, #f87171, #ef4444);
        }
        
        .vs-text {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 2rem);
            color: var(--gold);
            font-weight: 600;
        }
        
        .fight-log {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 1rem;
        }
        
        .fight-log-entry {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            line-height: 1.5;
            opacity: 0.8;
            animation: slideInLog 0.3s ease;
            border-radius: 4px;
        }
        
        @keyframes slideInLog {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 0.8;
                transform: translateX(0);
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        .fight-log-entry.player {
            color: #4ade80;
            background: rgba(74, 222, 128, 0.05);
            border-left: 3px solid #4ade80;
        }
        
        .fight-log-entry.opponent {
            color: #f87171;
            background: rgba(248, 113, 113, 0.05);
            border-left: 3px solid #f87171;
        }
        
        .fight-log-entry.neutral {
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
        }
        
        .fight-result {
            text-align: center;
            padding: 2rem 1rem;
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        
        .result-icon {
            font-size: clamp(3rem, 10vw, 4rem);
            margin-bottom: 1rem;
        }
        
        .result-text {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 2rem);
            font-weight: 400;
            color: var(--gold);
            margin-bottom: 1rem;
        }
        
        /* NEW IMPROVED RESULT STYLES */
        #fightResultDisplay {
            display: none;
            width: 100%;
            min-height: 100vh;
            padding: 2rem;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: var(--dark-bg);
            text-align: center;
        }
        
        #fightResultDisplay.show {
            display: block !important;
        }
        
        .result-icon {
            font-size: clamp(5rem, 15vw, 8rem);
            margin: 2rem 0;
            animation: resultBounce 0.6s ease-out;
        }
        
        @keyframes resultBounce {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .result-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(2rem, 8vw, 3rem);
            font-weight: 700;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 1rem 0;
            text-transform: uppercase;
        }
        
        .result-subtitle {
            font-size: clamp(1rem, 4vw, 1.3rem);
            opacity: 0.7;
            margin: 1rem 0 2rem;
        }
        
        .result-rewards {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }
        
        .reward-item {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #FFD700;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 5vw, 1.5rem);
            font-weight: 600;
            color: var(--gold);
        }
        
        .continue-btn {
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            padding: clamp(1rem, 4vw, 1.5rem) clamp(2rem, 8vw, 3rem);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4.5vw, 1.4rem);
            font-weight: 700;
            letter-spacing: 0.05em;
            color: var(--dark-bg);
            border-radius: 12px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.3);
            margin-top: 2rem;
            transition: all 0.3s ease;
        }
        
        .continue-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.5);
        }
        
        .continue-btn:active {
            transform: translateY(0);
        }
        
        .result-content {
            text-align: center;
            padding: 2rem;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .result-icon-large {
            font-size: clamp(5rem, 15vw, 8rem);
            margin-bottom: 1rem;
            animation: resultBounce 0.6s ease-out;
        }
        
        @keyframes resultBounce {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        
        .result-title-large {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(2rem, 8vw, 3.5rem);
            font-weight: 700;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        
        .result-subtitle {
            font-size: clamp(1rem, 4vw, 1.3rem);
            opacity: 0.7;
            margin-bottom: 2rem;
        }
        
        .result-rewards {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin: 2rem 0;
        }
        
        .result-reward-item {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 5vw, 1.8rem);
            font-weight: 600;
            color: var(--gold);
            animation: rewardPulse 0.8s ease-out;
        }
        
        @keyframes rewardPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .result-button-large {
            width: 100%;
            max-width: 400px;
            padding: 1.2rem 2rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4.5vw, 1.4rem);
            font-weight: 700;
            letter-spacing: 0.05em;
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.3);
            margin-top: 2rem;
        }
        
        .result-button-large:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.5);
        }
        
        .result-button-large:active {
            transform: translateY(0);
        }
        
        .result-rewards {
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            opacity: 0.8;
        }
        
        .continue-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .continue-button:active {
            transform: scale(0.98);
        }
        
        /* VIP SCREEN */
        #vipScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .vip-header {
            padding: 1.5rem;
            margin-top: 50px;  /* Відступ для кнопки назад */
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.1) 0%, transparent 100%);
            text-align: center;
        }
        
        .vip-icon {
            font-size: clamp(3rem, 10vw, 4rem);
            margin-bottom: 0.5rem;
        }
        
        .vip-header-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.8rem, 6vw, 2.2rem);
            font-weight: 600;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }
        
        .vip-header-subtitle {
            font-size: clamp(0.9rem, 3vw, 1rem);
            opacity: 0.7;
        }
        
        .vip-content {
            padding: 1rem;
        }
        
        .vip-status-card {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 1.2rem;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .vip-status-active {
            border-color: var(--gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 165, 0, 0.05));
        }
        
        .vip-status-label {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        
        .vip-status-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.6rem);
            color: var(--gold);
            font-weight: 600;
            margin-bottom: 0.3rem;
        }
        
        .vip-timer {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            color: var(--canvas-white);
            opacity: 0.8;
        }
        
        .vip-benefits {
            margin-bottom: 1.5rem;
        }
        
        .vip-benefits-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            color: var(--canvas-white);
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .vip-benefit-item {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.8rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .vip-benefit-icon {
            font-size: clamp(1.8rem, 6vw, 2.2rem);
            width: clamp(50px, 12vw, 60px);
            height: clamp(50px, 12vw, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .vip-benefit-text {
            flex: 1;
        }
        
        .vip-benefit-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            color: var(--gold);
            margin-bottom: 0.2rem;
        }
        
        .vip-benefit-desc {
            font-size: clamp(0.8rem, 3vw, 0.85rem);
            opacity: 0.6;
        }
        
        .vip-packages {
            margin-bottom: 1.5rem;
        }
        
        .vip-packages-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            color: var(--canvas-white);
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .vip-package {
            background: rgba(255, 255, 255, 0.02);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 1.2rem;
            margin-bottom: 1rem;
            position: relative;
        }
        
        .vip-package.recommended {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.05);
        }
        
        .vip-package-badge {
            position: absolute;
            top: -10px;
            right: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            color: var(--dark-bg);
            padding: 0.3rem 0.8rem;
            border-radius: 12px;
            font-size: clamp(0.7rem, 2.5vw, 0.75rem);
            font-weight: 600;
        }
        
        .vip-package-duration {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.4rem, 5vw, 1.6rem);
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
            text-align: center;
        }
        
        .vip-package-price {
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            color: var(--gold);
            text-align: center;
            margin-bottom: 0.5rem;
        }
        
        .vip-package-save {
            font-size: clamp(0.8rem, 3vw, 0.85rem);
            color: #4ade80;
            text-align: center;
            margin-bottom: 1rem;
        }
        
        .vip-buy-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            letter-spacing: 0.05rem;
        }
        
        .vip-buy-button:active {
            transform: scale(0.98);
        }
        
        .vip-buy-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .vip-note {
            text-align: center;
            font-size: clamp(0.8rem, 2.8vw, 0.85rem);
            opacity: 0.5;
            margin-top: 1rem;
            line-height: 1.5;
        }
        
        /* FIGHTERS MANAGEMENT */
        .fighters-list {
            margin: 1rem;
        }
        
        .fighter-slot {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .fighter-slot.active {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.05);
        }
        
        .fighter-slot.locked {
            cursor: pointer;
            opacity: 1;
        }
        
        .slot-locked-content {
            text-align: center;
            padding: 1rem;
        }
        
        .slot-locked-content.collapsed {
            padding: 0.8rem 1rem;
        }
        
        .slot-locked-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }
        
        .slot-locked-header-left {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            flex: 1;
        }
        
        .slot-locked-icon {
            font-size: clamp(1.8rem, 6vw, 2.2rem);
        }
        
        .slot-locked-content.collapsed .slot-locked-icon {
            font-size: clamp(1.5rem, 5vw, 1.8rem);
        }
        
        .slot-locked-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 4vw, 1.2rem);
            color: var(--canvas-white);
        }
        
        .slot-locked-content.collapsed .slot-locked-title {
            font-size: clamp(0.95rem, 3.5vw, 1.1rem);
        }
        
        .slot-expand-icon {
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            opacity: 0.6;
            transition: transform 0.3s ease;
        }
        
        .slot-expand-icon.expanded {
            transform: rotate(180deg);
        }
        
        .slot-locked-details {
            margin-top: 1rem;
            display: none;
        }
        
        .slot-locked-details.expanded {
            display: block;
        }
        
        .slot-locked-desc {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        
        .slot-unlock-button {
            padding: 0.9rem 1.5rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.95rem, 3.5vw, 1.05rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .slot-unlock-button:active {
            transform: scale(0.98);
        }
        
        /* ACADEMY SCREEN */
        #academyScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .academy-header {
            padding: 1rem;
            padding-left: 1rem;
            padding-right: 1rem;
            margin-top: 50px;  /* Відступ зверху для кнопки назад */
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
            text-align: center;  /* Центруємо текст */
        }
        
        .academy-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .academy-subtitle {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
        }
        
        .academy-content {
            padding: 1rem;
        }
        
        .academy-tab {
            flex: 1;
            padding: 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: white;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .academy-tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .academy-tab.active {
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border-color: var(--gold);
            color: var(--dark-bg);
            font-weight: 700;
        }
        
        .academy-timer-card {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .academy-timer-label {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        
        .academy-timer-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.6rem);
            color: var(--gold);
            margin-bottom: 1rem;
        }
        
        .academy-refresh-button {
            padding: 0.8rem 1.5rem;
            background: transparent;
            border: 1px solid var(--gold);
            color: var(--gold);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3vw, 1rem);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .academy-refresh-button:active {
            background: rgba(255, 215, 0, 0.1);
        }
        
        .academy-candidates {
            margin-top: 1rem;
        }
        
        .academy-candidates-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            color: var(--canvas-white);
            margin-bottom: 1rem;
        }
        
        .candidate-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1.2rem;
            margin-bottom: 1rem;
        }
        
        .candidate-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }
        
        .candidate-avatar {
            font-size: clamp(2rem, 7vw, 2.5rem);
            width: clamp(50px, 12vw, 60px);
            height: clamp(50px, 12vw, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.2);
            border-radius: 50%;
        }
        
        .candidate-info {
            flex: 1;
        }
        
        .candidate-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            font-weight: 400;
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
        }
        
        .candidate-details {
            font-size: clamp(0.8rem, 3vw, 0.85rem);
            opacity: 0.6;
        }
        
        .candidate-talent-badge {
            background: linear-gradient(135deg, var(--gold), #FFA500);
            color: var(--dark-bg);
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .candidate-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.6rem;
            margin-bottom: 1rem;
        }
        
        .candidate-stat {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 0.5rem;
        }
        
        .candidate-stat-label {
            font-size: clamp(0.75rem, 2.5vw, 0.8rem);
            opacity: 0.5;
            margin-bottom: 0.2rem;
        }
        
        .candidate-stat-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.95rem, 3.5vw, 1.05rem);
            color: var(--canvas-white);
        }
        
        .candidate-price {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 6px;
            padding: 0.8rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .candidate-price-label {
            font-size: clamp(0.75rem, 2.5vw, 0.8rem);
            opacity: 0.6;
            margin-bottom: 0.3rem;
        }
        
        .candidate-price-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            color: var(--gold);
        }
        
        .candidate-hire-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 3.5vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .candidate-hire-button:active {
            transform: scale(0.98);
        }
        
        .candidate-hire-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* TOAST NOTIFICATIONS */
        .toast-container {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            pointer-events: none;
            max-width: 90%;
            width: 400px;
        }
        
        .toast {
            background: var(--dark-bg);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 1rem 1.2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            gap: 0.8rem;
            animation: slideInDown 0.3s ease, fadeOut 0.3s ease 2.7s;
            pointer-events: auto;
        }
        
        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateY(-10px);
            }
        }
        
        .toast-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }
        
        .toast-content {
            flex: 1;
        }
        
        .toast-title {
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            color: var(--canvas-white);
            margin-bottom: 0.2rem;
        }
        
        .toast-message {
            font-size: 0.85rem;
            opacity: 0.8;
            line-height: 1.4;
        }
        
        .toast.success {
            border-color: #4ade80;
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.1), rgba(10, 10, 10, 0.95));
        }
        
        .toast.error {
            border-color: #ef4444;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(10, 10, 10, 0.95));
        }
        
        .toast.info {
            border-color: #3b82f6;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(10, 10, 10, 0.95));
        }
        
        .toast.warning {
            border-color: #f59e0b;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(10, 10, 10, 0.95));
        }
        
        /* LOADING OVERLAY */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 10, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2500;
            backdrop-filter: blur(5px);
        }
        
        .loading-overlay.active {
            display: flex;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 215, 0, 0.2);
            border-top-color: var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* SMOOTH SCREEN TRANSITIONS */
        .screen {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .screen:not(.active) {
            opacity: 0;
            transform: scale(0.98);
            pointer-events: none;
        }
        
        .screen.active {
            opacity: 1;
            transform: scale(1);
        }
        
        /* BUTTON PRESS EFFECTS */
        .nav-item:active,
        .action-card:active,
        .fighter-slot:active,
        button:active {
            transform: scale(0.95);
        }
        
        /* PULSE ANIMATION for important elements */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }
        
        /* FIGHTER STATS SCREEN */
        #fighterStatsScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .stats-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
        }
        
        .stats-fighter-card {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .stats-fighter-avatar {
            font-size: clamp(3rem, 10vw, 4rem);
            width: clamp(80px, 20vw, 100px);
            height: clamp(80px, 20vw, 100px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid var(--gold);
            border-radius: 50%;
        }
        
        .stats-fighter-info {
            flex: 1;
        }
        
        .stats-fighter-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.6rem);
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
        }
        
        .stats-fighter-details {
            display: flex;
            gap: 1rem;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        
        .stats-fighter-record {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            color: var(--gold);
        }
        
        .stats-content {
            padding: 1rem;
        }
        
        .stats-section {
            margin-bottom: 1.5rem;
        }
        
        .stats-section-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 4vw, 1.2rem);
            color: var(--canvas-white);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.8rem;
        }
        
        .stats-box {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 0.8rem;
            text-align: center;
        }
        
        .stats-box-label {
            font-size: clamp(0.75rem, 2.8vw, 0.8rem);
            opacity: 0.6;
            margin-bottom: 0.3rem;
        }
        
        .stats-box-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.5rem);
            color: var(--canvas-white);
        }
        
        .stats-box.highlight {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.05);
        }
        
        .stats-bar-item {
            margin-bottom: 1rem;
        }
        
        .stats-bar-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
        }
        
        .stats-bar-label {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            color: var(--canvas-white);
        }
        
        .stats-bar-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            color: var(--gold);
        }
        
        .stats-bar-container {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .stats-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--gold), #FFA500);
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .fight-history-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .fight-history-item {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 0.8rem;
        }
        
        .fight-history-result {
            font-size: 1.5rem;
            flex-shrink: 0;
        }
        
        .fight-history-info {
            flex: 1;
        }
        
        .fight-history-opponent {
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            color: var(--canvas-white);
            margin-bottom: 0.2rem;
        }
        
        .fight-history-date {
            font-size: clamp(0.75rem, 2.8vw, 0.8rem);
            opacity: 0.5;
        }
        
        .fight-history-item.win {
            border-left: 3px solid #4ade80;
        }
        
        .fight-history-item.loss {
            border-left: 3px solid #ef4444;
        }
        
        .fight-history-item.draw {
            border-left: 3px solid #94a3b8;
        }
        
        .stats-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .stats-badge {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 20px;
            padding: 0.5rem 1rem;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
        }
        
        .stats-badge-icon {
            font-size: 1.2rem;
        }
        
        .stats-empty {
            text-align: center;
            padding: 2rem 1rem;
            opacity: 0.5;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
        }
        
        /* DAILY REWARDS SCREEN */
        #dailyRewardsScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .daily-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
        }
        
        .daily-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
            text-align: center;
        }
        
        .daily-subtitle {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
            text-align: center;
        }
        
        .daily-streak {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem;
            text-align: center;
        }
        
        .daily-streak-icon {
            font-size: clamp(2rem, 7vw, 2.5rem);
            margin-bottom: 0.5rem;
        }
        
        .daily-streak-label {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.7;
            margin-bottom: 0.3rem;
        }
        
        .daily-streak-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            color: var(--gold);
        }
        
        .daily-content {
            padding: 1rem;
        }
        
        .daily-calendar {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .daily-day {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            position: relative;
        }
        
        .daily-day.claimed {
            background: rgba(74, 222, 128, 0.1);
            border-color: rgba(74, 222, 128, 0.5);
        }
        
        .daily-day.today {
            border-color: var(--gold);
            border-width: 2px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            animation: pulse 2s ease-in-out infinite;
        }
        
        .daily-day.locked {
            opacity: 0.3;
        }
        
        .daily-day-number {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.8rem, 3vw, 0.9rem);
            color: var(--canvas-white);
            margin-bottom: 0.2rem;
        }
        
        .daily-day-reward {
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            margin-bottom: 0.2rem;
        }
        
        .daily-day-value {
            font-size: clamp(0.65rem, 2.5vw, 0.7rem);
            font-weight: 600;
        }
        
        .daily-day-check {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.9rem;
        }
        
        .daily-claim-section {
            background: rgba(255, 215, 0, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
        }
        
        .daily-claim-icon {
            font-size: clamp(3rem, 10vw, 4rem);
            margin-bottom: 0.5rem;
        }
        
        .daily-claim-text {
            font-size: clamp(1rem, 4vw, 1.2rem);
            color: var(--canvas-white);
            margin-bottom: 0.5rem;
        }
        
        .daily-claim-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 2rem);
            color: var(--gold);
            margin-bottom: 1rem;
        }
        
        .daily-claim-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 4vw, 1.2rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .daily-claim-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
        }
        
        .daily-claim-button:active:not(:disabled) {
            transform: scale(0.97);
        }
        
        .daily-next-reward {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            text-align: center;
        }
        
        .daily-next-label {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        
        .daily-next-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.2rem, 4.5vw, 1.4rem);
            color: var(--canvas-white);
        }
        
        .daily-timer {
            margin-top: 1rem;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
            text-align: center;
        }
        
        /* ACHIEVEMENTS SCREEN */
        #achievementsScreen {
            background: var(--dark-bg);
            overflow-y: auto;
        }
        
        .achievements-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, transparent 100%);
        }
        
        .achievements-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.5rem, 5vw, 1.8rem);
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
            text-align: center;
        }
        
        .achievements-subtitle {
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            opacity: 0.6;
            text-align: center;
        }
        
        .achievements-summary {
            display: flex;
            justify-content: space-around;
            padding: 1rem;
            background: rgba(255, 215, 0, 0.05);
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .achievement-summary-item {
            text-align: center;
        }
        
        .achievement-summary-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1.3rem, 5vw, 1.5rem);
            color: var(--gold);
        }
        
        .achievement-summary-label {
            font-size: clamp(0.75rem, 2.8vw, 0.8rem);
            opacity: 0.7;
            margin-top: 0.2rem;
        }
        
        .achievements-content {
            padding: 1rem;
        }
        
        .achievement-category {
            margin-bottom: 1.5rem;
        }
        
        .achievement-category-title {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 4vw, 1.2rem);
            color: var(--canvas-white);
            margin-bottom: 0.8rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .achievement-item {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.8rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .achievement-item.completed {
            background: rgba(74, 222, 128, 0.1);
            border-color: rgba(74, 222, 128, 0.5);
        }
        
        .achievement-item.locked {
            opacity: 0.6;
        }
        
        .achievement-icon {
            font-size: clamp(2rem, 7vw, 2.5rem);
            flex-shrink: 0;
            filter: grayscale(100%);
            opacity: 0.5;
            transition: all 0.3s ease;
        }
        
        .achievement-item.completed .achievement-icon {
            filter: grayscale(0%);
            opacity: 1;
        }
        
        .achievement-info {
            flex: 1;
        }
        
        .achievement-name {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(1rem, 4vw, 1.1rem);
            color: var(--canvas-white);
            margin-bottom: 0.3rem;
        }
        
        .achievement-description {
            font-size: clamp(0.8rem, 3vw, 0.85rem);
            opacity: 0.7;
            margin-bottom: 0.5rem;
        }
        
        .achievement-progress {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .achievement-progress-bar {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .achievement-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--gold), #FFA500);
            border-radius: 3px;
            transition: width 0.5s ease;
        }
        
        .achievement-progress-text {
            font-size: clamp(0.75rem, 2.8vw, 0.8rem);
            opacity: 0.7;
            white-space: nowrap;
        }
        
        .achievement-reward {
            flex-shrink: 0;
            text-align: center;
        }
        
        .achievement-reward-value {
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.9rem, 3.5vw, 1rem);
            color: var(--gold);
        }
        
        .achievement-reward-label {
            font-size: clamp(0.65rem, 2.5vw, 0.7rem);
            opacity: 0.6;
        }
        
        .achievement-claim-btn {
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: var(--dark-bg);
            font-family: 'Oswald', sans-serif;
            font-size: clamp(0.85rem, 3vw, 0.9rem);
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .achievement-claim-btn:active {
            transform: scale(0.97);
        }
        
        /* ========================================= */
        /* INJURY SYSTEM STYLES */
        /* ========================================= */
        
        .injury-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .injury-modal.active {
            opacity: 1;
        }
        
        .injury-modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
        }
        
        .injury-modal-content {
            position: relative;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            border: 2px solid var(--gold);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.3);
            animation: slideUpInjury 0.3s ease;
        }
        
        @keyframes slideUpInjury {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .injury-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .injury-modal-header h2 {
            font-family: 'Oswald', sans-serif;
            font-size: 1.8rem;
            color: var(--gold);
            margin: 0;
        }
        
        .injury-close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .injury-close-btn:hover {
            opacity: 1;
        }
        
        .injury-info {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .injury-name {
            font-family: 'Oswald', sans-serif;
            font-size: 1.5rem;
            color: white;
            margin-bottom: 0.8rem;
        }
        
        .injury-severity {
            display: inline-block;
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.8rem;
        }
        
        .injury-severity.light {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
        }
        
        .injury-severity.medium {
            background: rgba(250, 204, 21, 0.2);
            color: #facc15;
        }
        
        .injury-severity.heavy {
            background: rgba(251, 146, 60, 0.2);
            color: #fb923c;
        }
        
        .injury-severity.critical {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }
        
        .injury-effect,
        .injury-time {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 0.5rem;
        }
        
        .treatment-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .treatment-option {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1rem;
            transition: all 0.3s ease;
        }
        
        .treatment-option:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: var(--gold);
        }
        
        .treatment-option.instant {
            border-color: var(--gold);
            background: rgba(255, 215, 0, 0.1);
        }
        
        .treatment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .treatment-name {
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            color: white;
        }
        
        .treatment-cost {
            font-weight: 700;
            color: var(--gold);
        }
        
        .treatment-time {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 0.8rem;
        }
        
        .treatment-btn {
            width: 100%;
            background: linear-gradient(135deg, var(--gold), #FFA500);
            border: none;
            color: #0a0a0a;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            padding: 0.8rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        
        .treatment-btn:hover:not(.disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
        }
        
        .treatment-btn.instant {
            background: linear-gradient(135deg, #FFD700, #FFC700);
        }
        
        .treatment-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #555;
        }
        
        .injury-natural-btn {
            width: 100%;
            background: none;
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            padding: 0.8rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .injury-natural-btn:hover {
            border-color: white;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .fighter-injury-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            padding: 0.3rem 0.6rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            animation: pulseInjury 2s ease infinite;
        }
        
        @keyframes pulseInjury {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }
        
        .injury-status-banner {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.2));
            border: 2px solid #ef4444;
            border-radius: 12px;
            padding: 1rem;
            margin: 1rem 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .injury-status-banner:hover {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(220, 38, 38, 0.3));
            transform: translateY(-2px);
        }
        
        .injury-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .injury-status-name {
            font-family: 'Oswald', sans-serif;
            font-size: 1.2rem;
            color: #ef4444;
        }
        
        .injury-status-severity {
            font-size: 0.9rem;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            background: rgba(239, 68, 68, 0.3);
            color: white;
        }
        
        .injury-status-time {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 0.3rem;
        }
        
        .injury-status-action {
            margin-top: 0.8rem;
            font-size: 0.9rem;
            color: var(--gold);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <!-- LOADING SCREEN -->
    <div id="loadingScreen" class="screen active">
        <div class="loading-content">
            <div class="game-logo">BOXING<br>MANAGER</div>
            <div class="game-subtitle">ПРОМОУТЕР</div>
            <div class="loading-bar-container">
                <div class="loading-bar"></div>
            </div>
            <div class="loading-text">ЗАВАНТАЖЕННЯ...</div>
            <div style="position: absolute; bottom: 20px; width: 100%; text-align: center; color: var(--gold); font-size: 0.8rem; opacity: 0.6;">
                0.20 Alpha - Red Marker
            </div>
        </div>
    </div>

    <!-- PROLOGUE SCREEN -->
    <div id="prologueScreen" class="screen">
        <div class="prologue-content">
            <div class="prologue-text" id="prologueText">
                <span class="prologue-line highlight">Ти був на вершині.</span>
                <span class="prologue-line">Повні арени. Великі бої. Світові титули.</span>
                <span class="prologue-line highlight">Один вечір змінив усе.</span>
                <span class="prologue-line">Важкий удар. Ти впав.</span>
                <span class="prologue-line">Лікар сказав просто: «Ще один бій — і ти більше не вийдеш з рингу».</span>
                <span class="prologue-line highlight">Кар'єра закінчилась. Але твій шлях — ні.</span>
                <span class="prologue-line">Тепер ти не б'єш.</span>
                <span class="prologue-line highlight">Тепер ти створюєш чемпіонів.</span>
            </div>
            <button class="continue-button" id="continueBtn" onclick="showCharacterCreation()" style="opacity: 0;">
                Продовжити
            </button>
        </div>
    </div>

    <!-- CHARACTER CREATION SCREEN -->
    <div id="characterScreen" class="screen">
        <div class="character-header">
            <div class="character-title">Створення персонажа</div>
            <div class="character-subtitle">Розкажи про себе</div>
        </div>
        
        <div class="form-container">
            <div class="form-group">
                <label class="form-label">Ім'я та Прізвище</label>
                <input type="text" 
                       id="managerNameInput" 
                       class="form-input" 
                       placeholder="Іван Петренко"
                       maxlength="40">
            </div>
            
            <div class="form-group">
                <label class="form-label">Вік</label>
                <input type="number" 
                       id="managerAge" 
                       class="form-input" 
                       placeholder="Скільки тобі років..."
                       min="8"
                       max="99">
            </div>
            
            <div class="form-group">
                <label class="form-label">Країна</label>
                <select id="managerCountry" class="form-select">
                    <option value="">Обери країну...</option>
                    <option value="Україна">Україна 🇺🇦</option>
                    <option value="США">США 🇺🇸</option>
                    <option value="Великобританія">Великобританія 🇬🇧</option>
                    <option value="Мексика">Мексика 🇲🇽</option>
                    <option value="Японія">Японія 🇯🇵</option>
                    <option value="Росія">Росія 🇷🇺</option>
                    <option value="Німеччина">Німеччина 🇩🇪</option>
                    <option value="Канада">Канада 🇨🇦</option>
                    <option value="Австралія">Австралія 🇦🇺</option>
                    <option value="Бразилія">Бразилія 🇧🇷</option>
                    <option value="Інше">Інше 🌍</option>
                </select>
            </div>
            
            <div class="form-group">
                <label class="form-label">Місто</label>
                <input type="text" 
                       id="managerCity" 
                       class="form-input" 
                       placeholder="Київ"
                       maxlength="30"
                       pattern="[A-Za-zА-Яа-яІіЇїЄєҐґ\s\-']+"
                       title="Тільки літери">
            </div>
            
            <button class="start-button" id="startButton" onclick="startGame()" disabled>
                Почати гру
            </button>
        </div>
    </div>

    <!-- STREET WALK TRANSITION -->
    <div id="streetWalkScreen" class="screen">
        <div class="street-walk-content">
            <div class="street-walk-text" id="streetWalkText">
                <span class="street-walk-line">Вечір. Темні вулиці міста.</span>
                <span class="street-walk-line">Ти йдеш додому, думаючи про минуле.</span>
                <span class="street-walk-line highlight">Раптом чуєш крики з провулка.</span>
                <span class="street-walk-line">Підходиш ближче.</span>
                <span class="street-walk-line">Натовп. Імпровізований ринг. Два бійці.</span>
                <span class="street-walk-line highlight">Вуличний турнір.</span>
                <span class="street-walk-line">Ти бачиш у їхніх очах те, що було в твоїх.</span>
                <span class="street-walk-line highlight">Голод. Fire. Талант.</span>
            </div>
        </div>
    </div>

    <!-- STREET TOURNAMENT SCREEN -->
    <div id="streetScreen" class="screen">
        <div class="street-header">
            <div class="street-title">Обери свого бійця</div>
            <div class="street-subtitle">
                Хтось із них може стати чемпіоном.<br>
                Але тільки з твоєю допомогою.
            </div>
        </div>
        
        <div class="fighters-grid" id="fightersGrid">
            <!-- Fighters will be generated here -->
        </div>
    </div>

    <!-- CONFIRMATION MODAL -->
    <div class="modal-overlay" id="confirmModal">
        <div class="modal-content">
            <div class="modal-fighter-avatar" id="modalAvatar"></div>
            <div class="modal-title" id="modalFighterName"></div>
            <div class="modal-subtitle">
                Ти впевнений, що хочеш обрати цього бійця?<br>
                Це рішення змінить твоє майбутнє.
            </div>
            <div class="modal-buttons">
                <button class="modal-button" onclick="closeModal()">Назад</button>
                <button class="modal-button confirm" onclick="confirmFighterSelection()">Так, обираю!</button>
            </div>
        </div>
    </div>

    <!-- TACTICS SELECTION MODAL -->
    <div class="tactics-modal-overlay" id="tacticsModal">
        <div class="tactics-modal-content">
            <div class="tactics-header">
                <div class="tactics-title">⚔️ ОБЕРИ ТАКТИКУ</div>
                <div class="tactics-subtitle">Твій стиль бою визначить перебіг поєдинку</div>
            </div>
            
            <div class="tactics-grid">
                <!-- AGGRESSIVE -->
                <div class="tactic-card" data-tactic="aggressive" onclick="selectTactic('aggressive')">
                    <div class="tactic-header">
                        <div class="tactic-icon">🔴</div>
                        <div class="tactic-name">АГРЕСИВНИЙ</div>
                    </div>
                    <div class="tactic-description">
                        Атакуй без зупинки! Тисни опонента з першої секунди та шукай нокаут.
                    </div>
                    <div class="tactic-effects">
                        <span class="tactic-effect positive">+30% шанс нокауту</span>
                        <span class="tactic-effect positive">+20% урон</span>
                        <span class="tactic-effect negative">-20% захист</span>
                    </div>
                </div>
                
                <!-- DEFENSIVE -->
                <div class="tactic-card" data-tactic="defensive" onclick="selectTactic('defensive')">
                    <div class="tactic-header">
                        <div class="tactic-icon">🔵</div>
                        <div class="tactic-name">ОБОРОННИЙ</div>
                    </div>
                    <div class="tactic-description">
                        Захищайся та контратакуй. Виміщуй опонента та бий на відповідь.
                    </div>
                    <div class="tactic-effects">
                        <span class="tactic-effect positive">+30% захист</span>
                        <span class="tactic-effect positive">+20% витривалість</span>
                        <span class="tactic-effect negative">-20% урон</span>
                    </div>
                </div>
                
                <!-- BALANCED -->
                <div class="tactic-card selected" data-tactic="balanced" onclick="selectTactic('balanced')">
                    <div class="tactic-header">
                        <div class="tactic-icon">🟡</div>
                        <div class="tactic-name">ЗБАЛАНСОВАНИЙ</div>
                    </div>
                    <div class="tactic-description">
                        Класичний бокс. Комбінуй атаку та захист залежно від ситуації.
                    </div>
                    <div class="tactic-effects">
                        <span class="tactic-effect">Без бонусів та штрафів</span>
                        <span class="tactic-effect">Універсальний підхід</span>
                    </div>
                </div>
            </div>
            
            <button class="tactics-confirm-btn" onclick="confirmTactics()">
                ПОЧАТИ БІЙ 🥊
            </button>
        </div>
    </div>

    <!-- MAIN GAME SCREEN -->
    <div id="gameScreen" class="screen">
        <!-- Top Resource Bar -->
        <div class="top-bar">
            <div class="resource-item">
                <div class="resource-icon">💵</div>
                <div class="resource-value" id="resourceCash">0</div>
            </div>
            <div class="resource-item">
                <div class="resource-icon">⭐</div>
                <div class="resource-value" id="resourceStars">0</div>
            </div>
            <div class="resource-item">
                <div class="resource-icon">🏆</div>
                <div class="resource-value" id="resourceRating">0</div>
            </div>
            <div class="resource-item" id="cloudStatus" style="cursor: pointer; opacity: 0.7;" onclick="showCloudInfo()">
                <div class="resource-icon" id="cloudIcon">☁️</div>
                <div class="resource-value" id="cloudText" style="font-size: 0.7rem;">Cloud</div>
            </div>
        </div>
        
        <!-- Scrollable Content -->
        <div class="game-scroll-content">
            <!-- Manager Profile -->
            <div class="manager-profile">
                <div class="manager-header">
                    <div class="vip-star-container">
                        <div class="vip-star" id="vipStar">⭐</div>
                        <div class="manager-avatar" id="managerAvatar">👔</div>
                    </div>
                    <div class="manager-info">
                        <div class="manager-name">
                            <span id="managerName">👤</span>
                        </div>
                        <div class="manager-details">
                            <span id="managerLocation">Київ, Україна</span>
                        </div>
                        <div class="vip-status" id="vipStatus" style="display: none;">
                            <!-- VIP timer will be here -->
                        </div>
                    </div>
                    <button class="vip-quick-btn" onclick="hapticMedium(); openVIP()">
                        💎 VIP
                    </button>
                </div>
                
                <div class="manager-stats">
                    <div class="manager-stat-box">
                        <div class="manager-stat-label">Боксерів</div>
                        <div class="manager-stat-value" id="managerFighters">1</div>
                    </div>
                    <div class="manager-stat-box">
                        <div class="manager-stat-label">Перемог</div>
                        <div class="manager-stat-value" id="managerWins">0</div>
                    </div>
                    <div class="manager-stat-box clickable" onclick="hapticMedium(); openAchievements()">
                        <div class="manager-stat-label">Досягнення</div>
                        <div class="manager-stat-value" id="achievementsCount">0/20</div>
                    </div>
                </div>
            </div>
            
            <!-- EMERGENCY RESET BUTTON -->
            <div style="padding: 0 1rem; margin-top: 0.5rem;">
                <button onclick="emergencyReset()" style="
                    width: 100%;
                    padding: 0.7rem;
                    background: rgba(239, 68, 68, 0.1);
                    border: 1px solid rgba(239, 68, 68, 0.3);
                    color: #ef4444;
                    border-radius: 8px;
                    font-size: 0.85rem;
                    cursor: pointer;
                    font-family: 'Oswald', sans-serif;
                    transition: all 0.3s;
                " onmouseover="this.style.background='rgba(239, 68, 68, 0.2)'" onmouseout="this.style.background='rgba(239, 68, 68, 0.1)'">
                    🔥 СКИНУТИ ВСЕ (Telegram Cloud + Local)
                </button>
            </div>
            
            <!-- Fighters List -->
            <div class="fighters-list" id="fightersList">
                <!-- Fighters will be generated here -->
            </div>
        </div>
        
        <!-- Bottom Navigation -->
        <div class="bottom-nav">
            <div class="nav-item" onclick="hapticMedium(); openTraining()">
                <div class="nav-icon">🏋️</div>
                <div class="nav-label">Тренування</div>
            </div>
            
            <div class="nav-item" onclick="hapticMedium(); openFights()">
                <div class="nav-icon">🥊</div>
                <div class="nav-label">Бої</div>
            </div>
            
            <div class="nav-item" onclick="hapticMedium(); openMarket()">
                <div class="nav-icon">💼</div>
                <div class="nav-label">Академія</div>
            </div>
            
            <div class="nav-item" onclick="hapticMedium(); openDailyRewards()">
                <div class="nav-icon">🎁</div>
                <div class="nav-label">Нагороди</div>
                <div class="nav-badge" id="dailyBadge" style="display: none;">!</div>
            </div>
            
            <div class="nav-item" onclick="hapticMedium(); openTeam()">
                <div class="nav-icon">👥</div>
                <div class="nav-label">Команда</div>
            </div>
            
            <div class="nav-item" onclick="hapticMedium(); openAchievements()">
                <div class="nav-icon">🏆</div>
                <div class="nav-label">Досягнення</div>
                <div class="nav-badge" id="achievementsBadge" style="display: none;">!</div>
            </div>
        </div>
    </div>

    <!-- TRAINING SCREEN -->
    <div id="trainingScreen" class="screen">
        <button class="back-button" onclick="backToGame()">←</button>
        
        <div class="training-header">
            <div class="training-title">🏋️ Тренування</div>
            <div class="training-subtitle">Покращуй характеристики свого бійця</div>
        </div>
        
        <div class="training-content" id="trainingContent">
            <!-- Training cards will be generated here -->
        </div>
    </div>

    <!-- FIGHTS SCREEN -->
    <div id="fightsScreen" class="screen">
        <button class="back-button" onclick="backToGame()">←</button>
        
        <div class="fights-header">
            <div class="fights-title">🥊 Бої</div>
            <div class="fights-subtitle">Обери суперника та викликай на бій</div>
        </div>
        
        <div id="fightsCooldown" style="display: none;">
            <!-- Cooldown timer will be shown here -->
        </div>
        
        <div class="fights-content" id="fightsContent">
            <!-- Opponents will be generated here -->
        </div>
    </div>

    <!-- FIGHT SIMULATION SCREEN -->
    <div id="fightSimScreen" class="screen">
        <div class="fight-sim-header">
            <div class="fight-sim-title">🥊 БІЙ</div>
            <div class="fight-sim-round" id="simRound">Раунд 1</div>
        </div>
        
        <!-- SIMULATION CONTENT (shown during fight) -->
        <div class="fight-sim-content" id="fightSimContent">
            <div class="fighters-display">
                <div class="fighter-display">
                    <div class="fighter-display-avatar" id="simPlayerAvatar">🥊</div>
                    <div class="fighter-display-name" id="simPlayerName">Гравець</div>
                    <div class="fighter-health-bar">
                        <div class="fighter-health-fill" id="simPlayerHealth" style="width: 100%"></div>
                    </div>
                </div>
                
                <div class="vs-text">VS</div>
                
                <div class="fighter-display">
                    <div class="fighter-display-avatar" id="simOpponentAvatar">🥊</div>
                    <div class="fighter-display-name" id="simOpponentName">Суперник</div>
                    <div class="fighter-health-bar">
                        <div class="fighter-health-fill" id="simOpponentHealth" style="width: 100%"></div>
                    </div>
                </div>
            </div>
            
            <div class="fight-log" id="fightLog">
                <!-- Fight events will appear here -->
            </div>
        </div>
        
        <!-- RESULT DISPLAY (shown after fight) -->
        <div id="fightResultDisplay" style="display: none;">
            <!-- Result will be shown here -->
        </div>
    </div>

    <!-- VIP SCREEN -->
    <div id="vipScreen" class="screen">
        <button class="back-button" onclick="backToGame()">←</button>
        
        <div class="vip-header">
            <div class="vip-icon">💎</div>
            <div class="vip-header-title">VIP СТАТУС</div>
            <div class="vip-header-subtitle">Ексклюзивні переваги для справжніх промоутерів</div>
        </div>
        
        <div class="vip-content" id="vipContent">
            <!-- VIP content will be generated here -->
        </div>
    </div>

    <!-- ACADEMY SCREEN -->
    <div id="academyScreen" class="screen">
        <button class="back-button" onclick="backToGame()">←</button>
        
        <div class="academy-header">
            <div class="academy-title">🎓 Академія</div>
            <div class="academy-subtitle">Найми молодих талантів</div>
        </div>
        
        <div style="display: flex; gap: 0.5rem; margin: 1rem; padding: 0 1rem;">
            <button id="academyTabRookies" class="academy-tab active" onclick="switchAcademyTab('rookies')">
                🌟 Новачки
            </button>
            <button id="academyTabMarket" class="academy-tab" onclick="switchAcademyTab('market')">
                💼 Досвідчені
            </button>
        </div>
        
        <div class="academy-content" id="academyContent">
            <!-- Academy content will be generated here -->
        </div>
    </div>

    <!-- FIGHTER STATS SCREEN -->
    <div id="fighterStatsScreen" class="screen">
        <button class="back-button" onclick="backToGame()">←</button>
        
        <div class="stats-header">
            <div class="stats-fighter-card" id="statsFighterCard">
                <!-- Fighter info will be generated here -->
            </div>
        </div>
        
        <div class="stats-content" id="statsContent">
            <!-- Stats content will be generated here -->
        </div>
    </div>

    <!-- DAILY REWARDS SCREEN -->
    <div id="dailyRewardsScreen" class="screen">
        <button class="back-button" onclick="backToGame()">←</button>
        
        <div class="daily-header">
            <div class="daily-title">🎁 Щоденні нагороди</div>
            <div class="daily-subtitle">Заходь кожен день та отримуй призи!</div>
        </div>
        
        <div class="daily-streak" id="dailyStreak">
            <!-- Streak info will be generated here -->
        </div>
        
        <div class="daily-content" id="dailyContent">
            <!-- Daily rewards content will be generated here -->
        </div>
    </div>

    <!-- TEAM SCREEN -->
    <div class="screen" id="teamScreen">
        <button class="back-button" onclick="backToGame()">←</button>
        
        <div class="screen-content" style="padding: 1.5rem 1rem; padding-top: 60px;">
            <!-- Header -->
            <div style="text-align: center; margin-bottom: 2rem;">
                <h1 style="font-size: 2rem; margin: 0; margin-bottom: 0.5rem;">👥</h1>
                <h2 style="margin: 0; font-size: 1.3rem; font-weight: 600;">Команда</h2>
            </div>
            
            <!-- Summary -->
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 1rem;">
                <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 0.75rem; text-align: center; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem; text-transform: uppercase; letter-spacing: 0.5px;">Членів</div>
                    <div id="teamCount" style="font-size: 1.3rem; font-weight: 700; color: white;">0/3</div>
                </div>
                <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 0.75rem; text-align: center; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem; text-transform: uppercase; letter-spacing: 0.5px;">Твій рейтинг</div>
                    <div id="teamRating" style="font-size: 1.3rem; font-weight: 700; color: #4ade80;">0</div>
                </div>
            </div>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 2rem;">
                <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 0.75rem; text-align: center; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem; text-transform: uppercase; letter-spacing: 0.5px;">Місяць</div>
                    <div id="teamExpenses" style="font-size: 1.3rem; font-weight: 700; color: #ef4444;">$0</div>
                </div>
                <div style="background: rgba(255,255,255,0.05); border-radius: 10px; padding: 0.75rem; text-align: center; border: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 0.3rem; text-transform: uppercase; letter-spacing: 0.5px;">Всього</div>
                    <div id="teamTotalSpent" style="font-size: 1.3rem; font-weight: 700; color: rgba(255,255,255,0.7);">$0</div>
                </div>
            </div>
            
            <!-- Current Team -->
            <div style="margin-bottom: 2rem;">
                <div style="font-size: 0.75rem; font-weight: 600; color: rgba(255,255,255,0.5); margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 1px;">Твоя команда</div>
                <div id="currentTeam"></div>
            </div>
            
            <!-- Available -->
            <div>
                <div style="font-size: 0.75rem; font-weight: 600; color: rgba(255,255,255,0.5); margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 1px;">Доступні для найму</div>
                <div id="availableTeam"></div>
            </div>
        </div>
    </div>

    <!-- ACHIEVEMENTS SCREEN -->
    <div id="achievementsScreen" class="screen">
        <button class="back-button" onclick="backToGame()">←</button>
        
        <div class="achievements-header">
            <div class="achievements-title">🏆 Досягнення</div>
            <div class="achievements-subtitle">Виконуй завдання та отримуй нагороди</div>
        </div>
        
        <div class="achievements-summary" id="achievementsSummary">
            <!-- Summary will be generated here -->
        </div>
        
        <div class="achievements-content" id="achievementsContent">
            <!-- Achievements will be generated here -->
        </div>
    </div>

    <!-- TOAST CONTAINER -->
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- LOADING OVERLAY -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <script>
        // Initialize Telegram Web App
        let tg = window.Telegram?.WebApp || {
            // Fallback для тестування поза Telegram
            ready: () => console.log('Telegram API not available - using fallback'),
            expand: () => console.log('Telegram API not available - using fallback'),
            enableClosingConfirmation: () => {},
            themeParams: { bg_color: '#0a0a0a' },
            HapticFeedback: {
                notificationOccurred: () => {},
                impactOccurred: () => {}
            },
            BackButton: {
                show: () => {},
                hide: () => {},
                onClick: () => {}
            },
            // CloudStorage НЕ створюємо вручну - він має бути від Telegram!
            initDataUnsafe: { user: null }
        };
        
        // ВАЖЛИВО: Перевірити чи це РЕАЛЬНИЙ Telegram
        const isRealTelegram = !!(window.Telegram?.WebApp?.initData);
        const hasTelegramObject = !!window.Telegram;
        const hasWebApp = !!window.Telegram?.WebApp;
        const hasCloudStorage = !!tg.CloudStorage;
        
        console.log('=== TELEGRAM DIAGNOSTIC ===');
        console.log('window.Telegram:', hasTelegramObject);
        console.log('window.Telegram.WebApp:', hasWebApp);
        console.log('Real Telegram (initData):', isRealTelegram);
        console.log('CloudStorage object:', hasCloudStorage);
        console.log('CloudStorage methods:', tg.CloudStorage ? Object.keys(tg.CloudStorage) : 'N/A');
        console.log('===========================');
        
        // Ініціалізувати Telegram
        if (typeof tg.ready === 'function') {
            tg.ready();
        }
        tg.expand();
        tg.enableClosingConfirmation();
        
        // Set theme
        document.body.style.backgroundColor = tg.themeParams.bg_color || '#0a0a0a';
        
        // Перевірка чи доступний Cloud Storage
        const isCloudAvailable = !!(tg.CloudStorage && typeof tg.CloudStorage.setItem === 'function');
        console.log('🔍 Cloud Storage available:', isCloudAvailable);
        
        if (!isCloudAvailable) {
            console.warn('⚠️ Telegram Cloud Storage недоступний. Використовується тільки localStorage.');
            if (isRealTelegram) {
                console.error('❌ ПРОБЛЕМА: Ви в Telegram але CloudStorage не працює!');
                console.error('Можливі причини:');
                console.error('1. Застаріла версія Telegram (потрібна 6.9+)');
                console.error('2. CloudStorage не підтримується на цій платформі');
                console.error('3. WebApp ініціалізувався некоректно');
            }
        } else {
            console.log('✅ Cloud Storage працює коректно!');
        }
        
        // ===== PERFORMANCE OPTIMIZATIONS (v0.02) =====
        
        // 1. In-Memory Cache
        let cachedCharacterData = null;
        let cacheTimestamp = 0;
        const CACHE_TTL = 1000; // 1 секунда
        
        // 2. Debounced Auto-Save
        let saveTimer = null;
        const SAVE_DELAY = 5000; // 5 секунд
        
        // 3. Save Hash (skip if no changes)
        let lastSaveHash = null;
        
        function hashData(data) {
            // Простий хеш для порівняння
            const str = JSON.stringify(data);
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return hash.toString();
        }
        
        function shouldSave(characterData) {
            const currentHash = hashData(characterData);
            if (currentHash === lastSaveHash) {
                console.log('⏭️ Skipping save - no changes');
                return false;
            }
            lastSaveHash = currentHash;
            return true;
        }
        
        // ===== CLOUD STORAGE SYSTEM =====
        
        // Storage Adapter Pattern - легко переключити на сервер пізніше
        class StorageAdapter {
            async save(key, data) {
                throw new Error('Method not implemented');
            }
            
            async load(key) {
                throw new Error('Method not implemented');
            }
            
            async remove(key) {
                throw new Error('Method not implemented');
            }
        }
        
        // Cloud Storage Adapter (використовується ЗАРАЗ)
        class CloudStorageAdapter extends StorageAdapter {
            async save(key, data) {
                return new Promise((resolve, reject) => {
                    // Перевірка чи доступний Cloud Storage
                    if (!tg.CloudStorage || typeof tg.CloudStorage.setItem !== 'function') {
                        console.warn('⚠️ Cloud Storage недоступний');
                        reject(new Error('Cloud Storage not available'));
                        return;
                    }
                    
                    try {
                        const jsonData = JSON.stringify(data);
                        
                        // Якщо дані більше 4KB, розбити на частини
                        if (jsonData.length > 3500) {
                            const chunks = this._splitIntoChunks(jsonData, 3500);
                            let saved = 0;
                            
                            chunks.forEach((chunk, index) => {
                                tg.CloudStorage.setItem(`${key}_${index}`, chunk, (error, success) => {
                                    if (error) {
                                        console.error('Cloud save error:', error);
                                        reject(error);
                                    } else {
                                        saved++;
                                        if (saved === chunks.length) {
                                            // Зберегти мета-дані про кількість частин
                                            tg.CloudStorage.setItem(`${key}_meta`, JSON.stringify({ chunks: chunks.length }), (err) => {
                                                if (err) reject(err);
                                                else resolve(true);
                                            });
                                        }
                                    }
                                });
                            });
                        } else {
                            // Дані влазять в один ключ
                            tg.CloudStorage.setItem(key, jsonData, (error, success) => {
                                if (error) {
                                    console.error('Cloud save error:', error);
                                    reject(error);
                                } else {
                                    resolve(true);
                                }
                            });
                        }
                    } catch (e) {
                        console.error('Save error:', e);
                        reject(e);
                    }
                });
            }
            
            async load(key) {
                return new Promise((resolve, reject) => {
                    // Перевірка чи доступний Cloud Storage
                    if (!tg.CloudStorage || typeof tg.CloudStorage.getItem !== 'function') {
                        console.warn('⚠️ Cloud Storage недоступний');
                        reject(new Error('Cloud Storage not available'));
                        return;
                    }
                    
                    // Спочатку перевірити чи є мета-дані (розбиті дані)
                    tg.CloudStorage.getItem(`${key}_meta`, (error, metaData) => {
                        if (!error && metaData) {
                            // Дані розбиті на частини
                            const meta = JSON.parse(metaData);
                            const chunkKeys = [];
                            for (let i = 0; i < meta.chunks; i++) {
                                chunkKeys.push(`${key}_${i}`);
                            }
                            
                            tg.CloudStorage.getItems(chunkKeys, (err, items) => {
                                if (err) {
                                    reject(err);
                                } else {
                                    // Зібрати всі частини
                                    let fullData = '';
                                    for (let i = 0; i < meta.chunks; i++) {
                                        fullData += items[`${key}_${i}`] || '';
                                    }
                                    
                                    try {
                                        resolve(JSON.parse(fullData));
                                    } catch (e) {
                                        reject(e);
                                    }
                                }
                            });
                        } else {
                            // Дані в одному ключі
                            tg.CloudStorage.getItem(key, (err, data) => {
                                if (err) {
                                    reject(err);
                                } else if (data) {
                                    try {
                                        resolve(JSON.parse(data));
                                    } catch (e) {
                                        reject(e);
                                    }
                                } else {
                                    resolve(null);
                                }
                            });
                        }
                    });
                });
            }
            
            async remove(key) {
                return new Promise((resolve) => {
                    tg.CloudStorage.removeItem(key, () => {
                        resolve(true);
                    });
                });
            }
            
            _splitIntoChunks(str, size) {
                const chunks = [];
                for (let i = 0; i < str.length; i += size) {
                    chunks.push(str.slice(i, i + size));
                }
                return chunks;
            }
        }
        
        // LocalStorage Adapter (FALLBACK якщо Cloud не працює)
        class LocalStorageAdapter extends StorageAdapter {
            async save(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (e) {
                    console.error('LocalStorage save error:', e);
                    throw e;
                }
            }
            
            async load(key) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : null;
                } catch (e) {
                    console.error('LocalStorage load error:', e);
                    return null;
                }
            }
            
            async remove(key) {
                localStorage.removeItem(key);
                return true;
            }
        }
        
        // Game Storage Manager
        class GameStorage {
            constructor() {
                // Спробувати Cloud Storage, fallback на LocalStorage
                this.cloudAdapter = new CloudStorageAdapter();
                this.localAdapter = new LocalStorageAdapter();
                
                // Перевірити чи доступний Cloud Storage
                this.useCloud = isCloudAvailable;
                this.syncInProgress = false;
                
                if (this.useCloud) {
                    console.log('💾 Storage initialized: ☁️ Cloud + 💾 Local');
                } else {
                    console.log('💾 Storage initialized: 💾 Local only (Cloud недоступний)');
                }
            }
            
            async saveCharacter(characterData) {
                const saveTime = Date.now();
                characterData._lastSave = saveTime;
                characterData._version = '2.0';
                
                try {
                    if (this.useCloud && isCloudAvailable) {
                        try {
                            // Зберегти в Cloud
                            await this.cloudAdapter.save('bm_character', characterData);
                            console.log('☁️ Saved to Cloud Storage');
                            
                            // Також зберегти локально як бекап
                            await this.localAdapter.save('bm_character', characterData);
                            
                            return { success: true, cloud: true, timestamp: saveTime };
                        } catch (cloudError) {
                            console.warn('⚠️ Cloud save failed:', cloudError.message);
                            console.warn('Falling back to localStorage...');
                            // Вимкнути Cloud для наступних спроб
                            this.useCloud = false;
                            
                            // Fallback на локальне збереження
                            await this.localAdapter.save('bm_character', characterData);
                            console.log('💾 Saved to Local Storage (Cloud fallback)');
                            
                            return { success: true, cloud: false, timestamp: saveTime, warning: cloudError.message };
                        }
                    } else {
                        // Тільки локально
                        await this.localAdapter.save('bm_character', characterData);
                        console.log('💾 Saved to Local Storage');
                        
                        return { success: true, cloud: false, timestamp: saveTime };
                    }
                } catch (error) {
                    console.error('❌ Save error:', error);
                    return { success: false, error: error.message };
                }
            }
            
            async loadCharacter() {
                try {
                    // ТІЛЬКИ якщо Cloud доступний - намагатися завантажити
                    if (this.useCloud) {
                        try {
                            const cloudData = await this.cloudAdapter.load('bm_character');
                            
                            if (cloudData) {
                                console.log('☁️ Loaded from Cloud Storage');
                                
                                // Також зберегти локально як backup
                                await this.localAdapter.save('bm_character', cloudData);
                                
                                return { data: cloudData, source: 'cloud' };
                            }
                        } catch (cloudError) {
                            console.warn('⚠️ Cloud load failed:', cloudError.message);
                            console.warn('Falling back to localStorage...');
                            // Вимкнути Cloud для наступних спроб
                            this.useCloud = false;
                        }
                    }
                    
                    // Завантажити з localStorage (або якщо Cloud не спрацював)
                    const localData = await this.localAdapter.load('bm_character');
                    
                    if (localData) {
                        console.log('💾 Loaded from Local Storage');
                        
                        // Якщо Cloud доступний - спробувати мігрувати
                        if (this.useCloud && isCloudAvailable) {
                            try {
                                await this.cloudAdapter.save('bm_character', localData);
                                console.log('✅ Migrated to Cloud Storage');
                            } catch (e) {
                                console.warn('⚠️ Migration failed:', e.message);
                            }
                        }
                        
                        return { data: localData, source: 'local' };
                    }
                    
                    return { data: null, source: 'none' };
                    
                } catch (error) {
                    console.error('❌ Load error:', error);
                    
                    // Fallback на локальне завантаження
                    try {
                        const localData = await this.localAdapter.load('bm_character');
                        this.useCloud = false;
                        return { data: localData, source: 'local_fallback' };
                    } catch (localError) {
                        return { data: null, source: 'error', error: localError.message };
                    }
                }
            }
            
            async syncToCloud() {
                if (this.syncInProgress) return;
                
                this.syncInProgress = true;
                
                try {
                    const localData = await this.localAdapter.load('bm_character');
                    
                    if (localData) {
                        await this.cloudAdapter.save('bm_character', localData);
                        console.log('🔄 Synced to Cloud');
                        this.useCloud = true;
                    }
                } catch (error) {
                    console.error('Sync error:', error);
                } finally {
                    this.syncInProgress = false;
                }
            }
        }
        
        // Глобальна змінна
        const gameStorage = new GameStorage();
        
        // Автосинхронізація кожні 30 секунд
        setInterval(() => {
            if (gameStorage.useCloud) {
                gameStorage.syncToCloud();
            }
        }, 30000);
        
        // Helper функції (легко використовувати по всьому коду)
        async function saveGame(characterData) {
            try {
                // Валідація даних перед збереженням
                if (!characterData || typeof characterData !== 'object') {
                    console.error('❌ Invalid character data:', characterData);
                    return false;
                }
                
                // Мінімальна валідація: тільки name обов'язковий
                if (!characterData.name) {
                    console.error('❌ Missing required field: name');
                    return false;
                }
                
                // fighters не обов'язковий (може бути створено пізніше)
                if (!characterData.fighters) {
                    console.log('ℹ️ Saving incomplete character (no fighters yet)');
                }
                
                const result = await gameStorage.saveCharacter(characterData);
                
                if (result.success) {
                    // Показати статус збереження
                    if (result.cloud) {
                        console.log('💾✅ Game saved to Cloud + Local');
                    } else {
                        console.log('💾✅ Game saved to Local only');
                    }
                    
                    // DEBUG: Перевірка що збережено
                    console.log('📊 Saved data size:', JSON.stringify(characterData).length, 'bytes');
                    console.log('👤 Player:', characterData.name);
                    console.log('💰 Cash:', characterData.gameState?.cash);
                } else {
                    console.error('❌ Save failed:', result.error);
                    // НЕ показувати toast - це дратує користувача
                    // showToast('Помилка збереження', result.error, 'error');
                }
                
                return result.success;
            } catch (error) {
                console.error('❌ Save exception:', error);
                return false;
            }
        }
        
        async function loadGame() {
            const result = await gameStorage.loadCharacter();
            
            if (result.data) {
                console.log(`💾 Game loaded from ${result.source}`);
                // Toast вимкнено - не дратує користувача
            }
            
            return result.data;
        }
        
        // Синхронна версія для сумісності (використовує localStorage як кеш)
        // OPTIMIZED: Save with cache and debounce
        function saveGameSync(characterData, immediate = false) {
            // Перевірка чи дані змінились
            if (!immediate && !shouldSave(characterData)) {
                return; // Skip save
            }
            
            // КРИТИЧНО: Оновити кеш з НОВИМИ даними
            cachedCharacterData = JSON.parse(JSON.stringify(characterData)); // Deep copy!
            cacheTimestamp = Date.now();
            
            // Зберегти в localStorage (швидко)
            localStorage.setItem('boxingManager_character', JSON.stringify(characterData));
            
            if (immediate) {
                // Критична дія - зберегти одразу
                console.log('💾 Immediate save');
                saveGame(characterData).catch(e => console.error('Cloud save error:', e));
            } else {
                // Звичайна дія - debounced save
                clearTimeout(saveTimer);
                saveTimer = setTimeout(() => {
                    console.log('💾 Debounced save');
                    saveGame(characterData).catch(e => console.error('Cloud save error:', e));
                }, SAVE_DELAY);
            }
        }
        
        // OPTIMIZED: Load with cache
        function loadGameSync() {
            const now = Date.now();
            
            // Перевірка кешу
            if (cachedCharacterData && (now - cacheTimestamp) < CACHE_TTL) {
                console.log('⚡ Loading from cache');
                return cachedCharacterData;
            }
            
            // Завантажити з localStorage
            const data = localStorage.getItem('boxingManager_character');
            const parsed = data ? JSON.parse(data) : null;
            
            // Оновити кеш
            if (parsed) {
                cachedCharacterData = parsed;
                cacheTimestamp = now;
            }
            
            return parsed;
        }
        
        // ===== UI/UX UTILITIES =====
        
        // Toast Notifications
        function showToast(title, message = '', type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: '✅',
                error: '❌',
                warning: '⚠️',
                info: 'ℹ️'
            };
            
            toast.innerHTML = `
                <div class="toast-icon">${icons[type]}</div>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    ${message ? `<div class="toast-message">${message}</div>` : ''}
                </div>
            `;
            
            container.appendChild(toast);
            
            // Haptic feedback
            try {
                if (type === 'success') {
                    tg.HapticFeedback.notificationOccurred('success');
                } else if (type === 'error') {
                    tg.HapticFeedback.notificationOccurred('error');
                } else if (type === 'warning') {
                    tg.HapticFeedback.notificationOccurred('warning');
                }
            } catch (e) {}
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // Loading overlay
        function showLoading() {
            document.getElementById('loadingOverlay').classList.add('active');
        }
        
        function hideLoading() {
            document.getElementById('loadingOverlay').classList.remove('active');
        }
        
        // Haptic feedback helpers
        function hapticLight() {
            try { tg.HapticFeedback.impactOccurred('light'); } catch (e) {}
        }
        
        function hapticMedium() {
            try { tg.HapticFeedback.impactOccurred('medium'); } catch (e) {}
        }
        
        function hapticHeavy() {
            try { tg.HapticFeedback.impactOccurred('heavy'); } catch (e) {}
        }
        
        // Cloud Storage status functions
        function updateCloudStatus() {
            const icon = document.getElementById('cloudIcon');
            const text = document.getElementById('cloudText');
            
            if (!icon || !text) return;
            
            if (gameStorage.useCloud) {
                icon.textContent = '☁️';
                text.textContent = 'Cloud';
                text.style.color = '#4ade80';
            } else {
                icon.textContent = '💾';
                text.textContent = 'Local';
                text.style.color = '#fbbf24';
            }
        }
        
        function showCloudInfo() {
            const characterData = loadGameSync();
            
            if (!characterData) {
                showToast('ℹ️ Cloud Storage', 'Немає збережених даних', 'info');
                return;
            }
            
            const lastSave = characterData._lastSave ? new Date(characterData._lastSave).toLocaleString('uk-UA') : 'Невідомо';
            const version = characterData._version || '1.0';
            const storage = gameStorage.useCloud ? '☁️ Cloud Storage' : '💾 Local Storage';
            
            const telegramUser = tg.initDataUnsafe?.user;
            const userId = telegramUser ? telegramUser.id : 'N/A';
            
            showToast(
                'Інформація про збереження',
                `${storage}\n` +
                `Останнє збереження: ${lastSave}\n` +
                `Версія: ${version}\n` +
                `Telegram ID: ${userId}`,
                'info'
            );
        }
        
        // ===== END UI/UX UTILITIES =====
        
        // ===== DAILY REWARDS SYSTEM =====
        
        const DAILY_REWARDS = [
            { day: 1, type: 'cash', amount: 500, icon: '💵' },
            { day: 2, type: 'cash', amount: 1000, icon: '💵' },
            { day: 3, type: 'stars', amount: 5, icon: '⭐' },
            { day: 4, type: 'cash', amount: 2000, icon: '💵' },
            { day: 5, type: 'stars', amount: 10, icon: '⭐' },
            { day: 6, type: 'cash', amount: 3000, icon: '💵' },
            { day: 7, type: 'stars', amount: 20, icon: '⭐', bonus: true }
        ];
        
        function initializeDailyRewards() {
            try {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                if (!characterData) return;
                
                const gameState = characterData.gameState;
                
                // Initialize daily rewards data if not exists
                if (!gameState.dailyRewards) {
                    gameState.dailyRewards = {
                        streak: 0,
                        lastClaimDate: null,
                        claimedDays: []
                    };
                    saveGameSync(characterData);
                }
            } catch (error) {
                console.error('Error initializing daily rewards:', error);
            }
        }
        
        function openDailyRewards() {
            showScreen('dailyRewardsScreen');
            loadDailyRewards();
        }
        
        function loadDailyRewards() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const dailyData = characterData.gameState.dailyRewards;
            
            // Check if streak should be reset
            checkDailyStreak(characterData);
            
            // Streak display
            const streakDiv = document.getElementById('dailyStreak');
            streakDiv.innerHTML = `
                <div class="daily-streak-icon">🔥</div>
                <div class="daily-streak-label">Серія днів підряд</div>
                <div class="daily-streak-value">${dailyData.streak} ${getDaysWord(dailyData.streak)}</div>
            `;
            
            // Main content
            const content = document.getElementById('dailyContent');
            
            // Check if can claim today
            const canClaim = canClaimToday(dailyData);
            const nextDay = dailyData.streak + 1;
            const nextReward = DAILY_REWARDS[(nextDay - 1) % 7];
            
            content.innerHTML = `
                <!-- Calendar -->
                <div class="daily-calendar">
                    ${DAILY_REWARDS.map((reward, index) => {
                        const day = index + 1;
                        const isClaimed = dailyData.claimedDays.includes(day);
                        const isToday = day === nextDay && canClaim;
                        const isLocked = day > nextDay;
                        
                        return `
                            <div class="daily-day ${isClaimed ? 'claimed' : ''} ${isToday ? 'today' : ''} ${isLocked ? 'locked' : ''}">
                                ${isClaimed ? '<div class="daily-day-check">✓</div>' : ''}
                                <div class="daily-day-number">День ${day}</div>
                                <div class="daily-day-reward">${reward.icon}</div>
                                <div class="daily-day-value">${reward.type === 'cash' ? '$' + reward.amount : reward.amount}</div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <!-- Claim Section -->
                <div class="daily-claim-section">
                    ${canClaim ? `
                        <div class="daily-claim-icon">${nextReward.icon}</div>
                        <div class="daily-claim-text">День ${nextDay}</div>
                        <div class="daily-claim-value">
                            ${nextReward.type === 'cash' ? '$' + nextReward.amount.toLocaleString() : '⭐ ' + nextReward.amount}
                        </div>
                        ${nextReward.bonus ? '<div style="color: var(--gold); margin-bottom: 1rem;">🎉 БОНУС ТИЖНЯ!</div>' : ''}
                        <button class="daily-claim-button" onclick="claimDailyReward()">
                            🎁 ЗАБРАТИ НАГОРОДУ
                        </button>
                    ` : `
                        <div class="daily-claim-icon">⏰</div>
                        <div class="daily-claim-text">Сьогодні вже отримано!</div>
                        <div class="daily-timer" id="dailyTimer"></div>
                        <button class="daily-claim-button" disabled>
                            ✓ ОТРИМАНО
                        </button>
                    `}
                    
                    ${nextDay < 7 ? `
                        <div class="daily-next-reward">
                            <div class="daily-next-label">Наступна нагорода (День ${nextDay + 1}):</div>
                            <div class="daily-next-value">
                                ${DAILY_REWARDS[nextDay % 7].icon} ${DAILY_REWARDS[nextDay % 7].type === 'cash' ? '$' + DAILY_REWARDS[nextDay % 7].amount.toLocaleString() : '⭐ ' + DAILY_REWARDS[nextDay % 7].amount}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            // Start timer if already claimed
            if (!canClaim) {
                startDailyTimer();
            }
        }
        
        function checkDailyStreak(characterData) {
            const dailyData = characterData.gameState.dailyRewards;
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            
            if (dailyData.lastClaimDate) {
                const lastClaim = new Date(dailyData.lastClaimDate);
                const lastClaimDay = new Date(lastClaim.getFullYear(), lastClaim.getMonth(), lastClaim.getDate()).getTime();
                const daysSince = Math.floor((today - lastClaimDay) / (24 * 60 * 60 * 1000));
                
                // Reset if missed more than 1 day
                if (daysSince > 1) {
                    dailyData.streak = 0;
                    dailyData.claimedDays = [];
                    saveGameSync(characterData);
                }
            }
        }
        
        function canClaimToday(dailyData) {
            if (!dailyData.lastClaimDate) return true;
            
            const now = Date.now();
            const timeSinceLastClaim = now - dailyData.lastClaimDate;
            const hoursInMs = 24 * 60 * 60 * 1000; // 24 години в мілісекундах
            
            // Має пройти мінімум 24 години
            return timeSinceLastClaim >= hoursInMs;
        }
        
        function claimDailyReward() {
            hapticHeavy();
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const dailyData = gameState.dailyRewards;
            
            if (!canClaimToday(dailyData)) {
                showToast('Вже отримано!', 'Приходь завтра за новою нагородою', 'warning');
                return;
            }
            
            // Get next reward
            const nextDay = dailyData.streak + 1;
            const reward = DAILY_REWARDS[(nextDay - 1) % 7];
            
            // Apply reward
            if (reward.type === 'cash') {
                gameState.cash += reward.amount;
            } else if (reward.type === 'stars') {
                gameState.stars += reward.amount;
            }
            
            // Update streak
            dailyData.streak = nextDay;
            dailyData.lastClaimDate = Date.now();
            
            // Update claimed days
            if (!dailyData.claimedDays.includes(nextDay)) {
                dailyData.claimedDays.push(nextDay);
            }
            
            // Reset after 7 days
            if (dailyData.streak >= 7) {
                dailyData.streak = 0;
                dailyData.claimedDays = [];
            }
            
            saveGameSync(characterData);
            
            // Show success
            const rewardText = reward.type === 'cash' 
                ? `$${reward.amount.toLocaleString()}`
                : `⭐ ${reward.amount}`;
            
            showToast('🎁 Нагороду отримано!', `${reward.icon} ${rewardText}${reward.bonus ? '\n🎉 Бонус тижня!' : ''}`, 'success');
            
            // Reload screen
            setTimeout(() => {
                loadDailyRewards();
            }, 500);
        }
        
        function startDailyTimer() {
            const updateTimer = () => {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                const dailyData = characterData.gameState.dailyRewards;
                
                if (!dailyData.lastClaimDate) return;
                
                const now = Date.now();
                const nextClaimTime = dailyData.lastClaimDate + (24 * 60 * 60 * 1000); // +24 години
                const remaining = nextClaimTime - now;
                
                if (remaining <= 0) {
                    const timerEl = document.getElementById('dailyTimer');
                    if (timerEl) {
                        timerEl.textContent = 'Можна забрати нагороду!';
                    }
                    return;
                }
                
                const hours = Math.floor(remaining / (60 * 60 * 1000));
                const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
                const seconds = Math.floor((remaining % (60 * 1000)) / 1000);
                
                const timerEl = document.getElementById('dailyTimer');
                if (timerEl) {
                    timerEl.textContent = `Наступна нагорода через: ${hours}г ${minutes}хв ${seconds}с`;
                }
            };
            
            updateTimer();
            setInterval(updateTimer, 1000); // Update every second
        }
        
        function getDaysWord(days) {
            if (days === 1) return 'день';
            if (days >= 2 && days <= 4) return 'дні';
            return 'днів';
        }
        
        function updateDailyBadge() {
            try {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                if (!characterData || !characterData.gameState || !characterData.gameState.dailyRewards) return;
                
                const dailyData = characterData.gameState.dailyRewards;
                const badge = document.getElementById('dailyBadge');
                
                if (badge && canClaimToday(dailyData)) {
                    badge.style.display = 'block';
                } else if (badge) {
                    badge.style.display = 'none';
                }
            } catch (error) {
                console.error('Error updating daily badge:', error);
            }
        }
        
        // ===== END DAILY REWARDS SYSTEM =====
        
        // ===== ACHIEVEMENTS SYSTEM =====
        
        const ACHIEVEMENTS = {
            // Milestone achievements - маленькі нагороди
            first_win: {
                id: 'first_win',
                name: 'Перша перемога',
                description: 'Виграй свій перший бій',
                icon: '🥉',
                category: 'Бої',
                reward: { type: 'cash', amount: 500 },
                check: (data) => data.gameState.totalWins >= 1
            },
            wins_5: {
                id: 'wins_5',
                name: 'Початківець',
                description: 'Виграй 5 боїв',
                icon: '🥊',
                category: 'Бої',
                reward: { type: 'cash', amount: 1000 },
                check: (data) => data.gameState.totalWins >= 5
            },
            wins_10: {
                id: 'wins_10',
                name: 'Досвідчений',
                description: 'Виграй 10 боїв',
                icon: '🥈',
                category: 'Бої',
                reward: { type: 'stars', amount: 3 },
                check: (data) => data.gameState.totalWins >= 10
            },
            wins_25: {
                id: 'wins_25',
                name: 'Професіонал',
                description: 'Виграй 25 боїв',
                icon: '🥇',
                category: 'Бої',
                reward: { type: 'stars', amount: 5 },
                check: (data) => data.gameState.totalWins >= 25
            },
            wins_50: {
                id: 'wins_50',
                name: 'Чемпіон',
                description: 'Виграй 50 боїв',
                icon: '👑',
                category: 'Бої',
                reward: { type: 'stars', amount: 10 },
                check: (data) => data.gameState.totalWins >= 50
            },
            
            // Training achievements
            first_training: {
                id: 'first_training',
                name: 'Перше тренування',
                description: 'Завершити будь-яке тренування',
                icon: '🏋️',
                category: 'Тренування',
                reward: { type: 'cash', amount: 300 },
                check: (data) => (data.gameState.totalTrainings || 0) >= 1
            },
            trainings_10: {
                id: 'trainings_10',
                name: 'Завзятий',
                description: 'Завершити 10 тренувань',
                icon: '💪',
                category: 'Тренування',
                reward: { type: 'cash', amount: 1500 },
                check: (data) => (data.gameState.totalTrainings || 0) >= 10
            },
            trainings_25: {
                id: 'trainings_25',
                name: 'Трудоголік',
                description: 'Завершити 25 тренувань',
                icon: '🔥',
                category: 'Тренування',
                reward: { type: 'stars', amount: 5 },
                check: (data) => (data.gameState.totalTrainings || 0) >= 25
            },
            
            // Stats achievements
            stat_50: {
                id: 'stat_50',
                name: 'Прогрес',
                description: 'Досягни 50 в будь-якому статі',
                icon: '📈',
                category: 'Розвиток',
                reward: { type: 'cash', amount: 2000 },
                check: (data) => {
                    return data.fighters.some(f => 
                        f.stats.power >= 50 || f.stats.speed >= 50 || 
                        f.stats.stamina >= 50 || f.stats.defense >= 50
                    );
                }
            },
            stat_75: {
                id: 'stat_75',
                name: 'Майстер',
                description: 'Досягни 75 в будь-якому статі',
                icon: '⭐',
                category: 'Розвиток',
                reward: { type: 'stars', amount: 5 },
                check: (data) => {
                    return data.fighters.some(f => 
                        f.stats.power >= 75 || f.stats.speed >= 75 || 
                        f.stats.stamina >= 75 || f.stats.defense >= 75
                    );
                }
            },
            stat_100: {
                id: 'stat_100',
                name: 'Досконалість',
                description: 'Досягни 100 в будь-якому статі',
                icon: '💎',
                category: 'Розвиток',
                reward: { type: 'stars', amount: 10 },
                check: (data) => {
                    return data.fighters.some(f => 
                        f.stats.power === 1000 || f.stats.speed === 1000 || 
                        f.stats.stamina === 1000 || f.stats.defense === 1000
                    );
                }
            },
            
            // Money achievements
            money_10k: {
                id: 'money_10k',
                name: 'Заможний',
                description: 'Накопич $10,000',
                icon: '💰',
                category: 'Бізнес',
                reward: { type: 'stars', amount: 2 },
                check: (data) => data.gameState.cash >= 10000
            },
            money_50k: {
                id: 'money_50k',
                name: 'Багатій',
                description: 'Накопич $50,000',
                icon: '💵',
                category: 'Бізнес',
                reward: { type: 'stars', amount: 5 },
                check: (data) => data.gameState.cash >= 50000
            },
            
            // Reputation achievements
            rep_500: {
                id: 'rep_500',
                name: 'Відомий',
                description: 'Набери 500 репутації',
                icon: '📣',
                category: 'Рейтинг',
                reward: { type: 'cash', amount: 2000 },
                check: (data) => {
                    const fighter = data.fighters[data.activeFighterIndex];
                    return fighter.gameData && fighter.gameData.rating >= 500;
                }
            },
            rep_1000: {
                id: 'rep_1000',
                name: 'Зірка',
                description: 'Досягни рейтингу 1000',
                icon: '🌟',
                category: 'Рейтинг',
                reward: { type: 'stars', amount: 5 },
                check: (data) => {
                    const fighter = data.fighters[data.activeFighterIndex];
                    return fighter.gameData && fighter.gameData.rating >= 1000;
                }
            },
            
            // Academy achievements
            second_fighter: {
                id: 'second_fighter',
                name: 'Розширення',
                description: 'Найми другого бійця',
                icon: '👥',
                category: 'Академія',
                reward: { type: 'stars', amount: 3 },
                check: (data) => data.fighters.length >= 2
            },
            three_fighters: {
                id: 'three_fighters',
                name: 'Повна команда',
                description: 'Найми третього бійця',
                icon: '👨‍👨‍👦',
                category: 'Академія',
                reward: { type: 'stars', amount: 5 },
                check: (data) => data.fighters.length >= 3
            },
            
            // Talent achievements
            talent_8: {
                id: 'talent_8',
                name: 'Талановитий',
                description: 'Отримай бійця з талантом 8+',
                icon: '✨',
                category: 'Таланти',
                reward: { type: 'stars', amount: 3 },
                check: (data) => data.fighters.some(f => f.talent >= 8)
            },
            talent_10: {
                id: 'talent_10',
                name: 'Легенда народжується',
                description: 'Отримай бійця з талантом 10',
                icon: '🌟',
                category: 'Таланти',
                reward: { type: 'stars', amount: 10 },
                check: (data) => data.fighters.some(f => f.talent === 10)
            },
            
            // Team achievements
            first_team_member: {
                id: 'first_team_member',
                name: 'Перший член команди',
                description: 'Найми тренера, лікаря або менеджера',
                icon: '🤝',
                category: 'Команда',
                reward: { type: 'cash', amount: 2000 },
                check: (data) => data.team && Object.keys(data.team.members || {}).length >= 1
            },
            full_team: {
                id: 'full_team',
                name: 'Повна команда',
                description: 'Найми 3 членів команди',
                icon: '👨‍👩‍👦',
                category: 'Команда',
                reward: { type: 'stars', amount: 5 },
                check: (data) => data.team && Object.keys(data.team.members || {}).length >= 3
            },
            
            // Rating achievements
            rating_100: {
                id: 'rating_100',
                name: 'Перший рубіж',
                description: 'Досягни 100 рейтингу',
                icon: '📊',
                category: 'Рейтинг',
                reward: { type: 'cash', amount: 1000 },
                check: (data) => {
                    const fighter = data.fighters[data.activeFighterIndex];
                    return fighter.gameData && fighter.gameData.rating >= 100;
                }
            },
            rating_300: {
                id: 'rating_300',
                name: 'На висоті',
                description: 'Досягни 300 рейтингу',
                icon: '📈',
                category: 'Рейтинг',
                reward: { type: 'stars', amount: 3 },
                check: (data) => {
                    const fighter = data.fighters[data.activeFighterIndex];
                    return fighter.gameData && fighter.gameData.rating >= 300;
                }
            },
            
            // Fight difficulty achievements
            hard_opponent: {
                id: 'hard_opponent',
                name: 'Сміливець',
                description: 'Перемож важкого супротивника',
                icon: '🔥',
                category: 'Виклики',
                reward: { type: 'stars', amount: 2 },
                check: (data) => (data.gameState.hardWins || 0) >= 1
            },
            hard_10: {
                id: 'hard_10',
                name: 'Безстрашний',
                description: 'Перемож 10 важких супротивників',
                icon: '⚔️',
                category: 'Виклики',
                reward: { type: 'stars', amount: 5 },
                check: (data) => (data.gameState.hardWins || 0) >= 10
            },
            
            // Championship achievements  
            first_belt: {
                id: 'first_belt',
                name: 'Чемпіон!',
                description: 'Виграй свій перший пояс',
                icon: '🏆',
                category: 'Чемпіонства',
                reward: { type: 'stars', amount: 5 },
                check: (data) => {
                    const fighter = data.fighters[data.activeFighterIndex];
                    return fighter.belts && Object.keys(fighter.belts).length >= 1;
                }
            },
            three_belts: {
                id: 'three_belts',
                name: 'Колекціонер',
                description: 'Виграй 3 різні пояси',
                icon: '🏅',
                category: 'Чемпіонства',
                reward: { type: 'stars', amount: 10 },
                check: (data) => {
                    const fighter = data.fighters[data.activeFighterIndex];
                    return fighter.belts && Object.keys(fighter.belts).length >= 3;
                }
            },
            
            // Daily bonus achievements
            daily_7: {
                id: 'daily_7',
                name: 'Тиждень підряд',
                description: 'Забери щоденну нагороду 7 днів підряд',
                icon: '📅',
                category: 'Активність',
                reward: { type: 'stars', amount: 3 },
                check: (data) => (data.gameState.dailyStreak || 0) >= 7
            },
            daily_30: {
                id: 'daily_30',
                name: 'Місяць відданості',
                description: 'Забери щоденну нагороду 30 днів підряд',
                icon: '🗓️',
                category: 'Активність',
                reward: { type: 'stars', amount: 15 },
                check: (data) => (data.gameState.dailyStreak || 0) >= 30
            },
            
            // Money achievements (extended)
            money_100k: {
                id: 'money_100k',
                name: 'Мільйонер',
                description: 'Накопич $100,000',
                icon: '💎',
                category: 'Бізнес',
                reward: { type: 'stars', amount: 10 },
                check: (data) => data.gameState.cash >= 100000
            },
            
            // Win streak achievements
            streak_5: {
                id: 'streak_5',
                name: 'Серія',
                description: 'Виграй 5 боїв підряд',
                icon: '🔥',
                category: 'Серії',
                reward: { type: 'stars', amount: 3 },
                check: (data) => (data.gameState.winStreak || 0) >= 5
            },
            streak_10: {
                id: 'streak_10',
                name: 'Непереможний',
                description: 'Виграй 10 боїв підряд',
                icon: '⚡',
                category: 'Серії',
                reward: { type: 'stars', amount: 7 },
                check: (data) => (data.gameState.winStreak || 0) >= 10
            },
            
            // Special achievements
            daily_7: {
                id: 'daily_7',
                name: 'Відданість',
                description: 'Отримай всі щоденні нагороди (7 днів)',
                icon: '🔥',
                category: 'Особливе',
                reward: { type: 'stars', amount: 10 },
                check: (data) => (data.gameState.dailyRewards?.streak || 0) >= 7
            },
            vip_first: {
                id: 'vip_first',
                name: 'VIP клуб',
                description: 'Придбай VIP статус',
                icon: '💎',
                category: 'Особливе',
                reward: { type: 'cash', amount: 3000 },
                check: (data) => data.gameState.vipUntil && data.gameState.vipUntil > Date.now()
            }
        };
        
        function initializeAchievements() {
            try {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                if (!characterData) return;
                
                const gameState = characterData.gameState;
                
                // Initialize achievements data if not exists
                if (!gameState.achievements) {
                    gameState.achievements = {
                        completed: [],
                        claimed: [],
                        totalClaimed: 0
                    };
                    saveGameSync(characterData);
                }
            } catch (error) {
                console.error('Error initializing achievements:', error);
            }
        }
        
        // ===== TEAM UI FUNCTIONS =====
        
        function openTeam() {
            showScreen('teamScreen');
            loadTeamScreen();
        }
        
        function loadTeamScreen() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            initializeTeam(characterData);
            
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            console.log('=== TEAM SCREEN RATING DEBUG ===');
            console.log('fighter.gameData:', fighter.gameData);
            console.log('fighter.gameData.rating:', fighter.gameData?.rating);
            console.log('fighter.rating:', fighter.rating);
            
            const currentRating = fighter.gameData.rating || 0;
            console.log('Displayed rating:', currentRating);
            
            // Update summary
            const memberCount = Object.keys(characterData.team.members).length;
            document.getElementById('teamCount').textContent = memberCount + '/3';
            document.getElementById('teamRating').textContent = currentRating;
            document.getElementById('teamExpenses').textContent = '$' + characterData.team.expenses.toLocaleString();
            document.getElementById('teamTotalSpent').textContent = '$' + characterData.team.totalSpent.toLocaleString();
            
            // Render
            renderCurrentTeam(characterData);
            renderAvailableTeam(characterData);
        }
        
        function renderCurrentTeam(characterData) {
            const container = document.getElementById('currentTeam');
            
            // Безпечна перевірка структури
            if (!characterData.team || !characterData.team.members) {
                console.warn('⚠️ Team data missing, initializing...');
                characterData.team = { members: {}, monthlyCost: 0 };
            }
            
            const members = Object.values(characterData.team.members || {});
            
            if (members.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 3rem 1rem; opacity: 0.4;">
                        <div style="font-size: 2.5rem; margin-bottom: 0.5rem;">👥</div>
                        <div style="font-size: 0.9rem;">Немає найнятих</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = members.map(member => {
                const typeInfo = TEAM_MEMBER_TYPES[member.type];
                
                // Format bonuses
                const bonuses = [];
                if (member.bonuses.trainingBonus) bonuses.push({ icon: '📚', text: '+' + Math.round(member.bonuses.trainingBonus * 100) + '%' });
                if (member.bonuses.powerBonus) bonuses.push({ icon: '💪', text: '+' + member.bonuses.powerBonus });
                if (member.bonuses.healingSpeed) bonuses.push({ icon: '🏥', text: '-' + Math.round((1 - member.bonuses.healingSpeed) * 100) + '%' });
                if (member.bonuses.injuryResistance) bonuses.push({ icon: '🛡️', text: '-' + Math.round(member.bonuses.injuryResistance * 100) + '%' });
                if (member.bonuses.fightEarnings) bonuses.push({ icon: '💰', text: '+' + Math.round(member.bonuses.fightEarnings * 100) + '%' });
                
                return `
                    <div style="background: rgba(255,255,255,0.03); 
                                border: 1px solid rgba(255,255,255,0.1); 
                                border-radius: 12px; 
                                padding: 1rem; 
                                margin-bottom: 0.75rem;">
                        
                        <!-- Header -->
                        <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem;">
                            <div style="font-size: 2rem; line-height: 1;">${typeInfo.icon}</div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.95rem; font-weight: 600; color: white; margin-bottom: 0.2rem;">
                                    ${member.firstName} ${member.lastName}
                                </div>
                                <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">
                                    ${typeInfo.name}
                                </div>
                            </div>
                            <button onclick="fireMember('${member.type}')" 
                                    style="background: rgba(239,68,68,0.15); 
                                           color: #ef4444; 
                                           border: 1px solid rgba(239,68,68,0.3);
                                           padding: 0.5rem 0.75rem; 
                                           border-radius: 8px; 
                                           font-size: 0.8rem;
                                           font-weight: 600; 
                                           cursor: pointer;">
                                Звільнити
                            </button>
                        </div>
                        
                        <!-- Bonuses -->
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.75rem;">
                            ${bonuses.map(bonus => `
                                <div style="background: rgba(255,255,255,0.05); 
                                            border: 1px solid rgba(255,255,255,0.1);
                                            border-radius: 6px; 
                                            padding: 0.4rem 0.6rem;
                                            display: flex;
                                            align-items: center;
                                            gap: 0.3rem;">
                                    <span style="font-size: 0.9rem;">${bonus.icon}</span>
                                    <span style="font-size: 0.75rem; font-weight: 600; color: rgba(255,255,255,0.9);">${bonus.text}</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <!-- Salary -->
                        <div style="padding-top: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem; margin-bottom: 0.2rem; text-transform: uppercase; letter-spacing: 0.5px;">
                                Зарплата
                            </div>
                            <div style="color: #fbbf24; font-weight: 600; font-size: 0.95rem;">
                                $${member.salary.toLocaleString()}/міс
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderAvailableTeam(characterData) {
            const container = document.getElementById('availableTeam');
            const available = getAvailableTeamMembers(characterData);
            const gameState = characterData.gameState;
            
            console.log('🎨 Rendering available team...');
            console.log('   Available data:', available);
            
            let html = '';
            let totalMembers = 0;
            
            Object.entries(TEAM_MEMBER_TYPES).forEach(([typeId, typeInfo]) => {
                const members = available[typeId];
                console.log('   Type:', typeId, 'Members:', members);
                
                if (!members || members.length === 0) {
                    console.log('     ⚠️ No members of type:', typeId);
                    return;
                }
                
                members.forEach(member => {
                    totalMembers++;
                    const canHire = member.meetsRequirements && member.canAfford;
                    html += `
                        <div style="background: rgba(255,255,255,0.03); 
                                    border: 1px solid ${canHire ? 'rgba(255,255,255,0.15)' : 'rgba(255,255,255,0.08)'}; 
                                    border-radius: 12px; 
                                    padding: 1rem; 
                                    margin-bottom: 0.75rem;
                                    ${!canHire ? 'opacity: 0.5;' : ''}">
                            
                            <!-- Header -->
                            <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem;">
                                <div style="font-size: 2rem; line-height: 1;">${typeInfo.icon}</div>
                                <div style="flex: 1;">
                                    <div style="font-size: 0.95rem; font-weight: 600; color: white; margin-bottom: 0.2rem;">
                                        ${member.firstName} ${member.lastName}
                                    </div>
                                    <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5);">
                                        ${typeInfo.name}
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Costs -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.75rem;">
                                <div style="background: rgba(255,255,255,0.05); 
                                            border: 1px solid rgba(255,255,255,0.1);
                                            border-radius: 8px; 
                                            padding: 0.5rem; 
                                            text-align: center;">
                                    <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem; text-transform: uppercase; letter-spacing: 0.5px;">Найм</div>
                                    <div style="font-size: 0.9rem; font-weight: 700; color: #fbbf24;">
                                        $${member.hiringCost.toLocaleString()}
                                    </div>
                                </div>
                                <div style="background: rgba(255,255,255,0.05); 
                                            border: 1px solid rgba(255,255,255,0.1);
                                            border-radius: 8px; 
                                            padding: 0.5rem; 
                                            text-align: center;">
                                    <div style="font-size: 0.65rem; color: rgba(255,255,255,0.5); margin-bottom: 0.2rem; text-transform: uppercase; letter-spacing: 0.5px;">Місяць</div>
                                    <div style="font-size: 0.9rem; font-weight: 700; color: #ef4444;">
                                        $${member.salary.toLocaleString()}
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Requirements Info (Always shown) -->
                            ${member.requirements && member.requirements.rating !== undefined ? `
                                <div style="background: rgba(255,255,255,0.05); 
                                            border: 1px solid ${member.meetsRequirements ? 'rgba(74,222,128,0.2)' : 'rgba(239,68,68,0.2)'}; 
                                            border-radius: 8px; 
                                            padding: 0.6rem; 
                                            margin-bottom: 0.75rem; 
                                            display: flex;
                                            align-items: center;
                                            justify-content: space-between;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="font-size: 0.75rem; color: rgba(255,255,255,0.7);">
                                            Потрібний рейтинг:
                                        </span>
                                        <span style="font-size: 0.8rem; font-weight: 700; color: ${member.meetsRequirements ? '#4ade80' : '#fbbf24'};">
                                            ${member.requirements.rating}
                                        </span>
                                    </div>
                                    <div style="font-size: 1rem;">
                                        ${member.meetsRequirements ? '✅' : '🔒'}
                                    </div>
                                </div>
                            ` : ''}
                            
                            ${!member.meetsRequirements && !member.requirements.rating ? `
                                <div style="background: rgba(239,68,68,0.1); 
                                            border: 1px solid rgba(239,68,68,0.2); 
                                            border-radius: 8px; 
                                            padding: 0.6rem; 
                                            margin-bottom: 0.75rem; 
                                            font-size: 0.75rem; 
                                            color: #ef4444;
                                            text-align: center;">
                                    ⚠️ ${member.missingRequirements.join(', ')}
                                </div>
                            ` : ''}
                            
                            <!-- Hire Button -->
                            <button onclick="hireMember('${member.id}')" 
                                    ${!canHire ? 'disabled' : ''}
                                    style="width: 100%; 
                                           background: ${canHire ? 'rgba(255,255,255,0.1)' : 'rgba(255,255,255,0.03)'}; 
                                           color: ${canHire ? 'white' : 'rgba(255,255,255,0.4)'}; 
                                           border: 1px solid ${canHire ? 'rgba(255,255,255,0.2)' : 'rgba(255,255,255,0.08)'}; 
                                           padding: 0.75rem; 
                                           border-radius: 10px; 
                                           font-size: 0.85rem;
                                           font-weight: 600; 
                                           cursor: ${canHire ? 'pointer' : 'not-allowed'};">
                                ${!member.canAfford ? '💰 Недостатньо грошей' : 
                                  !member.meetsRequirements ? '🔒 Заблоковано' : 
                                  'Найти за $' + member.hiringCost.toLocaleString()}
                            </button>
                        </div>
                    `;
                });
            });
            
            if (html === '') {
                console.log('⚠️ NO TEAM MEMBERS TO DISPLAY!');
                html = `
                    <div style="text-align: center; padding: 3rem 1rem; opacity: 0.4;">
                        <div style="font-size: 2.5rem; margin-bottom: 0.5rem;">🔒</div>
                        <div style="font-size: 0.9rem;">Немає доступних</div>
                    </div>
                `;
            } else {
                console.log('✅ Rendered', totalMembers, 'team members');
            }
            
            container.innerHTML = html;
        }
        
        function hireMember(memberId) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const result = hireTeamMember(characterData, memberId);
            
            if (result.success) {
                const member = TEAM_MEMBERS[memberId];
                showToast('✅ Найнято ' + member.firstName + ' ' + member.lastName + '!', '', 'success');
                saveGameSync(characterData);
                loadTeamScreen();
            } else {
                showToast('❌ Помилка', result.error, 'error');
            }
        }
        
        function fireMember(memberType) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const member = characterData.team.members[memberType];
            
            if (confirm('Звільнити ' + member.firstName + ' ' + member.lastName + '?')) {
                const result = fireTeamMember(characterData, memberType);
                
                if (result.success) {
                    showToast('👋 Звільнено', '', 'info');
                    saveGameSync(characterData);
                    loadTeamScreen();
                }
            }
        }
        
        function openAchievements() {
            showScreen('achievementsScreen');
            loadAchievements();
        }
        
        function loadAchievements() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            
            // Initialize achievements if not exists
            if (!characterData.gameState.achievements) {
                characterData.gameState.achievements = {
                    completed: [],
                    claimed: [],
                    notified: [],
                    totalClaimed: 0
                };
                saveGameSync(characterData);
            }
            
            // Ensure all arrays exist
            if (!characterData.gameState.achievements.completed) {
                characterData.gameState.achievements.completed = [];
            }
            if (!characterData.gameState.achievements.claimed) {
                characterData.gameState.achievements.claimed = [];
            }
            if (!characterData.gameState.achievements.notified) {
                characterData.gameState.achievements.notified = [];
            }
            if (typeof characterData.gameState.achievements.totalClaimed === 'undefined') {
                characterData.gameState.achievements.totalClaimed = 0;
            }
            
            const achievementsData = characterData.gameState.achievements;
            
            // Check if ACHIEVEMENTS exists
            if (typeof ACHIEVEMENTS === 'undefined') {
                const content = document.getElementById('achievementsContent');
                content.innerHTML = '<div style="text-align: center; padding: 3rem; opacity: 0.7;">Система досягнень тимчасово недоступна</div>';
                
                const summary = document.getElementById('achievementsSummary');
                summary.innerHTML = '';
                return;
            }
            
            // Check for new completions
            try {
                checkAchievements(characterData);
            } catch (error) {
                console.error('Error checking achievements:', error);
            }
            
            // Count completed and claimed
            const completed = achievementsData.completed.length;
            const claimed = achievementsData.claimed ? achievementsData.claimed.length : 0;
            const total = Object.keys(ACHIEVEMENTS).length;
            const unclaimed = completed - claimed;
            
            // Summary
            const summary = document.getElementById('achievementsSummary');
            summary.innerHTML = `
                <div class="achievement-summary-item">
                    <div class="achievement-summary-value">${completed}/${total}</div>
                    <div class="achievement-summary-label">Виконано</div>
                </div>
                <div class="achievement-summary-item">
                    <div class="achievement-summary-value">${claimed}</div>
                    <div class="achievement-summary-label">Отримано</div>
                </div>
                <div class="achievement-summary-item">
                    <div class="achievement-summary-value" style="${unclaimed > 0 ? 'color: #4ade80;' : ''}">${unclaimed}</div>
                    <div class="achievement-summary-label">Доступно</div>
                </div>
            `;
            
            // Group achievements by category
            const categories = {};
            Object.values(ACHIEVEMENTS).forEach(achievement => {
                if (!categories[achievement.category]) {
                    categories[achievement.category] = [];
                }
                categories[achievement.category].push(achievement);
            });
            
            // Render achievements
            const content = document.getElementById('achievementsContent');
            content.innerHTML = '';
            
            Object.entries(categories).forEach(([category, achievements]) => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'achievement-category';
                
                let categoryHTML = `<div class="achievement-category-title">${category}</div>`;
                
                achievements.forEach(achievement => {
                    const isCompleted = achievementsData.completed.includes(achievement.id);
                    const isClaimed = achievementsData.claimed && achievementsData.claimed.includes(achievement.id);
                    
                    let progress = { current: 0, target: 1, percentage: 0 };
                    try {
                        progress = getAchievementProgress(achievement, characterData);
                    } catch (error) {
                        console.error('Error getting progress for', achievement.id, error);
                    }
                    
                    categoryHTML += `
                        <div class="achievement-item ${isCompleted ? 'completed' : 'locked'}">
                            <div class="achievement-icon">${achievement.icon}</div>
                            <div class="achievement-info">
                                <div class="achievement-name">${achievement.name}</div>
                                <div class="achievement-description">${achievement.description}</div>
                                ${!isCompleted ? `
                                    <div class="achievement-progress">
                                        <div class="achievement-progress-bar">
                                            <div class="achievement-progress-fill" style="width: ${progress.percentage}%"></div>
                                        </div>
                                        <div class="achievement-progress-text">${progress.current}/${progress.target}</div>
                                    </div>
                                ` : ''}
                            </div>
                            <div class="achievement-reward">
                                <div class="achievement-reward-value">
                                    ${achievement.reward.type === 'cash' ? '$' + achievement.reward.amount : '⭐' + achievement.reward.amount}
                                </div>
                                ${isCompleted && !isClaimed ? `
                                    <button class="achievement-claim-btn" onclick="claimAchievement('${achievement.id}')">
                                        ЗАБРАТИ
                                    </button>
                                ` : ''}
                                ${isClaimed ? `<div class="achievement-reward-label">✓ Отримано</div>` : ''}
                            </div>
                        </div>
                    `;
                });
                
                categoryDiv.innerHTML = categoryHTML;
                content.appendChild(categoryDiv);
            });
        }
        
        function checkAchievements(characterData) {
            // Initialize achievements if not exists
            if (!characterData.gameState.achievements) {
                characterData.gameState.achievements = {
                    completed: [],
                    claimed: [],
                    notified: [],
                    totalClaimed: 0
                };
            }
            
            const achievementsData = characterData.gameState.achievements;
            
            // Initialize arrays if not exists
            if (!achievementsData.completed) {
                achievementsData.completed = [];
            }
            if (!achievementsData.claimed) {
                achievementsData.claimed = [];
            }
            if (!achievementsData.notified) {
                achievementsData.notified = [];
            }
            if (typeof achievementsData.totalClaimed === 'undefined') {
                achievementsData.totalClaimed = 0;
            }
            
            let hasNewCompletions = false;
            
            // Check if ACHIEVEMENTS object exists
            if (typeof ACHIEVEMENTS === 'undefined') {
                console.log('ACHIEVEMENTS not defined, skipping check');
                return;
            }
            
            Object.values(ACHIEVEMENTS).forEach(achievement => {
                // Skip if already completed
                if (achievementsData.completed.includes(achievement.id)) return;
                
                // Check if completed now
                if (achievement.check(characterData)) {
                    achievementsData.completed.push(achievement.id);
                    hasNewCompletions = true;
                    
                    // Show notification
                    setTimeout(() => {
                        if (typeof showToast === 'function') {
                            showToast(
                                '🏆 Досягнення виконано!',
                                `${achievement.icon} ${achievement.name}`,
                                'success'
                            );
                        }
                    }, 500);
                }
            });
            
            if (hasNewCompletions) {
                saveGameSync(characterData);
                updateAchievementsBadge();
            }
        }
        
        function getAchievementProgress(achievement, characterData) {
            // Extract target from check function (simplified)
            let current = 0;
            let target = 1;
            
            if (achievement.id.startsWith('wins_')) {
                current = characterData.gameState.totalWins || 0;
                target = parseInt(achievement.id.split('_')[1]);
            } else if (achievement.id.startsWith('trainings_')) {
                current = characterData.gameState.totalTrainings || 0;
                target = parseInt(achievement.id.split('_')[1]);
            } else if (achievement.id.startsWith('money_')) {
                current = characterData.gameState.cash || 0;
                target = parseInt(achievement.id.split('_')[1].replace('k', '000'));
            } else if (achievement.id.startsWith('stat_')) {
                const targetStat = parseInt(achievement.id.split('_')[1]);
                current = Math.max(...characterData.fighters.flatMap(f => [
                    f.stats.power, f.stats.speed, f.stats.stamina, f.stats.defense
                ]));
                target = targetStat;
            } else if (achievement.id === 'second_fighter') {
                current = characterData.fighters.length;
                target = 2;
            } else if (achievement.id === 'daily_7') {
                current = characterData.gameState.dailyRewards?.streak || 0;
                target = 7;
            } else {
                current = achievement.check(characterData) ? 1 : 0;
                target = 1;
            }
            
            return {
                current: Math.min(current, target),
                target: target,
                percentage: Math.min((current / target) * 100, 100)
            };
        }
        
        function claimAchievement(achievementId) {
            hapticHeavy();
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // Initialize achievements if not exists
            if (!gameState.achievements) {
                gameState.achievements = {
                    completed: [],
                    claimed: [],
                    totalClaimed: 0
                };
            }
            
            // Ensure claimed array exists
            if (!gameState.achievements.claimed) {
                gameState.achievements.claimed = [];
            }
            
            // Ensure completed array exists
            if (!gameState.achievements.completed) {
                gameState.achievements.completed = [];
            }
            
            const achievementsData = gameState.achievements;
            const achievement = ACHIEVEMENTS[achievementId];
            
            if (!achievement) {
                console.error('Achievement not found:', achievementId);
                showToast('Помилка!', 'Досягнення не знайдено', 'error');
                return;
            }
            
            // Check if already claimed
            if (achievementsData.claimed.includes(achievementId)) {
                showToast('Вже отримано!', 'error');
                return;
            }
            
            // Check if completed
            if (!achievementsData.completed.includes(achievementId)) {
                showToast('Не виконано!', 'error');
                return;
            }
            
            // Apply reward
            if (achievement.reward.type === 'cash') {
                gameState.cash += achievement.reward.amount;
            } else if (achievement.reward.type === 'stars') {
                gameState.stars += achievement.reward.amount;
            }
            
            // Mark as claimed
            achievementsData.claimed.push(achievementId);
            achievementsData.totalClaimed++;
            
            saveGameSync(characterData);
            
            // Show success
            const rewardText = achievement.reward.type === 'cash' 
                ? `$${achievement.reward.amount}`
                : `⭐${achievement.reward.amount}`;
            
            showToast('🎁 Нагороду отримано!', `${achievement.icon} ${rewardText}`, 'success');
            
            // Reload screen
            setTimeout(() => {
                loadAchievements();
                updateAchievementsBadge();
            }, 500);
        }
        
        function updateAchievementsBadge() {
            try {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                if (!characterData || !characterData.gameState.achievements) return;
                
                const achievementsData = characterData.gameState.achievements;
                const unclaimed = achievementsData.completed.length - achievementsData.claimed.length;
                
                const badge = document.getElementById('achievementsBadge');
                const countEl = document.getElementById('achievementsCount');
                
                if (badge) {
                    badge.style.display = unclaimed > 0 ? 'block' : 'none';
                }
                
                if (countEl) {
                    countEl.textContent = `${achievementsData.claimed.length}/${Object.keys(ACHIEVEMENTS).length}`;
                }
            } catch (error) {
                console.error('Error updating achievements badge:', error);
            }
        }
        
        // ===== END ACHIEVEMENTS SYSTEM =====
        
        // Loading screen - auto show prologue ONLY for new players
        let introTimer = null;
        
        function startIntroSequence() {
            introTimer = setTimeout(() => {
                showPrologue();
            }, 2500);
        }
        
        function cancelIntroSequence() {
            if (introTimer) {
                clearTimeout(introTimer);
                introTimer = null;
                console.log('🚫 Intro sequence cancelled');
            }
        }
        
        function showScreen(screenId) {
            console.log(`🎬 showScreen called: ${screenId}`);
            console.trace('Call stack:'); // Показати звідки викликано
            
            // Haptic feedback
            hapticLight();
            
            // Hide all screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active', 'hiding');
            });
            
            const newScreen = document.getElementById(screenId);
            
            // Reset animations for prologue
            if (screenId === 'prologueScreen') {
                const lines = newScreen.querySelectorAll('.prologue-line');
                lines.forEach(line => {
                    line.classList.remove('fade-in');
                });
            }
            
            // Reset animations for street walk
            if (screenId === 'streetWalkScreen') {
                const lines = newScreen.querySelectorAll('.street-walk-line');
                lines.forEach(line => {
                    line.classList.remove('fade-in');
                });
            }
            
            // Show new screen
            newScreen.classList.add('active');
        }
        
        function showPrologue() {
            showScreen('prologueScreen');
            
            // Cinematic text reveal
            const lines = document.querySelectorAll('.prologue-line');
            const continueBtn = document.getElementById('continueBtn');
            
            lines.forEach((line, index) => {
                setTimeout(() => {
                    line.classList.add('fade-in');
                }, index * 800); // 800ms delay between each line
            });
            
            // Show button after all text
            setTimeout(() => {
                continueBtn.style.animation = 'fadeInButton 1s ease-out forwards';
            }, lines.length * 800 + 500);
        }
        
        function showCharacterCreation() {
            showScreen('characterScreen');
        }
        
        // Check form validity on input
        document.getElementById('managerNameInput').addEventListener('input', checkFormValidity);
        document.getElementById('managerAge').addEventListener('input', checkFormValidity);
        document.getElementById('managerCountry').addEventListener('change', checkFormValidity);
        document.getElementById('managerCity').addEventListener('input', checkFormValidity);
        
        function checkFormValidity() {
            const name = document.getElementById('managerNameInput').value.trim();
            const age = document.getElementById('managerAge').value;
            const country = document.getElementById('managerCountry').value;
            const city = document.getElementById('managerCity').value.trim();
            const startButton = document.getElementById('startButton');
            
            if (name.length >= 2 && age >= 8 && age <= 99 && country && city.length >= 2) {
                startButton.disabled = false;
            } else {
                startButton.disabled = true;
            }
        }
        
        function startGame() {
            const nameInput = document.getElementById('managerNameInput').value.trim();
            const age = document.getElementById('managerAge').value;
            const country = document.getElementById('managerCountry').value;
            const cityInput = document.getElementById('managerCity').value.trim();
            
            // Validate name (must have first and last name)
            const nameParts = nameInput.split(' ').filter(part => part.length > 0);
            if (nameParts.length < 2) {
                alert('❌ Введи Ім\'я та Прізвище через пробіл!\nНаприклад: Іван Петренко');
                return;
            }
            
            const firstName = nameParts[0];
            const lastName = nameParts.slice(1).join(' ');
            
            if (firstName.length < 2 || lastName.length < 2) {
                alert('❌ Ім\'я та Прізвище мають бути довші 2 символів!');
                return;
            }
            
            // Validate city (only letters, spaces, and hyphens)
            const cityRegex = /^[A-Za-zА-Яа-яІіЇїЄєҐґ\s\-']+$/;
            if (!cityRegex.test(cityInput)) {
                alert('❌ Місто може містити тільки літери!\nНаприклад: Київ, Нью-Йорк');
                return;
            }
            
            if (age < 8 || age > 99 || !country || cityInput.length < 2) {
                alert('❌ Будь ласка, заповни всі поля коректно!');
                return;
            }
            
            // Save character data
            const characterData = {
                name: nameInput,
                firstName: firstName,
                lastName: lastName,
                age: parseInt(age),
                country: country,
                city: cityInput,
                createdAt: new Date().toISOString()
            };
            
            // Save to localStorage
            saveGameSync(characterData);
            
            // Send data to Telegram
            tg.sendData(JSON.stringify({
                action: 'character_created',
                data: characterData
            }));
            
            // Show success message
            document.querySelector('.form-container').innerHTML = `
                <div style="text-align: center; padding: 2rem;">
                    <div style="font-family: 'Oswald', sans-serif; font-size: 1.8rem; color: var(--gold); margin-bottom: 1rem;">
                        ${nameInput}
                    </div>
                    <div style="font-size: 1rem; opacity: 0.7; margin-bottom: 0.5rem;">
                        ${age} років
                    </div>
                    <div style="font-size: 1rem; opacity: 0.7; margin-bottom: 2rem;">
                        ${cityInput}, ${country}
                    </div>
                    <div style="font-size: 1.2rem; opacity: 0.8; line-height: 1.8;">
                        Персонаж створено!
                    </div>
                </div>
            `;
            
            // Transition to street walk scene
            setTimeout(() => {
                showStreetWalk();
            }, 2000);
        }
        
        // STREET WALK TRANSITION
        function showStreetWalk() {
            showScreen('streetWalkScreen');
            
            // Cinematic text reveal
            const lines = document.querySelectorAll('.street-walk-line');
            
            lines.forEach((line, index) => {
                setTimeout(() => {
                    line.classList.add('fade-in');
                }, index * 900); // 900ms delay between lines
            });
            
            // Transition to fighter selection after all text
            setTimeout(() => {
                showStreetTournament();
            }, lines.length * 900 + 1500);
        }
        
        // STREET TOURNAMENT
        function showStreetTournament() {
            showScreen('streetScreen');
            generateFighters();
        }
        
        function generateFighters() {
            const firstNames = ['Віктор', 'Іван', 'Максим', 'Олег', 'Дмитро', 'Андрій', 'Сергій', 'Артем'];
            const lastNames = ['Коваль', 'Петренко', 'Сидоров', 'Мельник', 'Шевченко', 'Бойко', 'Ковальчук', 'Гончар'];
            const nicknames = ['Молот', 'Буря', 'Тінь', 'Залізний', 'Вогонь', 'Гром', 'Хижак', 'Ураган'];
            
            // Fighter avatars (different boxer types)
            const avatars = ['🥊', '👊', '💪', '🔥', '⚡', '💥'];
            
            const fighters = [];
            const numFighters = 3; // Generate 3 fighters
            
            for (let i = 0; i < numFighters; i++) {
                // Weighted talent distribution (lower = more common)
                // 3-5: 60% chance (common)
                // 6-7: 30% chance (uncommon)
                // 8-9: 9% chance (rare)
                // 10: 1% chance (legendary)
                let talent;
                const rand = Math.random();
                if (rand < 0.01) {
                    talent = 10; // 1% - legendary
                } else if (rand < 0.10) {
                    talent = Math.random() < 0.5 ? 8 : 9; // 9% - rare
                } else if (rand < 0.40) {
                    talent = Math.random() < 0.5 ? 6 : 7; // 30% - uncommon
                } else {
                    talent = Math.floor(Math.random() * 3) + 3; // 60% - common (3-5)
                }
                
                const age = Math.floor(Math.random() * 8) + 18; // 18-25
                const weight = Math.floor(Math.random() * 20) + 65; // 65-84 kg
                
                // Balanced stats: високий талант = слабші старт (більший потенціал)
                // Талант 10: базові стати ~5-10 (дуже слабкі, але швидко качаються)
                // Талант 5: базові стати ~15-20 (середні)
                // Талант 2: базові стати ~20-25 (сильніші старт, але повільно качаються)
                const baseStats = 30 - (talent * 2); // Чим більший талант, тим слабші старт
                const variance = 5;
                
                fighters.push({
                    id: i,
                    firstName: firstNames[Math.floor(Math.random() * firstNames.length)],
                    lastName: lastNames[Math.floor(Math.random() * lastNames.length)],
                    nickname: nicknames[Math.floor(Math.random() * nicknames.length)],
                    avatar: avatars[Math.floor(Math.random() * avatars.length)],
                    age: age,
                    weight: weight,
                    talent: talent,
                    stats: {
                        power: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance))),
                        speed: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance))),
                        stamina: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance))),
                        defense: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance)))
                    }
                });
            }
            
            renderFighters(fighters);
        }
        
        let selectedFighterData = null;
        let generatedOpponents = []; // Store opponents globally
        
        function renderFighters(fighters) {
            const grid = document.getElementById('fightersGrid');
            grid.innerHTML = '';
            
            fighters.forEach(fighter => {
                const talentBonus = getTalentBonus(fighter.talent);
                const card = document.createElement('div');
                card.className = 'fighter-card';
                card.onclick = () => selectFighter(fighter);
                
                card.innerHTML = `
                    <div class="fighter-avatar">${fighter.avatar}</div>
                    <div class="fighter-header">
                        <div>
                            <div class="fighter-name">${fighter.firstName} "${fighter.nickname}" ${fighter.lastName}</div>
                            <div class="fighter-nickname">Вуличний боєць</div>
                        </div>
                        <div class="talent-badge">
                            🔥 ${fighter.talent}
                        </div>
                    </div>
                    
                    <div class="fighter-basics">
                        <span>📅 ${fighter.age} років</span>
                        <span>⚖️ ${fighter.weight} кг</span>
                    </div>
                    
                    <div class="fighter-stats">
                        <div>
                            <div class="stat-item">
                                <span class="stat-label">Сила</span>
                                <span class="stat-value">${fighter.stats.power}</span>
                            </div>
                            <div class="stat-bar">
                                <div class="stat-fill" style="width: ${fighter.stats.power}%"></div>
                            </div>
                        </div>
                        
                        <div>
                            <div class="stat-item">
                                <span class="stat-label">Швидкість</span>
                                <span class="stat-value">${fighter.stats.speed}</span>
                            </div>
                            <div class="stat-bar">
                                <div class="stat-fill" style="width: ${fighter.stats.speed}%"></div>
                            </div>
                        </div>
                        
                        <div>
                            <div class="stat-item">
                                <span class="stat-label">Витривалість</span>
                                <span class="stat-value">${fighter.stats.stamina}</span>
                            </div>
                            <div class="stat-bar">
                                <div class="stat-fill" style="width: ${fighter.stats.stamina}%"></div>
                            </div>
                        </div>
                        
                        <div>
                            <div class="stat-item">
                                <span class="stat-label">Захист</span>
                                <span class="stat-value">${fighter.stats.defense}</span>
                            </div>
                            <div class="stat-bar">
                                <div class="stat-fill" style="width: ${fighter.stats.defense}%"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="talent-description">
                        Талант дає <span class="talent-bonus">+${talentBonus}%</span> до росту всіх характеристик
                    </div>
                `;
                
                grid.appendChild(card);
            });
        }
        
        function getTalentBonus(talent) {
            // Calculate bonus based on talent level
            if (talent <= 3) return 10;
            if (talent <= 5) return 25;
            if (talent <= 7) return 45;
            if (talent <= 9) return 70;
            return 100; // talent 10
        }
        
        function selectFighter(fighter) {
            console.log('selectFighter called with:', fighter);
            selectedFighterData = fighter;
            
            // Show confirmation modal
            const modal = document.getElementById('confirmModal');
            console.log('Modal element:', modal);
            
            document.getElementById('modalAvatar').textContent = fighter.avatar;
            document.getElementById('modalFighterName').textContent = 
                `${fighter.firstName} "${fighter.nickname}" ${fighter.lastName}`;
            
            modal.classList.add('active');
            console.log('Modal classList after add:', modal.classList);
        }
        
        function closeModal() {
            document.getElementById('confirmModal').classList.remove('active');
            selectedFighterData = null;
        }
        
        function confirmFighterSelection() {
            if (!selectedFighterData) return;
            
            const fighter = selectedFighterData;
            
            // Initialize gameData for the fighter
            fighter.gameData = {
                record: { wins: 0, losses: 0, draws: 0 },
                rating: 0, // Start at 0, no limit
                form: 100,
                experience: 0
            };
            
            // Initialize fightHistory
            fighter.fightHistory = [];
            
            // Save selected fighter
            let characterData = loadGameSync();
            
            // Якщо немає даних (перший запуск) - створити новий об'єкт
            if (!characterData) {
                console.log('⚠️ No character data found - creating new');
                characterData = {
                    name: 'Новий гравець',
                    createdAt: new Date().toISOString()
                };
            }
            
            // Initialize fighters array and gameState
            characterData.fighters = [fighter];
            characterData.activeFighterIndex = 0;
            characterData.unlockedSlots = 1;
            
            // Welcome VIP bonus - 3 days for new players
            const vipEndTime = Date.now() + (3 * 24 * 60 * 60 * 1000); // 3 дні
            
            characterData.gameState = {
                cash: 2000,        // Зменшено з 5000
                stars: 50,         // Додано стартові зірки
                totalWins: 0,
                totalTrainings: 0,
                hardWins: 0,
                winStreak: 0,
                dailyStreak: 0,
                vipUntil: vipEndTime,  // VIP на 3 дні
                isNewPlayer: true       // Прапорець нового гравця
            };
            characterData.achievements = {};
            characterData.team = { members: {}, monthlyCost: 0 };
            
            // КРИТИЧНО: Очистити кеш перед збереженням!
            cachedCharacterData = null;
            cacheTimestamp = 0;
            lastSaveHash = null;
            
            console.log('=== SAVING NEW CHARACTER ===');
            console.log('Name:', characterData.name);
            console.log('Fighters:', characterData.fighters?.length);
            console.log('Cash:', characterData.gameState?.cash);
            console.log('Stars:', characterData.gameState?.stars);
            console.log('VIP until:', new Date(characterData.gameState?.vipUntil).toLocaleString('uk-UA'));
            
            // IMPORTANT: Save to localStorage
            saveGameSync(characterData, true); // IMMEDIATE save!
            
            console.log('✅ Character data saved:', characterData);
            console.log('🎁 VIP bonus activated until:', new Date(vipEndTime).toLocaleString('uk-UA'));
            
            // Send to Telegram
            tg.sendData(JSON.stringify({
                action: 'fighter_selected',
                data: fighter
            }));
            
            // Close modal
            closeModal();
            
            // Transition to main game
            setTimeout(() => {
                showMainGame();
            }, 2000);
        }
        
        // MAIN GAME SCREEN
        function showMainGame() {
            showScreen('gameScreen');
            loadGameData();
            
            // Show VIP welcome bonus for new players
            setTimeout(() => {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                if (characterData && characterData.gameState && characterData.gameState.isNewPlayer) {
                    const daysLeft = Math.ceil((characterData.gameState.vipUntil - Date.now()) / (24 * 60 * 60 * 1000));
                    
                    console.log('🎁 Showing welcome bonus toast...');
                    
                    showToast(
                        '🎁 Вітальний бонус!',
                        `VIP статус на ${daysLeft} дні\n💰 $2,000 грошей\n⭐ 50 зірок\n\nПриємної гри!`,
                        'success'
                    );
                    
                    // Mark as shown
                    characterData.gameState.isNewPlayer = false;
                    saveGameSync(characterData);
                } else {
                    console.log('ℹ️ No welcome bonus (not new player or data missing)');
                }
            }, 1500);
        }
        
        async function loadGameData() {
            console.log('=== loadGameData started ===');
            
            // Спочатку спробувати завантажити з Cloud/Local
            showLoading();
            const loadResult = await loadGame();
            
            console.log('loadGame result:', loadResult);
            
            let characterData;
            
            // loadGame повертає {data: ..., source: 'cloud'/'local'/'none'}
            if (loadResult && loadResult.data) {
                characterData = loadResult.data;
                console.log(`✅ Loaded from ${loadResult.source}`);
            } else {
                // Fallback на direct localStorage read
                const localData = localStorage.getItem('boxingManager_character');
                if (localData) {
                    try {
                        characterData = JSON.parse(localData);
                        console.log('📦 Loaded from localStorage (direct)');
                    } catch (e) {
                        console.error('Failed to parse localStorage:', e);
                    }
                }
            }
            
            hideLoading();
            
            if (!characterData) {
                console.log('⚠️ No character data - redirecting to intro');
                startIntroSequence();
                return;
            }
            
            console.log('✅ Character data loaded:', characterData);
            console.log('   - Name:', characterData.name);
            console.log('   - Fighters:', characterData.fighters?.length);
            console.log('   - Cash:', characterData.gameState?.cash);
            console.log('   - Stars:', characterData.gameState?.stars);
            
            // Initialize fighters array (migrate old data) - DO THIS FIRST!
            if (!characterData.fighters) {
                if (!characterData.fighter) {
                    alert('Помилка завантаження даних!');
                    return;
                }
                characterData.fighters = [characterData.fighter];
                characterData.activeFighterIndex = 0;
                characterData.unlockedSlots = 1;
                saveGameSync(characterData);
            }
            
            console.log('Before initializeAgingSystem');
            // Initialize and check aging system
            initializeAgingSystem();
            
            console.log('Before initializeDailyRewards');
            // Initialize daily rewards
            initializeDailyRewards();
            
            // Initialize achievements
            initializeAchievements();
            
            console.log('After daily rewards init');
            
            // ЗАХИСТ: якщо немає бійців - показати попередження
            if (characterData.fighters.length === 0) {
                console.warn('⚠️ No fighters available!');
                showToast('⚠️ Немає бійців!', 'Купи нового в Академії', 'warning');
                // Продовжити завантаження але без активного бійця
            }
            
            // Check if active fighter is retired (тільки якщо є бійці)
            if (characterData.fighters.length > 0) {
                const activeFighter = characterData.fighters[characterData.activeFighterIndex];
                if (activeFighter && activeFighter.retired) {
                    alert('⚠️ Твій активний боксер завершив кар\'єру!\n\nОбери іншого боксера або найми нового в Академії.');
                }
            }
            
            // Initialize game state if not exists OR migrate old format
            if (!characterData.gameState) {
                console.log('⚠️ No gameState - creating new');
                characterData.gameState = {
                    cash: 2000,
                    stars: 50,
                    totalFighters: characterData.fighters.length,
                    totalWins: 0,
                    totalTrainings: 0,
                    hardWins: 0,
                    winStreak: 0,
                    dailyStreak: 0,
                    vipUntil: 0
                };
                saveGameSync(characterData, true); // Immediate save
            }
            
            const gameState = characterData.gameState;
            
            // БЕЗПЕКА: Перевірка обов'язкових полів
            if (typeof gameState.cash === 'undefined') {
                console.warn('⚠️ Missing cash - setting to 2000');
                gameState.cash = 2000;
            }
            if (typeof gameState.stars === 'undefined') {
                console.warn('⚠️ Missing stars - setting to 50');
                gameState.stars = 50;
            }
            
            console.log('💰 GameState verified:', {
                cash: gameState.cash,
                stars: gameState.stars,
                vipUntil: gameState.vipUntil
            });
            
            // Migrate old VIP format to new
            if (gameState.isVIP && gameState.vipEndTime) {
                gameState.vipUntil = gameState.vipEndTime;
                delete gameState.isVIP;
                delete gameState.vipEndTime;
                saveGameSync(characterData);
            }
            
            // Initialize VIP fields if missing
            if (gameState.vipUntil === undefined) {
                gameState.vipUntil = 0;
                saveGameSync(characterData);
            }
            
            if (gameState.isNewPlayer === undefined) {
                gameState.isNewPlayer = false;
                saveGameSync(characterData);
            }
            
            // Update MANAGER profile
            document.getElementById('managerAvatar').textContent = '👔';
            
            // FORCE update name (з перевіркою)
            const nameElement = document.getElementById('managerName');
            if (nameElement) {
                nameElement.textContent = characterData.name;
                console.log('✅ Manager profile updated:', characterData.name);
                console.log('   Name element current text:', nameElement.textContent);
            } else {
                console.error('❌ managerName element not found in loadGameData!');
            }
            
            // Manager level видалено - не використовується
            document.getElementById('managerLocation').textContent = `${characterData.city}, ${characterData.country}`;
            
            // Update VIP star and status
            const vipStar = document.getElementById('vipStar');
            const vipStatus = document.getElementById('vipStatus');
            
            if (gameState.vipUntil && gameState.vipUntil > Date.now()) {
                // VIP is active
                vipStar.classList.add('active');
                vipStatus.style.display = 'block';
                
                // Calculate remaining time
                const remaining = gameState.vipUntil - Date.now();
                const days = Math.floor(remaining / (24 * 60 * 60 * 1000));
                const hours = Math.floor((remaining % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
                
                if (days > 0) {
                    vipStatus.textContent = `💎 VIP: ${days} дн ${hours} год`;
                } else {
                    vipStatus.textContent = `💎 VIP: ${hours} год`;
                }
            } else {
                // VIP is inactive
                vipStar.classList.remove('active');
                vipStatus.style.display = 'none';
                
                // Clean up expired VIP
                if (gameState.vipEndTime && gameState.vipEndTime <= Date.now()) {
                    gameState.isVIP = false;
                    delete gameState.vipEndTime;
                    saveGameSync(characterData);
                }
            }
            
            // Update manager stats
            document.getElementById('managerFighters').textContent = characterData.fighters.filter(f => !f.retired).length;
            document.getElementById('managerWins').textContent = gameState.totalWins;
            
            // Render fighters list
            renderFightersList();
            
            // Update resources - БЕЗПЕЧНА ПЕРЕВІРКА
            let currentRating = 0;
            if (characterData.fighters.length > 0) {
                const activeFighter = characterData.fighters[characterData.activeFighterIndex];
                currentRating = (activeFighter && activeFighter.gameData && activeFighter.gameData.rating) || 0;
            }
            
            document.getElementById('resourceCash').textContent = formatNumber(gameState.cash);
            document.getElementById('resourceStars').textContent = gameState.stars;
            document.getElementById('resourceRating').textContent = currentRating;
            
            console.log('✅ Resources updated:', {
                cash: gameState.cash,
                stars: gameState.stars,
                rating: currentRating
            });
            
            // Update Cloud status
            updateCloudStatus();
            
            // Update daily rewards badge (after DOM is ready)
            setTimeout(() => {
                updateDailyBadge();
                updateAchievementsBadge();
                startInjuryTimer(); // Start injury timer update
            }, 100);
            
            console.log('loadGameData completed');
        }
        
        // Injury timer - updates every second
        let injuryTimerInterval = null;
        
        function startInjuryTimer() {
            // Clear existing timer
            if (injuryTimerInterval) {
                clearInterval(injuryTimerInterval);
            }
            
            // Update immediately
            updateInjuryTimers();
            
            // Then update every second
            injuryTimerInterval = setInterval(() => {
                updateInjuryTimers();
            }, 1000);
        }
        
        function updateInjuryTimers() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            if (!characterData || !characterData.fighters) return;
            
            characterData.fighters.forEach((fighter, index) => {
                if (!fighter || !fighter.injury) return;
                
                const remainingTime = fighter.injury.healTime - Date.now();
                
                if (remainingTime <= 0) {
                    // Injury healed!
                    delete fighter.injury;
                    saveGameSync(characterData);
                    showToast(`${fighter.firstName} вилікувався! 💚`, 'success');
                    renderFightersList();
                } else {
                    // Update time display
                    const banners = document.querySelectorAll('.injury-status-banner');
                    banners.forEach(banner => {
                        const timeElement = banner.querySelector('.injury-status-time');
                        if (timeElement) {
                            timeElement.textContent = `⏰ Відновлення: ${formatInjuryTime(remainingTime)}`;
                        }
                    });
                }
            });
        }
        
        function renderFightersList() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fightersList = document.getElementById('fightersList');
            fightersList.innerHTML = '';
            
            const maxSlots = 2;
            const unlockedSlots = characterData.unlockedSlots || 1;
            
            // Render unlocked slots with fighters
            for (let i = 0; i < unlockedSlots; i++) {
                const fighter = characterData.fighters[i];
                if (fighter) {
                    fightersList.appendChild(createFighterCard(fighter, i, characterData.activeFighterIndex === i));
                }
            }
            
            // Render locked slots
            for (let i = unlockedSlots; i < maxSlots; i++) {
                fightersList.appendChild(createLockedSlotCard(i));
            }
        }
        
        function createFighterCard(fighter, index, isActive) {
            const card = document.createElement('div');
            card.className = 'fighter-slot' + (isActive ? ' active' : '');
            card.onclick = () => switchActiveFighter(index);
            
            // Initialize talent if missing (for old fighters)
            if (!fighter.talent) {
                fighter.talent = Math.floor(Math.random() * 8) + 3; // 3-10
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                saveGameSync(characterData);
            }
            
            if (!fighter.gameData) {
                fighter.gameData = {
                    rating: 1000,
                    form: calculateFormByAge(fighter.age),
                    record: { wins: 0, losses: 0, draws: 0 }
                };
            }
            
            card.innerHTML = `
                <div class="fighter-card-main" style="padding: 0; margin: 0; background: transparent; border: none;">
                    <div class="fighter-card-header">
                        <div class="fighter-card-avatar">${fighter.avatar}</div>
                        <div class="fighter-card-info">
                            <div class="fighter-card-name">${fighter.firstName} "${fighter.nickname}"</div>
                            <div class="fighter-card-stats">
                                <span>${fighter.age} років</span>
                                <span>${fighter.weight} кг</span>
                                <span title="Талант дає +${getTalentBonus(fighter.talent)}% до тренувань">🔥 ${fighter.talent}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="fighter-quick-stats">
                        <div class="fighter-quick-stat">
                            <div class="fighter-quick-stat-label">Оверол</div>
                            <div class="fighter-quick-stat-value">${Math.round((fighter.stats.power + fighter.stats.speed + fighter.stats.stamina + fighter.stats.defense) / 4)}</div>
                        </div>
                        <div class="fighter-quick-stat">
                            <div class="fighter-quick-stat-label">Форма</div>
                            <div class="fighter-quick-stat-value">${fighter.gameData.form}%</div>
                        </div>
                        <div class="fighter-quick-stat">
                            <div class="fighter-quick-stat-label">Рекорд</div>
                            <div class="fighter-quick-stat-value">${fighter.gameData.record.wins}-${fighter.gameData.record.losses}-${fighter.gameData.record.draws}</div>
                        </div>
                    </div>
                    
                    ${fighter.injury && fighter.injury.healTime > Date.now() ? `
                        <div class="injury-status-banner" onclick="event.stopPropagation(); openTreatmentModal();">
                            <div class="injury-status-header">
                                <div class="injury-status-name">${fighter.injury.name}</div>
                                <div class="injury-status-severity">${
                                    fighter.injury.severity === 'light' ? 'Легка' :
                                    fighter.injury.severity === 'medium' ? 'Середня' :
                                    fighter.injury.severity === 'heavy' ? 'Важка' : 'Критична'
                                }</div>
                            </div>
                            <div class="injury-status-time">
                                ⏰ Відновлення: ${formatInjuryTime(fighter.injury.healTime - Date.now())}
                            </div>
                            <div class="injury-status-action">
                                👉 Натисни для лікування
                            </div>
                        </div>
                    ` : ''}
                    
                    <div style="background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); border-radius: 8px; padding: 0.8rem; margin: 1rem 0; text-align: center;">
                        <div style="color: rgba(255,255,255,0.7); font-size: 0.85rem; margin-bottom: 0.3rem;">
                            💰 Ціна бійця
                        </div>
                        <div style="color: var(--gold); font-size: 1.3rem; font-weight: 700;">
                            $${formatNumber(calculateFighterPrice(fighter))}
                        </div>
                    </div>
                    
                    ${isActive ? `
                        <div class="fighter-card-actions">
                            <button class="fighter-card-btn primary" onclick="event.stopPropagation(); openTraining()">
                                🏋️ Тренувати
                            </button>
                            <button class="fighter-card-btn" onclick="event.stopPropagation(); openFights()">
                                🥊 Бої
                            </button>
                        </div>
                        <div class="fighter-card-actions" style="margin-top: 0.5rem;">
                            <button class="fighter-card-btn" onclick="event.stopPropagation(); openFighterDetails()">
                                📊 Статистика
                            </button>
                            <button class="fighter-card-btn" onclick="event.stopPropagation(); openSellFighterModal(${index})" 
                                    style="background: linear-gradient(135deg, #dc2626, #b91c1c); color: white;">
                                💵 Продати
                            </button>
                        </div>
                    ` : `
                        <div style="text-align: center; padding: 0.5rem; opacity: 0.6; font-size: 0.85rem;">
                            Натисни щоб зробити активним
                        </div>
                    `}
                </div>
            `;
            
            return card;
        }
        
        function createLockedSlotCard(index) {
            const card = document.createElement('div');
            card.className = 'fighter-slot locked';
            card.id = `lockedSlot${index}`;
            
            card.innerHTML = `
                <div class="slot-locked-content collapsed" id="slotContent${index}">
                    <div class="slot-locked-header" onclick="toggleLockedSlot(${index})">
                        <div class="slot-locked-header-left">
                            <div class="slot-locked-icon">🔒</div>
                            <div class="slot-locked-title">Додатковий слот</div>
                        </div>
                        <div class="slot-expand-icon" id="expandIcon${index}">▼</div>
                    </div>
                    
                    <div class="slot-locked-details" id="slotDetails${index}">
                        <div class="slot-locked-desc">
                            <strong>Як працює:</strong><br>
                            1️⃣ Розблокуй слот (⭐ 100)<br>
                            2️⃣ Йди в 🎓 Академію<br>
                            3️⃣ Найми другого бійця<br><br>
                            <strong>Переваги:</strong><br>
                            • Більше боїв і заробітку<br>
                            • Страховка від старіння<br>
                            • Гнучкі стратегії
                        </div>
                        <button class="slot-unlock-button" onclick="event.stopPropagation(); unlockFighterSlot()">
                            РОЗБЛОКУВАТИ ⭐ 100
                        </button>
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function toggleLockedSlot(index) {
            const content = document.getElementById(`slotContent${index}`);
            const details = document.getElementById(`slotDetails${index}`);
            const icon = document.getElementById(`expandIcon${index}`);
            
            content.classList.toggle('collapsed');
            details.classList.toggle('expanded');
            icon.classList.toggle('expanded');
        }
        
        function switchActiveFighter(index) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            
            if (characterData.fighters[index].retired) {
                alert('⚠️ Цей боксер завершив кар\'єру!\n\nОбери іншого або найми нового в Академії.');
                return;
            }
            
            characterData.activeFighterIndex = index;
            saveGameSync(characterData);
            
            renderFightersList();
        }
        
        function unlockFighterSlot() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // Check if enough stars
            if (gameState.stars < 100) {
                showToast('Недостатньо Stars!', `Потрібно: ⭐ 100\nУ тебе: ⭐ ${gameState.stars}`, 'error');
                return;
            }
            
            // Check if already unlocked
            if (characterData.unlockedSlots >= 2) {
                showToast('Всі слоти розблоковані!', '', 'info');
                return;
            }
            
            // Deduct stars
            gameState.stars -= 100;
            characterData.unlockedSlots = 2;
            
            saveGameSync(characterData);
            
            showToast('🎉 Слот розблоковано!', '👇 Зараз відкриється Академія!\nОбери бійця на вкладці "🌟 Новачки" або "💼 Досвідчені"', 'success');
            
            loadGameData();
            
            // Automatically open Academy after 2 seconds
            setTimeout(() => {
                openAcademy();
            }, 2500);
        }
        
        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }
        
        // Action handlers
        function openTraining() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            
            // ЗАХИСТ: перевірка наявності бійців
            if (!characterData.fighters || characterData.fighters.length === 0) {
                alert('⚠️ Немає бійців!\n\nКупи нового боксера в Академії.');
                openAcademy();
                return;
            }
            
            const activeFighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (!activeFighter || activeFighter.retired) {
                alert('⚠️ Немає активного боксера!\n\nОбери боксера або найми нового в Академії.');
                return;
            }
            
            showScreen('trainingScreen');
            loadTrainingScreen();
        }
        
        async function backToGame() {
            showScreen('gameScreen');
            await loadGameData();
        }
        
        function updateResourceBar() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // ЗАХИСТ: перевірка наявності бійців
            let currentRating = 0;
            if (characterData.fighters && characterData.fighters.length > 0) {
                const activeFighter = characterData.fighters[characterData.activeFighterIndex];
                currentRating = (activeFighter && activeFighter.gameData && activeFighter.gameData.rating) || 0;
            }
            
            document.getElementById('resourceCash').textContent = formatNumber(gameState.cash);
            document.getElementById('resourceStars').textContent = gameState.stars;
            document.getElementById('resourceRating').textContent = currentRating;
        }
        
        // TRAINING SYSTEM - updated to work with active fighter
        
        
        // ========================================
        // RANKING SYSTEM WITH CHAMPIONSHIP BELTS
        // ========================================
        
        // RANKING TIERS
        const RANKING_TIERS = [
            {
                id: 'beginner',
                name: 'Новачок',
                number: 1,         // Додано для розрахунку нагород
                minRating: 0,
                maxRating: 99,
                icon: '🥉',
                color: '#cd7f32',
                opponents: 3,
                // Fixed stat ranges for opponents - doesn't scale with player!
                opponentStats: {
                    easy: { min: 40, max: 60 },    // Легкий
                    medium: { min: 60, max: 80 },  // Рівний
                    hard: { min: 80, max: 100 }    // Важкий
                }
            },
            {
                id: 'amateur',
                name: 'Аматор',
                number: 2,         // Додано для розрахунку нагород
                minRating: 100,
                maxRating: 299,
                icon: '🥈',
                color: '#c0c0c0',
                opponents: 3,
                opponentStats: {
                    easy: { min: 100, max: 130 },
                    medium: { min: 130, max: 160 },
                    hard: { min: 160, max: 200 }
                }
            },
            {
                id: 'professional',
                name: 'Професіонал',
                number: 3,         // Додано для розрахунку нагород
                minRating: 300,
                maxRating: 599,
                icon: '🥇',
                color: '#ffd700',
                opponents: 4,
                opponentStats: {
                    easy: { min: 200, max: 250 },
                    medium: { min: 250, max: 300 },
                    hard: { min: 300, max: 370 }
                }
            },
            {
                id: 'contender',
                name: 'Претендент',
                number: 4,         // Додано для розрахунку нагород
                minRating: 600,
                maxRating: 999,
                icon: '⭐',
                color: '#ff6b6b',
                opponents: 4,
                opponentStats: {
                    easy: { min: 370, max: 450 },
                    medium: { min: 450, max: 530 },
                    hard: { min: 530, max: 620 }
                }
            },
            {
                id: 'champion',
                name: 'Чемпіон',
                number: 5,         // Додано для розрахунку нагород
                minRating: 1000,
                maxRating: 9999,
                icon: '👑',
                color: '#9b59b6',
                opponents: 5,
                opponentStats: {
                    easy: { min: 620, max: 720 },
                    medium: { min: 720, max: 820 },
                    hard: { min: 820, max: 1000 }
                }
            }
        ];

        // CHAMPIONSHIP BELTS
// ========================================
// RANDOM EVENTS SYSTEM
// ========================================

const RANDOM_EVENTS = {
    // POSITIVE EVENTS
    interview: {
        id: 'interview',
        type: 'positive',
        title: '📰 Запрошення на інтерв\'ю',
        description: 'Спортивний журнал хоче взяти у тебе інтерв\'ю. Це підніме твою репутацію!',
        icon: '📰',
        rarity: 'common', // common, rare, epic, legendary
        choices: [
            {
                text: '✅ Погодитись',
                effects: {
                    time: 2 // hours
                },
                result: '📰 Інтерв\'ю пройшло чудово! +300 репутації'
            },
            {
                text: '❌ Відмовитись',
                effects: {},
                result: 'Ти відмовився від інтерв\'ю'
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 100; // Only if rating 100+
        }
    },
    
    commercial: {
        id: 'commercial',
        type: 'positive',
        title: '🎥 Зйомка реклами',
        description: 'Спортивний бренд пропонує знятися в рекламі їхніх товарів. Непогані гроші!',
        icon: '🎥',
        rarity: 'rare',
        choices: [
            {
                text: '💰 Зняться ($8,000)',
                effects: {
                    cash: 8000,
                    time: 4
                },
                result: '🎥 Реклама вийшла чудовою! +$8,000'
            },
            {
                text: '❌ Відмовитись',
                effects: {},
                result: 'Ти відмовився від реклами'
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 300 && fighter.gameData.record.wins >= 10;
        }
    },
    
    charity: {
        id: 'charity',
        type: 'positive',
        title: '🎪 Благодійний бій',
        description: 'Організатори пропонують провести благодійний бій. Грошей не буде, але репутація зросте!',
        icon: '🎪',
        rarity: 'common',
        choices: [
            {
                text: '❤️ Погодитись',
                effects: {
                    time: 3
                },
                result: '❤️ Благодійний бій пройшов успішно! +1,000 репутації'
            },
            {
                text: '💰 Відмовитись',
                effects: {
                },
                result: '💰 Ти відмовився. Деякі фани розчаровані (-200 REP)'
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 200;
        }
    },
    
    birthday: {
        id: 'birthday',
        type: 'positive',
        title: '🎉 День народження!',
        description: 'Сьогодні твій день народження! Ти відчуваєш прилив сил і мотивації.',
        icon: '🎉',
        rarity: 'epic',
        choices: [
            {
                text: '🎂 Відсвяткувати',
                effects: {
                    powerBonus: 5,
                    speedBonus: 5,
                    staminaBonus: 5,
                    defenseBonus: 5,
                    formBonus: 10,
                    duration: 7 // days
                },
                result: '🎉 Чудове свято! +5 до всіх статів на тиждень!'
            }
        ],
        condition: (data) => {
            // Check if birthday already happened this year (game year = 365 days of events)
            if (!data.gameState.eventHistory) data.gameState.eventHistory = {};
            const lastBirthday = data.gameState.eventHistory.birthday || 0;
            const daysSinceLastBirthday = (Date.now() - lastBirthday) / (24 * 60 * 60 * 1000);
            return daysSinceLastBirthday > 365 || lastBirthday === 0; // Once per game year
        }
    },
    
    sponsorship: {
        id: 'sponsorship',
        type: 'positive',
        title: '💼 Спонсорська пропозиція',
        description: 'Великий спортивний бренд пропонує спонсорський контракт!',
        icon: '💼',
        rarity: 'epic',
        choices: [
            {
                text: '✅ Підписати контракт',
                effects: {
                    cash: 25000,
                    sponsor: {
                        name: 'SportTech',
                        duration: 30, // days
                        bonus: 0.15 // +15% cash from fights
                    }
                },
                result: '💼 Контракт підписано! +$25,000 + 15% до заробітку з боїв на місяць'
            },
            {
                text: '❌ Відхилити',
                effects: {},
                result: 'Ти відхилив пропозицію'
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 500 && fighter.gameData.record.wins >= 20;
        }
    },
    
    // NEGATIVE EVENTS
    scandal: {
        id: 'scandal',
        type: 'negative',
        title: '⚠️ Скандал у пресі',
        description: 'Таблоїди опублікували компрометуючу статтю про тебе. Потрібно реагувати!',
        icon: '⚠️',
        rarity: 'rare',
        choices: [
            {
                text: '📢 Публічні вибачення',
                effects: {
                    cash: -5000
                },
                result: '📢 Вибачення допомогли. Втрачено $5,000 та 500 REP'
            },
            {
                text: '⚖️ Судитись ($10,000)',
                effects: {
                    cash: -10000,
                },
                result: '⚖️ Суд виграно! Репутацію відновлено (+200), але витрачено $10,000'
            },
            {
                text: '🤐 Ігнорувати',
                effects: {
                },
                result: '🤐 Мовчання сприйняли як згоду. -1,500 репутації'
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 300;
        }
    },
    
    injury_risk: {
        id: 'injury_risk',
        type: 'negative',
        title: '🏥 Біль у плечі',
        description: 'Під час тренування відчув біль у плечі. Можливо, варто показатися лікарю?',
        icon: '🏥',
        rarity: 'common',
        choices: [
            {
                text: '🏥 Піти до лікаря ($2,000)',
                effects: {
                    cash: -2000
                },
                result: '🏥 Лікар сказав що все нормально. Краще перестрахуватися!'
            },
            {
                text: '💪 Продовжувати тренуватись',
                effects: {
                    injuryRisk: 0.3 // 30% chance of injury
                },
                result: '💪 Ти вирішив продовжувати...'
            }
        ],
        condition: (data) => true
    },
    
    doping_offer: {
        id: 'doping_offer',
        type: 'negative',
        title: '💊 Сумнівна пропозиція',
        description: 'Хтось пропонує "чудодійні добавки" для швидкого росту статів. Виглядає підозріло...',
        icon: '💊',
        rarity: 'rare',
        choices: [
            {
                text: '✅ Спробувати',
                effects: {
                    powerBonus: 15,
                    speedBonus: 15,
                    staminaBonus: 15,
                    defenseBonus: 15,
                    duration: 14,
                    dopingFlag: true // Will cause issues later
                },
                result: '💊 Стати різко виросли! +15 до всього на 2 тижні. Але що буде далі?'
            },
            {
                text: '❌ Відмовитись',
                effects: {
                },
                result: '✅ Ти вибрав чесний шлях. +100 репутації'
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 400;
        }
    },
    
    doping_test: {
        id: 'doping_test',
        type: 'negative',
        title: '🔬 Допінг-контроль',
        description: 'Раптовий допінг-тест! Якщо використовував заборонені речовини - будуть проблеми.',
        icon: '🔬',
        rarity: 'epic',
        choices: [
            {
                text: '🧪 Пройти тест',
                effects: {
                    dopingTest: true
                },
                result: '🧪 Проходиш тест...'
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 500;
        }
    },
    
    // NEUTRAL EVENTS
    tv_show: {
        id: 'tv_show',
        type: 'neutral',
        title: '📱 Запрошення на ТВ-шоу',
        description: 'Популярне ТВ-шоу запрошує тебе в якості гостя. Шоу дивляться мільйони!',
        icon: '📱',
        rarity: 'rare',
        choices: [
            {
                text: '😄 Бути жартівливим',
                effects: {
                    cash: 3000
                },
                result: '😄 Публіка тебе полюбила! +500 REP, +$3,000'
            },
            {
                text: '😠 Бути провокативним',
                effects: {
                    cash: 5000,
                    hypeBonus: 1.5 // Next fight gets 1.5x attention
                },
                result: '😠 Скандал! -300 REP, але наступний бій буде хайповим (+50% гроші)'
            },
            {
                text: '😐 Бути нейтральним',
                effects: {
                    cash: 2000
                },
                result: '😐 Нормальний ефір. +100 REP, +$2,000'
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 400;
        }
    },
    
    marathon: {
        id: 'marathon',
        type: 'neutral',
        title: '🏃 Благодійний марафон',
        description: 'В місті проходить благодійний марафон. Участь допоможе підняти витривалість!',
        icon: '🏃',
        rarity: 'common',
        choices: [
            {
                text: '🏃 Пробігти марафон',
                effects: {
                    staminaBonus: 8,
                    time: 4
                },
                result: '🏃 Марафон завершено! +8 витривалість, +200 REP'
            },
            {
                text: '❌ Пропустити',
                effects: {},
                result: 'Ти пропустив марафон'
            }
        ],
        condition: (data) => true
    },
    
    sparring_offer: {
        id: 'sparring_offer',
        type: 'neutral',
        title: '🥊 Пропозиція спарингу',
        description: 'Відомий боксер пропонує провести спаринг. Це хороший досвід, але є ризик травми.',
        icon: '🥊',
        rarity: 'rare',
        choices: [
            {
                text: '✅ Погодитись',
                effects: {
                    powerBonus: 5,
                    speedBonus: 5,
                    injuryRisk: 0.2 // 20% injury risk
                },
                result: '🥊 Чудовий спаринг! +5 сила, +5 швидкість, +300 REP'
            },
            {
                text: '❌ Відмовитись',
                effects: {},
                result: 'Ти відмовився від спарингу'
            }
        ],
        condition: (data) => {
            const fighter = data.fighters[data.activeFighterIndex];
            return fighter.gameData.rating >= 200;
        }
    }
};

// Event rarity chances
const EVENT_RARITY_CHANCES = {
    common: 0.50,    // 50%
    rare: 0.30,      // 30%
    epic: 0.15,      // 15%
    legendary: 0.05  // 5%
};

// Check if event should trigger
function shouldTriggerEvent() {
    // Base 15% chance per action (fight, training, etc)
    return Math.random() < 0.15;
}

// Get random event based on rarity
function getRandomEvent(characterData) {
    // Determine rarity first
    const rand = Math.random();
    let targetRarity;
    
    if (rand < 0.05) targetRarity = 'legendary';
    else if (rand < 0.20) targetRarity = 'epic';
    else if (rand < 0.50) targetRarity = 'rare';
    else targetRarity = 'common';
    
    // Get all events of that rarity that meet conditions
    const availableEvents = Object.values(RANDOM_EVENTS).filter(event => {
        return event.rarity === targetRarity && 
               (!event.condition || event.condition(characterData));
    });
    
    if (availableEvents.length === 0) {
        // If no events available, try common
        const commonEvents = Object.values(RANDOM_EVENTS).filter(event => {
            return event.rarity === 'common' && 
                   (!event.condition || event.condition(characterData));
        });
        
        if (commonEvents.length === 0) return null;
        return commonEvents[Math.floor(Math.random() * commonEvents.length)];
    }
    
    return availableEvents[Math.floor(Math.random() * availableEvents.length)];
}

// Apply event choice effects
function applyEventEffects(characterData, effects) {
    const gameState = characterData.gameState;
    const fighter = characterData.fighters[characterData.activeFighterIndex];
    
    // Initialize event data if needed
    if (!fighter.eventData) {
        fighter.eventData = {
            activeBuffs: [],
            sponsor: null,
            dopingFlag: false,
            lastEvents: []
        };
    }
    
    // Apply immediate effects
    if (effects.cash) gameState.cash += effects.cash;
    
    // Apply temporary stat buffs
    if (effects.powerBonus || effects.speedBonus || effects.staminaBonus || effects.defenseBonus) {
        const buff = {
            id: Date.now(),
            power: effects.powerBonus || 0,
            speed: effects.speedBonus || 0,
            stamina: effects.staminaBonus || 0,
            defense: effects.defenseBonus || 0,
            form: effects.formBonus || 0,
            expiresAt: Date.now() + (effects.duration || 7) * 24 * 60 * 60 * 1000
        };
        fighter.eventData.activeBuffs.push(buff);
    }
    
    // Apply sponsor
    if (effects.sponsor) {
        fighter.eventData.sponsor = {
            ...effects.sponsor,
            startDate: Date.now(),
            expiresAt: Date.now() + effects.sponsor.duration * 24 * 60 * 60 * 1000
        };
    }
    
    // Set doping flag
    if (effects.dopingFlag) {
        fighter.eventData.dopingFlag = true;
    }
    
    // Handle injury risk
    if (effects.injuryRisk && Math.random() < effects.injuryRisk) {
        // Apply random injury
        const injuries = ['shoulder', 'hand', 'rib', 'nose'];
        const randomInjury = injuries[Math.floor(Math.random() * injuries.length)];
        // This will be handled by existing injury system
        return { injury: randomInjury };
    }
    
    // Handle doping test
    if (effects.dopingTest && fighter.eventData.dopingFlag) {
        // Failed doping test!
        gameState.cash -= 50000;
        fighter.gameData.rating = Math.max(0, fighter.gameData.rating - 200);
        fighter.eventData.dopingFlag = false;
        
        return { dopingFailed: true };
    }
    
    return {};
}

// Get active buffs for fighter
function getActiveBuffs(fighter) {
    if (!fighter.eventData || !fighter.eventData.activeBuffs) return null;
    
    // Remove expired buffs
    const now = Date.now();
    fighter.eventData.activeBuffs = fighter.eventData.activeBuffs.filter(buff => buff.expiresAt > now);
    
    if (fighter.eventData.activeBuffs.length === 0) return null;
    
    // Sum all active buffs
    const totalBuffs = {
        power: 0,
        speed: 0,
        stamina: 0,
        defense: 0,
        form: 0
    };
    
    fighter.eventData.activeBuffs.forEach(buff => {
        totalBuffs.power += buff.power;
        totalBuffs.speed += buff.speed;
        totalBuffs.stamina += buff.stamina;
        totalBuffs.defense += buff.defense;
        totalBuffs.form += buff.form;
    });
    
    return totalBuffs;
}

// Get sponsor bonus
function getSponsorBonus(fighter) {
    if (!fighter.eventData || !fighter.eventData.sponsor) return 0;
    
    const now = Date.now();
    if (fighter.eventData.sponsor.expiresAt < now) {
        fighter.eventData.sponsor = null;
        return 0;
    }
    
    return fighter.eventData.sponsor.bonus;
}
        const CHAMPIONSHIP_BELTS = [
            {
                id: 'regional',
                name: 'Регіональний чемпіон',
                icon: '🥉',
                minRating: 100,
                color: '#cd7f32',
                reward: { cash: 5000, rep: 200, stars: 10 },
                defenseInterval: 30
            },
            {
                id: 'national',
                name: 'Національний чемпіон',
                icon: '🥈',
                minRating: 300,
                color: '#c0c0c0',
                reward: { cash: 15000, rep: 500, stars: 25 },
                defenseInterval: 20
            },
            {
                id: 'continental',
                name: 'Континентальний чемпіон',
                icon: '🥇',
                minRating: 600,
                color: '#ffd700',
                reward: { cash: 35000, rep: 1000, stars: 50 },
                defenseInterval: 15
            },
            {
                id: 'world',
                name: 'Чемпіон світу',
                icon: '👑',
                minRating: 1000,
                color: '#9b59b6',
                reward: { cash: 100000, rep: 3000, stars: 150 },
                defenseInterval: 10
            }
        ];

        function getCurrentTier(rating) {
            for (let tier of RANKING_TIERS) {
                if (rating >= tier.minRating && rating <= tier.maxRating) {
                    return tier;
                }
            }
            return RANKING_TIERS[RANKING_TIERS.length - 1];
        }

        function getAvailableBelts(rating) {
            return CHAMPIONSHIP_BELTS.filter(belt => rating >= belt.minRating);
        }

        function canChallengeForBelt(fighter, belt) {
            const rating = fighter.gameData?.rating || 0;
            if (rating < belt.minRating) return false;
            if (fighter.belts && fighter.belts[belt.id]) return false;
            const winsInTier = fighter.gameData?.winsInCurrentTier || 0;
            if (winsInTier < 5) return false;
            return true;
        }

        function generateChampion(belt, playerRating, isGatekeeper = false) {
            const firstNames = ['Іван', 'Максим', 'Олег', 'Дмитро', 'Андрій', 'Сергій', 'Артем', 'Віктор', 'Олександр'];
            const lastNames = ['Коваль', 'Петров', 'Сидоров', 'Мельник', 'Шевченко', 'Бойко', 'Іванов', 'Гончар', 'Ковальчук'];
            const nicknames = ['Буря', 'Непереможний', 'Залізний', 'Вогонь', 'Гром', 'Легенда', 'Хижак', 'Молот', 'Титан'];
            
            const firstName = firstNames[Math.floor(Math.random() * firstNames.length)];
            const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
            const nickname = nicknames[Math.floor(Math.random() * nicknames.length)];
            
            // Gatekeeper bosses are balanced - only slightly harder
            // Regular champions are much harder
            const ratingBonus = isGatekeeper ? 50 : 150;
            const championRating = Math.max(playerRating + ratingBonus, belt.minRating + 50);
            
            const wins = Math.floor(Math.random() * 20) + 30;
            const losses = Math.floor(Math.random() * 3);
            const draws = Math.floor(Math.random() * 2);
            
            return {
                firstName,
                lastName,
                nickname,
                avatar: belt.icon,
                rating: championRating,
                record: { wins, losses, draws },
                difficulty: 'champion',
                difficultyLabel: belt.name,
                cashReward: belt.reward.cash,
                repReward: belt.reward.rep,
                starsReward: belt.reward.stars,
                belt: belt,
                isChampion: true,
                stats: calculateChampionStats(playerRating, belt, isGatekeeper)
            };
        }
        
        function calculateChampionStats(playerRating, belt, isGatekeeper) {
            // Get player's approximate stats based on rating
            // Early game: ~50-150 stats
            // Mid game: ~200-400 stats
            // Late game: ~500-800 stats
            const playerApproxStat = Math.min(800, 50 + playerRating * 0.5);
            
            // Gatekeeper: 10-20% stronger than player
            // Regular champion: 30-50% stronger than player
            const multiplier = isGatekeeper ? 1.15 : 1.4;
            const variance = 0.1; // ±10% random variance
            
            const baseStat = playerApproxStat * multiplier;
            
            return {
                power: Math.round(baseStat * (1 + (Math.random() * variance * 2 - variance))),
                speed: Math.round(baseStat * (1 + (Math.random() * variance * 2 - variance))),
                stamina: Math.round(baseStat * (1 + (Math.random() * variance * 2 - variance))),
                defense: Math.round(baseStat * (1 + (Math.random() * variance * 2 - variance)))
            };
        }

        function initializeRankingSystem(fighter) {
            if (!fighter.gameData) fighter.gameData = {};
            if (!fighter.gameData.rating) fighter.gameData.rating = 0;
            if (!fighter.gameData.winsInCurrentTier) fighter.gameData.winsInCurrentTier = 0;
            if (!fighter.belts) fighter.belts = {};
            if (!fighter.beltDefenses) fighter.beltDefenses = {};
        }

        function awardBelt(fighter, belt) {
            if (!fighter.belts) fighter.belts = {};
            fighter.belts[belt.id] = {
                wonDate: Date.now(),
                defenses: 0,
                nextDefense: Date.now() + (belt.defenseInterval * 24 * 60 * 60 * 1000)
            };
        }

        function isBeltDefenseDue(fighter, beltId) {
            const belt = fighter.belts[beltId];
            if (!belt) return false;
            return Date.now() >= belt.nextDefense;
        }

        function getBeltsNeedingDefense(fighter) {
            const needDefense = [];
            if (!fighter.belts) return needDefense;
            for (let beltId in fighter.belts) {
                if (isBeltDefenseDue(fighter, beltId)) {
                    const beltData = CHAMPIONSHIP_BELTS.find(b => b.id === beltId);
                    if (beltData) needDefense.push(beltData);
                }
            }
            return needDefense;
        }

        function loseBelt(fighter, beltId) {
            if (fighter.belts && fighter.belts[beltId]) {
                delete fighter.belts[beltId];
            }
        }

        function updateRatingAfterWin(fighter, opponent) {
            console.log('=== UPDATE RATING AFTER WIN ===');
            console.log('Before - Rating:', fighter.gameData.rating);
            console.log('Before - Wins in tier:', fighter.gameData.winsInCurrentTier);
            console.log('Opponent is champion?', opponent.isChampion);
            console.log('Opponent difficulty:', opponent.difficulty);
            
            // Calculate rating gain based on difficulty and champion status
            let ratingGain = 25; // Base for medium/easy
            
            if (opponent.isChampion) {
                // Championship fights give more rating
                ratingGain = 50;
            } else if (opponent.difficulty === 'hard') {
                // Hard opponents give double rating
                ratingGain = 50;
            } else if (opponent.difficulty === 'easy') {
                // Easy opponents give less rating
                ratingGain = 15;
            }
            
            console.log('Rating gain:', ratingGain);
            
            const beforeRating = fighter.gameData.rating;
            fighter.gameData.rating += ratingGain;
            const afterRating = fighter.gameData.rating;
            const actualGain = afterRating - beforeRating;
            
            console.log('After - Rating:', fighter.gameData.rating);
            console.log('VERIFICATION: Should be +' + ratingGain + ', actually +' + actualGain);
            
            if (actualGain !== ratingGain) {
                console.error('⚠️ RATING MISMATCH! Expected +' + ratingGain + ' but got +' + actualGain);
            }
            
            if (opponent.belt) awardBelt(fighter, opponent.belt);
            
            // Reset wins when advancing to new tier (gatekeeper boss defeated)
            if (opponent.isGatekeeperBoss) {
                console.log('🎉 Gatekeeper defeated! Advancing to new tier, resetting wins.');
                fighter.gameData.winsInCurrentTier = 0;
            }
            
            if (opponent.isTitleDefense && fighter.belts[opponent.belt.id]) {
                fighter.belts[opponent.belt.id].defenses++;
                fighter.belts[opponent.belt.id].nextDefense = Date.now() + (opponent.belt.defenseInterval * 24 * 60 * 60 * 1000);
            }
        }

        function updateRatingAfterLoss(fighter, opponent) {
            const ratingLoss = 15;
            fighter.gameData.rating = Math.max(0, fighter.gameData.rating - ratingLoss);
            fighter.gameData.winsInCurrentTier = 0;
            if (opponent.isTitleDefense && opponent.belt) {
                loseBelt(fighter, opponent.belt.id);
            }
        }
        
        const TRAINING_TYPES = {
            power: { icon: '💪', name: 'Сила', key: 'power' },
            speed: { icon: '⚡', name: 'Швидкість', key: 'speed' },
            stamina: { icon: '🫁', name: 'Витривалість', key: 'stamina' },
            defense: { icon: '🛡️', name: 'Захист', key: 'defense' }
        };
        
        const TRAINING_OPTIONS = [
            { time: 30, cost: 100, reward: '5-8', minutes: 30 },
            { time: 120, cost: 500, reward: '10-15', minutes: 120 },
            { time: 360, cost: 2000, reward: '20-30', minutes: 360 }
        ];
        
        // ========================================= 
        // INJURY SYSTEM
        // =========================================
        
        const INJURY_TYPES = {
            bruise: { name: '🤕 Синці та забиті місця', severity: 'light', duration: 0.5 * 60 * 60 * 1000, statReduction: 0.10, chance: 0.08, healCost: 300, starCost: 5 },
            cut: { name: '💢 Розсічення брови', severity: 'light', duration: 1 * 60 * 60 * 1000, statReduction: 0.10, chance: 0.06, healCost: 400, starCost: 5 },
            fatigue: { name: '😮‍💨 Втома м\'язів', severity: 'light', duration: 1.5 * 60 * 60 * 1000, statReduction: 0.15, chance: 0.08, healCost: 500, starCost: 8 },
            ribCrack: { name: '🦴 Тріщина ребра', severity: 'medium', duration: 3 * 60 * 60 * 1000, statReduction: 0.25, chance: 0.05, healCost: 1000, starCost: 10 },
            brokenNose: { name: '👃 Зламаний ніс', severity: 'medium', duration: 4 * 60 * 60 * 1000, statReduction: 0.20, chance: 0.04, healCost: 1200, starCost: 12 },
            wristSprain: { name: '🤛 Розтягнення зап\'ястя', severity: 'medium', duration: 5 * 60 * 60 * 1000, statReduction: 0.30, chance: 0.05, healCost: 1500, starCost: 15 },
            concussion: { name: '💀 Струс мозку', severity: 'heavy', duration: 8 * 60 * 60 * 1000, statReduction: 0.40, chance: 0.02, healCost: 3000, starCost: 20 },
            fracture: { name: '🦴 Перелом кістки', severity: 'heavy', duration: 10 * 60 * 60 * 1000, statReduction: 0.35, chance: 0.01, healCost: 3500, starCost: 25 },
            eyeDamage: { name: '👁️ Пошкодження ока', severity: 'heavy', duration: 12 * 60 * 60 * 1000, statReduction: 0.50, chance: 0.015, healCost: 4000, starCost: 30 },
            severeConcussion: { name: '⚠️ Важкий струс мозку', severity: 'critical', duration: 20 * 60 * 60 * 1000, statReduction: 0.50, chance: 0.005, healCost: 8000, starCost: 50 },
            compoundFracture: { name: '🦴 Складний перелом', severity: 'critical', duration: 24 * 60 * 60 * 1000, statReduction: 0.50, chance: 0.003, healCost: 10000, starCost: 60 }
        };
        
        const DOCTORS = {
            none: { name: 'Без лікаря', timeReduction: 0, cost: 0 },
            basic: { name: 'Лікар рівень 1', timeReduction: 0.25, cost: 500 },
            advanced: { name: 'Лікар рівень 2', timeReduction: 0.75, cost: 2000 }
        };
        
        function checkForInjury(fighter, opponentDifficulty, fightResult) {
            if (fighter.injury && fighter.injury.healTime > Date.now()) return null;
            let chanceMultiplier = 1.0;
            if (opponentDifficulty === 'hard') chanceMultiplier = 1.5;
            if (opponentDifficulty === 'easy') chanceMultiplier = 0.5;
            if (fightResult === 'loss') chanceMultiplier *= 1.5;
            if (fighter.gameData && fighter.gameData.form < 70) chanceMultiplier *= 1.3;
            const injuries = Object.keys(INJURY_TYPES).reverse();
            for (let injuryKey of injuries) {
                const injury = INJURY_TYPES[injuryKey];
                const finalChance = injury.chance * chanceMultiplier;
                if (Math.random() < finalChance) {
                    return { type: injuryKey, ...injury, receivedAt: Date.now(), healTime: Date.now() + injury.duration };
                }
            }
            return null;
        }
        
        function applyInjuryEffects(fighter) {
            if (!fighter.injury || fighter.injury.healTime <= Date.now()) {
                if (fighter.injury) delete fighter.injury;
                return fighter.stats;
            }
            const reduction = fighter.injury.statReduction;
            return {
                power: Math.floor(fighter.stats.power * (1 - reduction)),
                speed: Math.floor(fighter.stats.speed * (1 - reduction)),
                stamina: Math.floor(fighter.stats.stamina * (1 - reduction)),
                defense: Math.floor(fighter.stats.defense * (1 - reduction))
            };
        }
        
        let isHealing = false; // Flag to prevent multiple clicks
        
        function healInjury(doctorLevel, useStars = false) {
            // Prevent multiple clicks
            if (isHealing) {
                console.log('Already healing, ignoring click');
                return false;
            }
            
            isHealing = true;
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (!fighter || !fighter.injury) { 
                showToast('Травму не знайдено!', 'error');
                isHealing = false;
                return false; 
            }
            
            if (useStars) {
                if (gameState.stars < fighter.injury.starCost) { 
                    showToast('Недостатньо зірок! ⭐', 'error');
                    isHealing = false;
                    return false; 
                }
                gameState.stars -= fighter.injury.starCost;
                delete fighter.injury;
                saveGameSync(characterData);
                showToast('Травму вилікувано! 🏥', 'success');
                loadGameData();
                closeInjuryModal();
                isHealing = false;
                return true;
            }
            
            const doctor = DOCTORS[doctorLevel];
            if (gameState.cash < doctor.cost) { 
                showToast('Недостатньо грошей! 💰', 'error');
                isHealing = false;
                return false; 
            }
            
            gameState.cash -= doctor.cost;
            const remainingTime = fighter.injury.healTime - Date.now();
            const reducedTime = remainingTime * (1 - doctor.timeReduction);
            fighter.injury.healTime = Date.now() + reducedTime;
            saveGameSync(characterData);
            const hours = Math.floor(reducedTime / (60 * 60 * 1000));
            const minutes = Math.floor((reducedTime % (60 * 60 * 1000)) / (60 * 1000));
            showToast(`Найнято лікаря! Лікування: ${hours}г ${minutes}хв 🏥`, 'success');
            loadGameData();
            closeInjuryModal();
            isHealing = false;
            return true;
        }
        
        function formatInjuryTime(milliseconds) {
            const hours = Math.floor(milliseconds / (60 * 60 * 1000));
            const minutes = Math.floor((milliseconds % (60 * 60 * 1000)) / (60 * 1000));
            if (hours > 0) return `${hours}г ${minutes}хв`;
            return `${minutes}хв`;
        }
        
        function openTreatmentModal() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const gameState = characterData.gameState;
            if (!fighter.injury) return;
            const injury = fighter.injury;
            const remainingTime = injury.healTime - Date.now();
            const hours = Math.floor(remainingTime / (60 * 60 * 1000));
            const minutes = Math.floor((remainingTime % (60 * 60 * 1000)) / (60 * 1000));
            const timeWithBasic = remainingTime * 0.75;
            const hoursBasic = Math.floor(timeWithBasic / (60 * 60 * 1000));
            const minutesBasic = Math.floor((timeWithBasic % (60 * 60 * 1000)) / (60 * 1000));
            const timeWithAdvanced = remainingTime * 0.25;
            const hoursAdvanced = Math.floor(timeWithAdvanced / (60 * 60 * 1000));
            const minutesAdvanced = Math.floor((timeWithAdvanced % (60 * 60 * 1000)) / (60 * 1000));
            const modal = document.createElement('div');
            modal.id = 'injuryModal';
            modal.className = 'injury-modal';
            modal.innerHTML = `
                <div class="injury-modal-overlay" onclick="closeInjuryModal()"></div>
                <div class="injury-modal-content">
                    <div class="injury-modal-header">
                        <h2>🏥 Лікування травми</h2>
                        <button onclick="closeInjuryModal()" class="injury-close-btn">✕</button>
                    </div>
                    <div class="injury-info">
                        <div class="injury-name">${injury.name}</div>
                        <div class="injury-severity ${injury.severity}">
                            ${injury.severity === 'light' ? '🟢 Легка' : injury.severity === 'medium' ? '🟡 Середня' : injury.severity === 'heavy' ? '🟠 Важка' : '🔴 Критична'}
                        </div>
                        <div class="injury-effect">📉 Зменшення статів: -${Math.round(injury.statReduction * 100)}%</div>
                        <div class="injury-time">⏰ Природне лікування: ${hours}г ${minutes}хв</div>
                    </div>
                    <div class="treatment-options">
                        <div class="treatment-option">
                            <div class="treatment-header">
                                <span class="treatment-name">🏥 Лікар рівень 1</span>
                                <span class="treatment-cost">$${DOCTORS.basic.cost}</span>
                            </div>
                            <div class="treatment-time">⏰ ${hoursBasic}г ${minutesBasic}хв</div>
                            <button onclick="this.disabled=true; this.classList.add('disabled'); healInjury('basic'); return false;" 
                                    class="treatment-btn ${gameState.cash < DOCTORS.basic.cost ? 'disabled' : ''}"
                                    ${gameState.cash < DOCTORS.basic.cost ? 'disabled' : ''}>
                                Найняти лікаря
                            </button>
                        </div>
                        <div class="treatment-option">
                            <div class="treatment-header">
                                <span class="treatment-name">🏥 Лікар рівень 2</span>
                                <span class="treatment-cost">$${DOCTORS.advanced.cost}</span>
                            </div>
                            <div class="treatment-time">⏰ ${hoursAdvanced}г ${minutesAdvanced}хв</div>
                            <button onclick="this.disabled=true; this.classList.add('disabled'); healInjury('advanced'); return false;" 
                                    class="treatment-btn ${gameState.cash < DOCTORS.advanced.cost ? 'disabled' : ''}"
                                    ${gameState.cash < DOCTORS.advanced.cost ? 'disabled' : ''}>
                                Найняти лікаря
                            </button>
                        </div>
                        <div class="treatment-option instant">
                            <div class="treatment-header">
                                <span class="treatment-name">⭐ Миттєве лікування</span>
                                <span class="treatment-cost">${injury.starCost} ⭐</span>
                            </div>
                            <div class="treatment-time">⚡ Одразу</div>
                            <button onclick="this.disabled=true; this.classList.add('disabled'); healInjury('none', true); return false;" 
                                    class="treatment-btn instant ${gameState.stars < injury.starCost ? 'disabled' : ''}"
                                    ${gameState.stars < injury.starCost ? 'disabled' : ''}>
                                Вилікувати зараз
                            </button>
                        </div>
                    </div>
                    <button onclick="closeInjuryModal()" class="injury-natural-btn">
                        Хай заживає природно
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
            setTimeout(() => modal.classList.add('active'), 10);
        }
        
        function closeInjuryModal() {
            isHealing = false; // Reset flag
            const modal = document.getElementById('injuryModal');
            if (modal) {
                modal.classList.remove('active');
                setTimeout(() => modal.remove(), 300);
            }
        }
        
        // =========================================
        // TEAM MANAGEMENT SYSTEM - STEP 1: DATA
        // =========================================
        
        const TEAM_MEMBER_TYPES = {
            trainer: {
                id: 'trainer',
                name: 'Тренер',
                icon: '🧑‍🏫',
                color: '#4ade80'
            },
            doctor: {
                id: 'doctor',
                name: 'Лікар',
                icon: '💊',
                color: '#ef4444'
            },
            manager: {
                id: 'manager',
                name: 'Менеджер',
                icon: '📢',
                color: '#fbbf24'
            }
        };
        
        const TEAM_MEMBERS = {
            trainer_basic: {
                id: 'trainer_basic',
                type: 'trainer',
                firstName: 'Іван',
                lastName: 'Петренко',
                level: 1,
                salary: 2000,
                hiringCost: 5000,
                bonuses: {
                    trainingBonus: 0.10,
                    powerBonus: 3
                },
                requirements: { rating: 100 }
            },
            doctor_basic: {
                id: 'doctor_basic',
                type: 'doctor',
                firstName: 'Наталія',
                lastName: 'Сидорова',
                level: 1,
                salary: 1500,
                hiringCost: 4000,
                bonuses: {
                    healingSpeed: 0.80,
                    injuryResistance: 0.10
                },
                requirements: { rating: 200 }
            },
            manager_basic: {
                id: 'manager_basic',
                type: 'manager',
                firstName: 'Дмитро',
                lastName: 'Бойко',
                level: 1,
                salary: 3000,
                hiringCost: 8000,
                bonuses: {
                    fightEarnings: 0.15
                },
                requirements: { rating: 300 }
            }
        };
        
        // =========================================
        // TEAM MANAGEMENT SYSTEM - STEP 2: FUNCTIONS
        // =========================================
        
        // Initialize team structure
        function initializeTeam(characterData) {
            if (!characterData.team) {
                characterData.team = {
                    members: {},
                    expenses: 0,
                    totalSpent: 0,
                    lastPayment: Date.now()
                };
            }
            
            // Додати відсутні поля якщо team існує але неповний
            if (characterData.team.expenses === undefined) {
                characterData.team.expenses = 0;
            }
            if (characterData.team.totalSpent === undefined) {
                characterData.team.totalSpent = 0;
            }
            if (!characterData.team.members) {
                characterData.team.members = {};
            }
            if (!characterData.team.lastPayment) {
                characterData.team.lastPayment = Date.now();
            }
        }
        
        // Hire team member
        function hireTeamMember(characterData, memberId) {
            const member = TEAM_MEMBERS[memberId];
            if (!member) return { success: false, error: 'Не знайдено' };
            
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const gameState = characterData.gameState;
            
            // Check if already have this type
            if (characterData.team.members[member.type]) {
                return { success: false, error: 'Вже є ' + TEAM_MEMBER_TYPES[member.type].name };
            }
            
            // Check requirements
            if (member.requirements.rating && fighter.gameData.rating < member.requirements.rating) {
                return { success: false, error: 'Потрібен рейтинг ' + member.requirements.rating };
            }
            
            // Check money
            if (gameState.cash < member.hiringCost) {
                return { success: false, error: 'Недостатньо грошей' };
            }
            
            // Hire
            gameState.cash -= member.hiringCost;
            characterData.team.members[member.type] = { ...member, hiredDate: Date.now() };
            updateTeamExpenses(characterData);
            
            return { success: true };
        }
        
        // Fire team member
        function fireTeamMember(characterData, memberType) {
            if (!characterData.team.members[memberType]) {
                return { success: false, error: 'Не найнято' };
            }
            
            delete characterData.team.members[memberType];
            updateTeamExpenses(characterData);
            
            return { success: true };
        }
        
        // Update monthly expenses
        function updateTeamExpenses(characterData) {
            let total = 0;
            Object.values(characterData.team.members).forEach(member => {
                total += member.salary;
            });
            characterData.team.expenses = total;
        }
        
        // Get team bonuses
        function getTeamBonuses(characterData) {
            const bonuses = {
                trainingBonus: 0,
                powerBonus: 0,
                healingSpeed: 1.0,
                injuryResistance: 0,
                fightEarnings: 0
            };
            
            if (!characterData.team || !characterData.team.members) return bonuses;
            
            Object.values(characterData.team.members).forEach(member => {
                if (!member.bonuses) return;
                
                if (member.bonuses.trainingBonus) bonuses.trainingBonus += member.bonuses.trainingBonus;
                if (member.bonuses.powerBonus) bonuses.powerBonus += member.bonuses.powerBonus;
                if (member.bonuses.healingSpeed) bonuses.healingSpeed *= member.bonuses.healingSpeed;
                if (member.bonuses.injuryResistance) bonuses.injuryResistance += member.bonuses.injuryResistance;
                if (member.bonuses.fightEarnings) bonuses.fightEarnings += member.bonuses.fightEarnings;
            });
            
            return bonuses;
        }
        
        // Get available members for hiring
        function getAvailableTeamMembers(characterData) {
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const gameState = characterData.gameState;
            const available = {};
            
            // Безпечна перевірка team
            if (!characterData.team || !characterData.team.members) {
                characterData.team = { members: {}, monthlyCost: 0 };
            }
            
            // Get rating - same as displayed on main screen
            const currentRating = fighter.gameData.rating || 0;
            
            console.log('🔍 Getting available team members...');
            console.log('   Current rating:', currentRating);
            console.log('   Current cash:', gameState.cash);
            console.log('   Already hired:', Object.keys(characterData.team.members));
            
            Object.entries(TEAM_MEMBERS).forEach(([id, member]) => {
                console.log('   Checking:', id, member.type);
                
                // Skip if already hired this type
                if (characterData.team.members[member.type]) {
                    console.log('     ❌ Already hired');
                    return;
                }
                
                // Check requirements - БЕЗПЕЧНА ПЕРЕВІРКА
                let meetsRequirements = true;
                let missingRequirements = [];
                
                if (member.requirements && member.requirements.rating) {
                    if (currentRating < member.requirements.rating) {
                        meetsRequirements = false;
                        missingRequirements.push('Рейтинг ' + member.requirements.rating);
                        console.log('     ⚠️ Need rating:', member.requirements.rating, 'Have:', currentRating);
                    }
                }
                
                if (!available[member.type]) {
                    available[member.type] = [];
                }
                
                const canAfford = gameState.cash >= member.hiringCost;
                
                available[member.type].push({
                    ...member,
                    meetsRequirements,
                    missingRequirements,
                    canAfford
                });
                
                console.log('     ✅ Added:', meetsRequirements ? 'Available' : 'Locked', canAfford ? 'Can afford' : 'Too expensive');
            });
            
            console.log('📊 Available team members:', available);
            
            return available;
        }
        
        // ========================================= 
        // FIGHTER ECONOMY SYSTEM
        // =========================================
        
        function calculateFighterPrice(fighter) {
            // Base price from talent
            let price = (fighter.talent || 5) * 1000;
            
            // Bonus for stats (overall)
            const overall = Math.round((fighter.stats.power + fighter.stats.speed + fighter.stats.stamina + fighter.stats.defense) / 4);
            price += overall * 10;
            
            // Bonus/penalty for record
            if (fighter.gameData && fighter.gameData.record) {
                const record = fighter.gameData.record;
                price += (record.wins * 500) - (record.losses * 200);
            }
            
            // Age multiplier (younger = more expensive)
            const age = fighter.age || 25;
            let ageMultiplier = 1.0;
            if (age <= 25) ageMultiplier = 1.2;
            else if (age <= 30) ageMultiplier = 1.0;
            else if (age <= 35) ageMultiplier = 0.8;
            else ageMultiplier = 0.5;
            
            price = Math.floor(price * ageMultiplier);
            
            // Penalty for injury
            if (fighter.injury && fighter.injury.healTime > Date.now()) {
                price = Math.floor(price * 0.5);
            }
            
            return Math.max(1000, price); // Minimum $1,000
        }
        
        function getPriceBreakdown(fighter) {
            const talent = (fighter.talent || 5) * 1000;
            const overall = Math.round((fighter.stats.power + fighter.stats.speed + fighter.stats.stamina + fighter.stats.defense) / 4);
            const statsBonus = overall * 10;
            
            let recordBonus = 0;
            if (fighter.gameData && fighter.gameData.record) {
                const record = fighter.gameData.record;
                recordBonus = (record.wins * 500) - (record.losses * 200);
            }
            
            const age = fighter.age || 25;
            let ageLabel = '';
            let ageMultiplier = 1.0;
            if (age <= 25) { ageMultiplier = 1.2; ageLabel = '+20%'; }
            else if (age <= 30) { ageMultiplier = 1.0; ageLabel = '+0%'; }
            else if (age <= 35) { ageMultiplier = 0.8; ageLabel = '-20%'; }
            else { ageMultiplier = 0.5; ageLabel = '-50%'; }
            
            const subtotal = talent + statsBonus + recordBonus;
            const total = Math.floor(subtotal * ageMultiplier);
            
            let injuryPenalty = '';
            if (fighter.injury && fighter.injury.healTime > Date.now()) {
                injuryPenalty = '-50% (травма)';
            }
            
            return {
                talent,
                statsBonus,
                recordBonus,
                ageLabel,
                ageMultiplier,
                subtotal,
                total: injuryPenalty ? Math.floor(total * 0.5) : total,
                injuryPenalty
            };
        }
        
        function openSellFighterModal(fighterIndex) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[fighterIndex];
            
            // Тепер МОЖНА продати останнього бійця!
            // Користувач зможе купити нового з зароблених грошей
            
            const price = calculateFighterPrice(fighter);
            const breakdown = getPriceBreakdown(fighter);
            const commission = Math.floor(price * 0.1);
            const finalPrice = price - commission;
            
            const modal = document.createElement('div');
            modal.id = 'sellFighterModal';
            modal.className = 'injury-modal';
            modal.innerHTML = `
                <div class="injury-modal-overlay" onclick="closeSellModal()"></div>
                <div class="injury-modal-content">
                    <div class="injury-modal-header">
                        <h2>💰 Продати бійця?</h2>
                        <button onclick="closeSellModal()" class="injury-close-btn">✕</button>
                    </div>
                    
                    <div class="sell-fighter-info">
                        <div style="text-align: center; margin-bottom: 1.5rem;">
                            <div style="font-size: 3rem; margin-bottom: 0.5rem;">${fighter.avatar}</div>
                            <div style="font-size: 1.3rem; font-weight: bold; color: white;">
                                ${fighter.firstName} "${fighter.nickname}" ${fighter.lastName}
                            </div>
                            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 0.5rem; flex-wrap: wrap;">
                                <span>🔥 Талант ${fighter.talent}</span>
                                <span>📊 Оверол ${Math.round((fighter.stats.power + fighter.stats.speed + fighter.stats.stamina + fighter.stats.defense) / 4)}</span>
                                <span>📈 ${fighter.gameData.record.wins}-${fighter.gameData.record.losses}-${fighter.gameData.record.draws}</span>
                                <span>🎂 ${fighter.age} років</span>
                            </div>
                        </div>
                        
                        <div style="background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem;">
                            <div style="text-align: center; font-size: 0.9rem; color: rgba(255,255,255,0.7); margin-bottom: 1rem;">
                                РОЗРАХУНОК ЦІНИ
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.7);">Базова (талант):</span>
                                    <span style="color: white; font-weight: 600;">$${formatNumber(breakdown.talent)}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.7);">За стати:</span>
                                    <span style="color: #4ade80; font-weight: 600;">+$${formatNumber(breakdown.statsBonus)}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.7);">За рекорд:</span>
                                    <span style="color: ${breakdown.recordBonus >= 0 ? '#4ade80' : '#f87171'}; font-weight: 600;">
                                        ${breakdown.recordBonus >= 0 ? '+' : ''}$${formatNumber(breakdown.recordBonus)}
                                    </span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.7);">Вік (${fighter.age} років):</span>
                                    <span style="color: ${breakdown.ageMultiplier >= 1 ? '#4ade80' : '#f87171'}; font-weight: 600;">
                                        ${breakdown.ageLabel}
                                    </span>
                                </div>
                                ${breakdown.injuryPenalty ? `
                                    <div style="display: flex; justify-content: space-between;">
                                        <span style="color: rgba(255,255,255,0.7);">Травма:</span>
                                        <span style="color: #f87171; font-weight: 600;">${breakdown.injuryPenalty}</span>
                                    </div>
                                ` : ''}
                                <div style="height: 1px; background: rgba(255,215,0,0.3); margin: 0.5rem 0;"></div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.7);">Проміжна сума:</span>
                                    <span style="color: white; font-weight: 600;">$${formatNumber(price)}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: rgba(255,255,255,0.7);">Комісія (10%):</span>
                                    <span style="color: #f87171; font-weight: 600;">-$${formatNumber(commission)}</span>
                                </div>
                                <div style="height: 1px; background: rgba(255,215,0,0.5); margin: 0.5rem 0;"></div>
                                <div style="display: flex; justify-content: space-between; font-size: 1.2rem;">
                                    <span style="color: var(--gold); font-weight: 700;">ВСЬОГО:</span>
                                    <span style="color: var(--gold); font-weight: 700;">$${formatNumber(finalPrice)}</span>
                                </div>
                            </div>
                        </div>
                        
                        <div style="background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; text-align: center;">
                            <span style="color: #f87171;">⚠️ Продаж незворотній! Боєць буде видалений назавжди.</span>
                        </div>
                        
                        <div style="display: flex; gap: 1rem;">
                            <button onclick="closeSellModal()" class="injury-natural-btn" style="flex: 1;">
                                ❌ Скасувати
                            </button>
                            <button onclick="confirmSellFighter(${fighterIndex}, ${finalPrice})" 
                                    class="treatment-btn" style="flex: 1;">
                                ✅ ПРОДАТИ за $${formatNumber(finalPrice)}
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            setTimeout(() => modal.classList.add('active'), 10);
        }
        
        function closeSellModal() {
            const modal = document.getElementById('sellFighterModal');
            if (modal) {
                modal.classList.remove('active');
                setTimeout(() => modal.remove(), 300);
            }
        }
        
        function confirmSellFighter(fighterIndex, price) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[fighterIndex];
            
            // Add money
            characterData.gameState.cash += price;
            
            // Remove fighter
            characterData.fighters.splice(fighterIndex, 1);
            
            // Якщо НЕ ЗАЛИШИЛОСЬ бійців - відправити в Академію
            if (characterData.fighters.length === 0) {
                characterData.activeFighterIndex = -1;
                saveGameSync(characterData);
                showToast(`${fighter.firstName} "${fighter.nickname}" проданий за $${formatNumber(price)}! 💰`, 'success');
                closeSellModal();
                
                // Перенаправити в Академію для покупки нового
                setTimeout(() => {
                    showToast('⚠️ Немає бійців!', 'Купи нового в Академії', 'warning');
                    openAcademy();
                }, 1000);
                return;
            }
            
            // Update active fighter index if needed
            if (characterData.activeFighterIndex >= characterData.fighters.length) {
                characterData.activeFighterIndex = characterData.fighters.length - 1;
            }
            
            saveGameSync(characterData);
            
            showToast(`${fighter.firstName} "${fighter.nickname}" проданий за $${formatNumber(price)}! 💰`, 'success');
            
            closeSellModal();
            loadGameData();
        }
        
        let selectedTraining = {};
        let trainingTimers = {};
        
        function loadTrainingScreen() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const gameState = characterData.gameState;
            
            // Initialize training state if not exists
            if (!fighter.training) {
                fighter.training = {};
            }
            
            const content = document.getElementById('trainingContent');
            content.innerHTML = '';
            
            // Add talent info banner at the top
            const talent = fighter.talent || 5;
            const talentBonus = getTalentBonus(talent);
            const talentBanner = document.createElement('div');
            talentBanner.style.cssText = 'background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); border-radius: 8px; padding: 0.8rem; margin-bottom: 1rem; text-align: center;';
            talentBanner.innerHTML = `<div style="color: #FFD700; font-weight: 600; font-size: 0.9rem;">🔥 Талант ${talent} · Бонус +${talentBonus}% до всіх тренувань</div>`;
            content.appendChild(talentBanner);
            
            Object.keys(TRAINING_TYPES).forEach(type => {
                const typeData = TRAINING_TYPES[type];
                const currentValue = fighter.stats[typeData.key];
                const isTraining = fighter.training[type] && fighter.training[type].endTime > Date.now();
                
                const card = document.createElement('div');
                card.className = 'training-card' + (isTraining ? ' active' : '');
                card.innerHTML = `
                    <div class="training-card-header">
                        <div class="training-stat-name">
                            <span class="training-stat-icon">${typeData.icon}</span>
                            <span>${typeData.name}</span>
                        </div>
                        <div class="training-stat-value">${currentValue}/1000</div>
                    </div>
                    
                    <div class="training-progress">
                        <div class="training-progress-bar">
                            <div class="training-progress-fill" style="width: ${(currentValue / 1000 * 100)}%"></div>
                        </div>
                    </div>
                    
                    ${isTraining ? generateTrainingTimer(type, fighter.training[type]) : generateTrainingOptions(type, gameState)}
                `;
                
                content.appendChild(card);
            });
            
            // Start timers for active trainings
            Object.keys(fighter.training).forEach(type => {
                if (fighter.training[type] && fighter.training[type].endTime > Date.now()) {
                    startTrainingTimer(type);
                }
            });
            
            saveGameSync(characterData);
        }
        
        function generateTrainingOptions(type, gameState) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const talent = fighter.talent || 5;
            const talentBonus = getTalentBonus(talent);
            
            return `
                <div class="training-options">
                    ${TRAINING_OPTIONS.map((opt, idx) => {
                        const [min, max] = opt.reward.split('-').map(Number);
                        const avgReward = Math.floor((min + max) / 2);
                        const withBonus = Math.floor(avgReward * (1 + talentBonus / 100));
                        
                        return `
                        <div class="training-option ${selectedTraining[type] === idx ? 'selected' : ''}" 
                             onclick="selectTrainingOption('${type}', ${idx})">
                            <div class="training-option-time">⏱️ ${opt.time < 60 ? opt.time + ' хв' : (opt.time / 60) + ' год'}</div>
                            <div class="training-option-cost">💵 $${opt.cost}</div>
                            <div class="training-option-reward">
                                +${opt.reward}
                                <div style="font-size: 0.75rem; color: #FFD700; margin-top: 2px;">
                                    ~${withBonus} з талантом
                                </div>
                            </div>
                        </div>
                    `}).join('')}
                </div>
                <button class="training-button" onclick="startTraining('${type}')" 
                        ${!selectedTraining[type] && selectedTraining[type] !== 0 ? 'disabled' : ''}>
                    ПОЧАТИ ТРЕНУВАННЯ
                </button>
            `;
        }
        
        function generateTrainingTimer(type, trainingData) {
            const remaining = Math.max(0, trainingData.endTime - Date.now());
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            
            return `
                <div class="training-timer">
                    <div class="training-timer-label">Тренування в процесі...</div>
                    <div class="training-timer-value" id="timer-${type}">
                        ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}
                    </div>
                    <button class="training-boost-button" onclick="boostTraining('${type}')">
                        ⚡ ПРИСКОРИТИ (⭐ 10)
                    </button>
                </div>
            `;
        }
        
        function selectTrainingOption(type, optionIndex) {
            selectedTraining[type] = optionIndex;
            loadTrainingScreen();
        }
        
        function startTraining(type) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (selectedTraining[type] === undefined) return;
            
            // Check if already training something
            if (fighter.training) {
                for (const trainingType in fighter.training) {
                    if (fighter.training[trainingType] && fighter.training[trainingType].endTime > Date.now()) {
                        showToast('Вже тренується!', `${fighter.firstName} вже тренує ${TRAINING_TYPES[trainingType].name}. Дочекайся завершення.`, 'warning');
                        return;
                    }
                }
            }
            
            const option = TRAINING_OPTIONS[selectedTraining[type]];
            
            // Check if enough money
            if (gameState.cash < option.cost) {
                showToast('Недостатньо грошей!', `Потрібно $${option.cost}`, 'error');
                return;
            }
            
            // Deduct cost
            gameState.cash -= option.cost;
            
            // Apply VIP time bonus
            const timeMultiplier = getVIPMultiplier('time');
            const trainingTime = Math.floor(option.minutes * timeMultiplier);
            
            // Initialize training object if not exists
            if (!fighter.training) fighter.training = {};
            
            // Set training
            const endTime = Date.now() + (trainingTime * 60 * 1000);
            fighter.training[type] = {
                endTime: endTime,
                reward: option.reward,
                statKey: TRAINING_TYPES[type].key,
                originalMinutes: option.minutes,
                actualMinutes: trainingTime
            };
            
            saveGameSync(characterData);
            
            // Show VIP bonus toast if applicable
            if (timeMultiplier < 1) {
                setTimeout(() => {
                    showToast('⭐ VIP бонус!', `Час: ${trainingTime} хв (замість ${option.minutes} хв)\nЕкономія: ${option.minutes - trainingTime} хв`, 'success');
                }, 500);
            }
            
            // Reload screen
            loadTrainingScreen();
        }
        
        function startTrainingTimer(type) {
            if (trainingTimers[type]) {
                clearInterval(trainingTimers[type]);
            }
            
            console.log(`Starting training timer for ${type}`);
            
            trainingTimers[type] = setInterval(() => {
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                const fighter = characterData.fighters[characterData.activeFighterIndex];
                
                if (!fighter || !fighter.training || !fighter.training[type]) {
                    console.log(`No training data for ${type}, clearing timer`);
                    clearInterval(trainingTimers[type]);
                    return;
                }
                
                const training = fighter.training[type];
                const remaining = Math.max(0, training.endTime - Date.now());
                
                if (remaining <= 0) {
                    // Training complete!
                    console.log(`Training ${type} completed!`);
                    completeTraining(type);
                    clearInterval(trainingTimers[type]);
                    return;
                }
                
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                
                const timerEl = document.getElementById(`timer-${type}`);
                if (timerEl) {
                    timerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                } else {
                    console.log(`Timer element not found: timer-${type}`);
                }
            }, 1000);
        }
        
        function completeTraining(type) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const training = fighter.training[type];
            const gameState = characterData.gameState;
            
            // Calculate reward
            const [min, max] = training.reward.split('-').map(Number);
            let reward = Math.floor(Math.random() * (max - min + 1)) + min;
            
            // Apply talent bonus
            const talent = fighter.talent || 5; // Default to 5 if not set
            const talentBonus = getTalentBonus(talent);
            console.log('Training - Talent:', talent, 'Bonus:', talentBonus + '%', 'Base reward:', reward);
            
            reward = Math.floor(reward * (1 + talentBonus / 100));
            console.log('After talent bonus:', reward);
            
            // Apply TEAM bonus (trainer)
            initializeTeam(characterData);
            const teamBonuses = getTeamBonuses(characterData);
            if (teamBonuses.trainingBonus > 0) {
                const beforeTeam = reward;
                reward = Math.floor(reward * (1 + teamBonuses.trainingBonus));
                console.log('Team training bonus: +' + Math.round(teamBonuses.trainingBonus * 100) + '%, ' + beforeTeam + ' → ' + reward);
            }
            
            // Apply VIP bonus
            const vipMultiplier = getVIPMultiplier('training');
            if (vipMultiplier > 1) {
                reward = Math.floor(reward * vipMultiplier);
                console.log('After VIP bonus:', reward);
            }
            
            // Apply FORM bonus/penalty
            const form = fighter.gameData.form || 100;
            reward = applyFormToTraining(reward, form);
            console.log('After form adjustment:', reward);
            
            // Update stat
            const statKey = training.statKey;
            const oldValue = fighter.stats[statKey];
            fighter.stats[statKey] = Math.min(1000, fighter.stats[statKey] + reward);
            const newValue = fighter.stats[statKey];
            
            console.log('=== TRAINING STAT UPDATE ===');
            console.log('Stat:', statKey);
            console.log('Old value:', oldValue);
            console.log('Reward:', reward);
            console.log('New value:', newValue);
            console.log('===========================');
            
            // Track training completion
            gameState.totalTrainings = (gameState.totalTrainings || 0) + 1;
            
            // Clear training
            delete fighter.training[type];
            
            saveGameSync(characterData);
            
            // Check achievements
            checkAchievements(characterData);
            
            // Build toast message
            let toastMessage = `${TRAINING_TYPES[type].icon} ${TRAINING_TYPES[type].name} +${reward}`;
            if (talentBonus > 0) {
                toastMessage += `\n🔥 Талант: +${talentBonus}%`;
            }
            if (teamBonuses.trainingBonus > 0) {
                toastMessage += `\n👥 Тренер: +${Math.round(teamBonuses.trainingBonus * 100)}%`;
            }
            if (vipMultiplier > 1) {
                toastMessage += '\n⭐ VIP бонус: +20%';
            }
            if (form < 100) {
                toastMessage += `\n⚠️ Форма ${form}%`;
            }
            
            showToast('🎉 Тренування завершено!', toastMessage, 'success');
            
            loadTrainingScreen();
            updateResourceBar(); // Update rating display
            
            // Check for random event after training
            triggerRandomEventCheck();
        }
        
        function boostTraining(type) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            if (gameState.stars < 10) {
                alert('Недостатньо Stars! Потрібно ⭐ 10');
                return;
            }
            
            // Deduct stars
            gameState.stars -= 10;
            
            // Complete training instantly
            saveGameSync(characterData);
            completeTraining(type);
        }
        
        function getTalentBonus(talent) {
            if (talent <= 3) return 10;
            if (talent <= 5) return 25;
            if (talent <= 7) return 45;
            if (talent <= 9) return 70;
            return 100;
        }
        
        function openFights() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            
            // ЗАХИСТ: перевірка наявності бійців
            if (!characterData.fighters || characterData.fighters.length === 0) {
                alert('⚠️ Немає бійців!\n\nКупи нового боксера в Академії.');
                openAcademy();
                return;
            }
            
            const activeFighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (!activeFighter || activeFighter.retired) {
                alert('⚠️ Немає активного боксера!\n\nОбери боксера або найми нового в Академії.');
                return;
            }
            
            showScreen('fightsScreen');
            loadFightsScreen();
        }
        
        // FIGHTS SYSTEM
        let fightCooldownTimer = null;
        
        function loadFightsScreen() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const gameState = characterData.gameState;
            
            // Check cooldown for this specific fighter
            if (!fighter.fightCooldown) {
                fighter.fightCooldown = {};
            }
            
            if (fighter.fightCooldown.nextAvailable && fighter.fightCooldown.nextAvailable > Date.now()) {
                showFightCooldown(fighter.fightCooldown.nextAvailable);
                return;
            }
            
            // Hide cooldown, show fights
            document.getElementById('fightsCooldown').style.display = 'none';
            document.getElementById('fightsContent').style.display = 'block';
            
            // Generate 3 opponents
            const opponents = generateOpponents(fighter, gameState);
            renderOpponents(opponents);
        }
        
        function showFightCooldown(endTime) {
            const cooldownDiv = document.getElementById('fightsCooldown');
            const fightsContent = document.getElementById('fightsContent');
            
            cooldownDiv.style.display = 'block';
            fightsContent.style.display = 'none';
            
            cooldownDiv.innerHTML = `
                <div class="fights-cooldown">
                    <div class="cooldown-text">⏱️ Твій боксер відпочиває</div>
                    <div class="cooldown-timer" id="cooldownTimer">00:00</div>
                    <button class="cooldown-skip-btn" onclick="skipFightCooldown()">
                        ⚡ ПРОПУСТИТИ (⭐ 10)
                    </button>
                </div>
            `;
            
            // Start cooldown timer
            if (fightCooldownTimer) clearInterval(fightCooldownTimer);
            
            fightCooldownTimer = setInterval(() => {
                const remaining = Math.max(0, endTime - Date.now());
                
                if (remaining <= 0) {
                    clearInterval(fightCooldownTimer);
                    loadFightsScreen();
                    return;
                }
                
                const hours = Math.floor(remaining / 3600000);
                const minutes = Math.floor((remaining % 3600000) / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                
                const timerEl = document.getElementById('cooldownTimer');
                if (timerEl) {
                    timerEl.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
            }, 1000);
        }
        
        function skipFightCooldown() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (gameState.stars < 10) {
                alert('Недостатньо Stars! Потрібно ⭐ 10');
                return;
            }
            
            gameState.stars -= 10;
            
            // Clear fighter's cooldown
            if (fighter.fightCooldown) {
                delete fighter.fightCooldown.nextAvailable;
            }
            
            saveGameSync(characterData);
            
            if (fightCooldownTimer) clearInterval(fightCooldownTimer);
            loadFightsScreen();
        }
        
        function generateOpponents(fighter, gameState) {
            // Initialize ranking system
            initializeRankingSystem(fighter);
            
            console.log('=== GENERATE OPPONENTS ===');
            console.log('Fighter rating:', fighter.gameData.rating);
            console.log('Wins in tier:', fighter.gameData.winsInCurrentTier);
            
            const firstNames = ['Іван', 'Максим', 'Олег', 'Дмитро', 'Андрій', 'Сергій', 'Артем', 'Віктор'];
            const lastNames = ['Коваль', 'Петров', 'Сидоров', 'Мельник', 'Шевченко', 'Бойко', 'Іванов', 'Гончар'];
            const nicknames = ['Буря', 'Залізний', 'Вогонь', 'Гром', 'Тінь', 'Хижак', 'Ураган', 'Молот'];
            const avatars = ['🥊', '👊', '💪'];
            
            const playerRating = fighter.gameData.rating || 0;
            const currentTier = getCurrentTier(playerRating);
            
            console.log('Current tier:', currentTier.name);
            
            // Check if player is close to tier limit and needs to fight boss
            const isNearTierLimit = playerRating >= (currentTier.maxRating - 25);
            const hasRequiredWins = (fighter.gameData.winsInCurrentTier || 0) >= 3;
            
            console.log('Near tier limit?', isNearTierLimit, `(${playerRating} >= ${currentTier.maxRating - 25})`);
            console.log('Has required wins?', hasRequiredWins);
            
            // Find the GATEKEEPER belt for current tier (belt at tier boundary)
            // This is the belt with minRating == currentTier.maxRating + 1
            const gatekeeperBelt = CHAMPIONSHIP_BELTS.find(b => 
                b.minRating === (currentTier.maxRating + 1)
            );
            
            console.log('Gatekeeper belt:', gatekeeperBelt?.name || 'none');
            
            // Check if player already has this belt
            const alreadyHasBelt = gatekeeperBelt && fighter.belts && fighter.belts[gatekeeperBelt.id];
            const needsBossFight = isNearTierLimit && hasRequiredWins && gatekeeperBelt && !alreadyHasBelt;
            
            console.log('Already has belt?', alreadyHasBelt);
            console.log('Needs boss fight?', needsBossFight);
            console.log('Current rating:', playerRating, 'Belt minRating:', gatekeeperBelt?.minRating);
            
            // If player needs to fight boss - ONLY show the boss
            if (needsBossFight) {
                console.log('🔒 BOSS FIGHT REQUIRED! Only showing:', gatekeeperBelt.name);
                const boss = generateChampion(gatekeeperBelt, playerRating, true); // true = isGatekeeper
                boss.isGatekeeperBoss = true; // Special flag
                return [boss];
            }
            
            // Generate regular opponents
            // Calculate reward multiplier based on tier
            const tierMultiplier = 1 + (currentTier.number * 0.5); // Tier 1=1.5x, Tier 2=2x, Tier 3=2.5x...
            
            console.log('💰 Tier multiplier:', tierMultiplier, 'for tier:', currentTier.name);
            
            const difficulties = [
                { name: 'easy', ratingDiff: -50, baseReward: 500, rep: 50, difficulty: 'Легкий' },
                { name: 'medium', ratingDiff: 0, baseReward: 1000, rep: 100, difficulty: 'Рівний' },
                { name: 'hard', ratingDiff: 100, baseReward: 2000, rep: 200, difficulty: 'Важкий' }
            ];
            
            const opponents = difficulties.map(diff => {
                const wins = Math.floor(Math.random() * 20) + 5;
                const losses = Math.floor(Math.random() * 10);
                const draws = Math.floor(Math.random() * 3);
                
                // Calculate reward with tier multiplier
                const reward = Math.floor(diff.baseReward * tierMultiplier);
                
                return {
                    firstName: firstNames[Math.floor(Math.random() * firstNames.length)],
                    lastName: lastNames[Math.floor(Math.random() * lastNames.length)],
                    nickname: nicknames[Math.floor(Math.random() * nicknames.length)],
                    avatar: avatars[Math.floor(Math.random() * avatars.length)],
                    rating: Math.max(0, playerRating + diff.ratingDiff + Math.floor(Math.random() * 50 - 25)),
                    record: { wins, losses, draws },
                    difficulty: diff.name,
                    difficultyLabel: diff.difficulty,
                    cashReward: reward, // Динамічна нагорода!
                    repReward: diff.rep,
                    stats: calculateOpponentStats(currentTier, diff.name), // Use tier and difficulty name
                    isChampion: false
                };
            });
            
            // Add championship challenges if player already passed the gatekeeper
            const availableBelts = getAvailableBelts(playerRating);
            console.log('Available belts:', availableBelts.map(b => b.name));
            
            for (let belt of availableBelts) {
                // Skip the gatekeeper belt - it only appears when needed
                const isGatekeeperBelt = belt.minRating === currentTier.maxRating + 1;
                if (isGatekeeperBelt) continue;
                
                console.log(`Checking belt: ${belt.name}`);
                console.log(`  Min rating: ${belt.minRating}, Player rating: ${playerRating}`);
                console.log(`  Wins in tier: ${fighter.gameData?.winsInCurrentTier || 0}`);
                console.log(`  Has belt already: ${fighter.belts && fighter.belts[belt.id]}`);
                
                if (canChallengeForBelt(fighter, belt)) {
                    console.log(`  ✅ CAN CHALLENGE FOR ${belt.name}!`);
                    const champion = generateChampion(belt, playerRating);
                    opponents.push(champion);
                } else {
                    console.log(`  ❌ Cannot challenge yet`);
                }
            }
            
            // Add mandatory title defenses
            const beltsNeedingDefense = getBeltsNeedingDefense(fighter);
            console.log('Belts needing defense:', beltsNeedingDefense.length);
            
            for (let belt of beltsNeedingDefense) {
                const challenger = generateChampion(belt, playerRating);
                challenger.difficultyLabel = `Захист ${belt.name}`;
                challenger.isTitleDefense = true;
                challenger.cashReward = belt.reward.cash * 0.5;
                opponents.push(challenger);
            }
            
            console.log('Total opponents:', opponents.length);
            console.log('Champions:', opponents.filter(o => o.isChampion).length);
            
            return opponents;
        }
        
        function calculateOpponentStats(currentTier, difficulty) {
            // Use fixed stat ranges from tier configuration
            const statRange = currentTier.opponentStats[difficulty];
            
            if (!statRange) {
                // Fallback if no range defined
                console.error('No stat range for difficulty:', difficulty);
                return { power: 50, speed: 50, stamina: 50, defense: 50 };
            }
            
            // Generate random stats within the fixed range
            const generateStat = () => {
                return Math.floor(Math.random() * (statRange.max - statRange.min + 1)) + statRange.min;
            };
            
            return {
                power: generateStat(),
                speed: generateStat(),
                stamina: generateStat(),
                defense: generateStat()
            };
        }
        
        function renderOpponents(opponents) {
            // Store opponents globally
            generatedOpponents = opponents;
            
            const content = document.getElementById('fightsContent');
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            const playerRating = fighter.gameData?.rating || 0;
            const currentTier = getCurrentTier(playerRating);
            
            // Add tier badge at top
            content.innerHTML = `
                <div style="background: linear-gradient(135deg, ${currentTier.color}20, ${currentTier.color}10); 
                            border: 1px solid ${currentTier.color}40; border-radius: 12px; 
                            padding: 1rem; margin-bottom: 1.5rem; text-align: center;">
                    <div style="font-size: 2rem; margin-bottom: 0.5rem;">${currentTier.icon}</div>
                    <div style="color: ${currentTier.color}; font-weight: 700; font-size: 1.1rem; margin-bottom: 0.3rem;">
                        ${currentTier.name}
                    </div>
                    <div style="color: rgba(255,255,255,0.7); font-size: 0.9rem; margin-bottom: 0.5rem;">
                        Рейтинг: ${playerRating} | Перемог у рівні: ${fighter.gameData?.winsInCurrentTier || 0}
                    </div>
                    
                    ${currentTier.opponentStats ? `
                        <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 0.7rem; margin-top: 0.7rem;">
                            <div style="color: rgba(255,255,255,0.9); font-size: 0.85rem; font-weight: 600; margin-bottom: 0.4rem;">
                                📊 Діапазони противників:
                            </div>
                            <div style="display: flex; gap: 0.7rem; font-size: 0.75rem;">
                                <div style="flex: 1;">
                                    <span style="color: #4ade80;">Легкий:</span>
                                    <span style="color: rgba(255,255,255,0.7);">${currentTier.opponentStats.easy.min}-${currentTier.opponentStats.easy.max}</span>
                                </div>
                                <div style="flex: 1;">
                                    <span style="color: #fbbf24;">Рівний:</span>
                                    <span style="color: rgba(255,255,255,0.7);">${currentTier.opponentStats.medium.min}-${currentTier.opponentStats.medium.max}</span>
                                </div>
                                <div style="flex: 1;">
                                    <span style="color: #ef4444;">Важкий:</span>
                                    <span style="color: rgba(255,255,255,0.7);">${currentTier.opponentStats.hard.min}-${currentTier.opponentStats.hard.max}</span>
                                </div>
                            </div>
                            <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem; margin-top: 0.4rem; text-align: center;">
                                💡 Противники не ростуть - готуйся до переходу!
                            </div>
                        </div>
                    ` : ''}
                    
                    ${fighter.belts && Object.keys(fighter.belts).length > 0 ? `
                        <div style="margin-top: 0.8rem; padding-top: 0.8rem; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="color: var(--gold); font-weight: 600; margin-bottom: 0.5rem;">🏆 Твої пояси:</div>
                            <div style="display: flex; gap: 0.8rem; justify-content: center; flex-wrap: wrap;">
                                ${Object.keys(fighter.belts).map(beltId => {
                                    const belt = CHAMPIONSHIP_BELTS.find(b => b.id === beltId);
                                    const beltData = fighter.belts[beltId];
                                    return belt ? `
                                        <div style="background: rgba(255,215,0,0.1); padding: 0.5rem 1rem; border-radius: 8px; border: 1px solid rgba(255,215,0,0.3);">
                                            <div style="font-size: 1.3rem;">${belt.icon}</div>
                                            <div style="font-size: 0.75rem; color: rgba(255,255,255,0.8);">${belt.name}</div>
                                            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.6);">Захистів: ${beltData.defenses}</div>
                                        </div>
                                    ` : '';
                                }).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            opponents.forEach((opp, index) => {
                const card = document.createElement('div');
                card.className = 'opponent-card';
                
                // Special styling for champions
                if (opp.isChampion) {
                    card.style.border = `2px solid ${opp.belt.color}`;
                    card.style.background = `linear-gradient(135deg, ${opp.belt.color}10, rgba(0,0,0,0))`;
                }
                
                const ratingDiff = opp.rating - playerRating;
                const ratingClass = ratingDiff > 0 ? 'positive' : ratingDiff < 0 ? 'negative' : '';
                const ratingSign = ratingDiff > 0 ? '+' : '';
                
                card.innerHTML = `
                    <div class="opponent-header">
                        <div class="opponent-avatar" style="${opp.isChampion ? `font-size: 2.5rem; filter: drop-shadow(0 0 10px ${opp.belt.color});` : ''}">${opp.avatar}</div>
                        <div class="opponent-info">
                            <div class="opponent-name">${opp.firstName} "${opp.nickname}" ${opp.lastName}</div>
                            ${opp.isChampion ? `
                                <div style="color: ${opp.belt.color}; font-weight: 700; font-size: 0.9rem; margin-top: 0.2rem;">
                                    ${opp.belt.icon} ${opp.belt.name}
                                </div>
                            ` : ''}
                            <div class="opponent-details">
                                <span>Рекорд: ${opp.record.wins}-${opp.record.losses}-${opp.record.draws}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="difficulty-badge difficulty-${opp.difficulty}" style="${opp.isChampion ? `background: ${opp.belt.color}; color: white;` : ''}">
                        ${opp.isTitleDefense ? '🛡️ ' : ''}${opp.difficultyLabel}
                    </div>
                    
                    <div class="opponent-stats">
                        <div class="opponent-stat">
                            <div class="opponent-stat-label">Рейтинг</div>
                            <div class="opponent-stat-value ${ratingClass}">${opp.rating} (${ratingSign}${ratingDiff})</div>
                        </div>
                        <div class="opponent-stat">
                            <div class="opponent-stat-label">Оверол</div>
                            <div class="opponent-stat-value">${Math.floor((opp.stats.power + opp.stats.speed + opp.stats.stamina + opp.stats.defense) / 4)}</div>
                        </div>
                    </div>
                    
                    <div class="opponent-rewards">
                        <div class="rewards-label">Нагорода за перемогу:</div>
                        <div class="rewards-values">
                            <span>💵 $${formatNumber(opp.cashReward)}</span>
                            <span>📈 +${opp.isChampion ? 50 : (opp.difficulty === 'hard' ? 50 : (opp.difficulty === 'easy' ? 15 : 25))} рейтинг</span>
                            ${opp.starsReward ? `<span>⭐ +${opp.starsReward}</span>` : ''}
                        </div>
                    </div>
                    
                    ${opp.isChampion && !opp.isTitleDefense ? `
                        <div style="background: ${opp.isGatekeeperBoss ? 'rgba(239,68,68,0.15)' : 'rgba(255,215,0,0.1)'}; 
                                    border: 1px solid ${opp.isGatekeeperBoss ? 'rgba(239,68,68,0.4)' : 'rgba(255,215,0,0.3)'}; 
                                    border-radius: 8px; padding: 0.8rem; margin-bottom: 1rem; text-align: center;">
                            ${opp.isGatekeeperBoss ? `
                                <div style="color: #f87171; font-weight: 700; margin-bottom: 0.3rem; font-size: 1.1rem;">
                                    🔒 ОБОВ'ЯЗКОВИЙ БІЙ!
                                </div>
                                <div style="font-size: 0.85rem; color: rgba(255,255,255,0.8); line-height: 1.4;">
                                    Щоб перейти на наступний рівень, треба перемогти чемпіона!<br>
                                    <strong>Перемога:</strong> новий рівень + пояс ${opp.belt.name}<br>
                                    <strong>Поразка:</strong> залишаєшся на поточному рівні
                                </div>
                            ` : `
                                <div style="color: var(--gold); font-weight: 600; margin-bottom: 0.3rem;">🏆 Чемпіонський бій!</div>
                                <div style="font-size: 0.85rem; color: rgba(255,255,255,0.7);">
                                    Перемога дає пояс ${opp.belt.name}
                                </div>
                            `}
                        </div>
                    ` : ''}
                    
                    ${opp.isTitleDefense ? `
                        <div style="background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); border-radius: 8px; padding: 0.8rem; margin-bottom: 1rem; text-align: center;">
                            <div style="color: #f87171; font-weight: 600; margin-bottom: 0.3rem;">⚠️ ОБОВ'ЯЗКОВИЙ ЗАХИСТ!</div>
                            <div style="font-size: 0.85rem; color: rgba(255,255,255,0.7);">
                                Поразка = втрата поясу
                            </div>
                        </div>
                    ` : ''}
                    
                    <button class="fight-button" onclick="startFightByIndex(${index})" 
                            style="${opp.isChampion ? `background: linear-gradient(135deg, ${opp.belt.color}, ${opp.belt.color}dd); border: none; font-weight: 700;` : ''}">
                        ${opp.isTitleDefense ? '🛡️ ЗАХИСТИТИ ТИТУЛ' : '🥊 ВИКЛИКАТИ НА БІЙ'}
                    </button>
                `;
                
                content.appendChild(card);
            });
        }
        
        // ===== NEW FIGHT SYSTEM (SIMPLE & WORKING) =====
        
        // GLOBAL: Store selected opponent for tactics modal
        let pendingFightOpponent = null;
        let selectedTactic = 'balanced'; // Default
        
        function startFightByIndex(index) {
            console.log('Fight button clicked, index:', index);
            const opponent = generatedOpponents[index];
            if (!opponent) {
                console.error('Opponent not found');
                return;
            }
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            // Check for injury
            if (fighter.injury && fighter.injury.healTime > Date.now()) {
                showToast('Боєць травмований! Зачекай повного відновлення або вилікуй! 🏥', 'error');
                openTreatmentModal();
                return;
            }
            
            console.log('Showing tactics selection for:', fighter.firstName, 'vs', opponent.firstName);
            
            // Store opponent and show tactics modal
            pendingFightOpponent = opponent;
            showTacticsModal();
        }
        
        function showTacticsModal() {
            const modal = document.getElementById('tacticsModal');
            modal.classList.add('active');
        }
        
        function closeTacticsModal() {
            const modal = document.getElementById('tacticsModal');
            modal.classList.remove('active');
            pendingFightOpponent = null;
        }
        
        function selectTactic(tactic) {
            selectedTactic = tactic;
            
            // Remove selected class from all
            document.querySelectorAll('.tactic-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Add selected class to chosen
            document.querySelector(`[data-tactic="${tactic}"]`).classList.add('selected');
        }
        
        function confirmTactics() {
            if (!pendingFightOpponent) {
                console.error('No pending fight');
                return;
            }
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            // ВАЖЛИВО: Зберегти opponent ПЕРЕД закриттям модалки!
            const opponent = pendingFightOpponent;
            
            console.log('Starting fight with tactic:', selectedTactic);
            console.log('Fighter:', fighter);
            console.log('Opponent:', opponent);
            
            closeTacticsModal();
            
            // Show fight screen
            showScreen('fightSimScreen');
            
            // Start simulation with selected tactic (використовуємо збережений opponent!)
            runFightSimulation(fighter, opponent, selectedTactic);
        }
        
        // Apply tactic modifiers to stats
        function applyTacticModifiers(stats, tactic) {
            // Ensure stats exist
            if (!stats || typeof stats !== 'object') {
                console.error('Invalid stats passed to applyTacticModifiers:', stats);
                return {
                    power: 50,
                    speed: 50,
                    stamina: 50,
                    defense: 50,
                    koChance: 1.0
                };
            }
            
            // Create a deep copy to avoid modifying original
            const modified = {
                power: stats.power || 50,
                speed: stats.speed || 50,
                stamina: stats.stamina || 50,
                defense: stats.defense || 50
            };
            
            switch(tactic) {
                case 'aggressive':
                    modified.power = Math.floor(modified.power * 1.2); // +20% damage
                    modified.defense = Math.floor(modified.defense * 0.8); // -20% defense
                    modified.koChance = 1.3; // +30% KO chance
                    console.log('🔴 AGGRESSIVE: +20% power, -20% defense, +30% KO chance');
                    break;
                    
                case 'defensive':
                    modified.defense = Math.floor(modified.defense * 1.3); // +30% defense
                    modified.stamina = Math.floor(modified.stamina * 1.2); // +20% stamina
                    modified.power = Math.floor(modified.power * 0.8); // -20% damage
                    modified.koChance = 0.7; // -30% KO chance
                    console.log('🔵 DEFENSIVE: +30% defense, +20% stamina, -20% power');
                    break;
                    
                case 'balanced':
                default:
                    modified.koChance = 1.0; // Normal KO chance
                    console.log('🟡 BALANCED: No modifiers');
                    break;
            }
            
            return modified;
        }
        
        // ===== JUDGES SCORING SYSTEM =====
        // Функція підрахунку очок за раунд (викликається в кінці кожного раунду)
        function scoreRound(roundNumber, pHits, oHits, pKD, oKD, judge1, judge2, judge3, rounds, log) {
            let playerScore = 10;
            let opponentScore = 10;
            
            // 1. Базовий рахунок: хто більше вдарив
            if (pHits > oHits * 1.5) {
                // Гравець значно домінував
                opponentScore = 9;
            } else if (oHits > pHits * 1.5) {
                // Опонент значно домінував
                playerScore = 9;
            }
            // Інакше 10-10 (рівний раунд)
            
            // 2. Нокдауни віднімають очки (кожен нокдаун = -1 очко)
            if (pKD > 0) {
                opponentScore -= pKD;
            }
            if (oKD > 0) {
                playerScore -= oKD;
            }
            
            // Мінімум 6 очок (рідко але можливо при кількох нокдаунах)
            playerScore = Math.max(6, playerScore);
            opponentScore = Math.max(6, opponentScore);
            
            // 3. Додати до загальних рахунків кожного судді (з невеликою варіацією)
            // Суддя 1 (консервативний)
            judge1.player += playerScore;
            judge1.opponent += opponentScore;
            
            // Суддя 2 (нейтральний, може бачити по-іншому)
            const variation2 = Math.random() < 0.15 ? (Math.random() < 0.5 ? 1 : -1) : 0;
            judge2.player += Math.max(6, playerScore + variation2);
            judge2.opponent += Math.max(6, opponentScore - variation2);
            
            // Суддя 3 (незалежний, може бачити по-іншому)
            const variation3 = Math.random() < 0.15 ? (Math.random() < 0.5 ? 1 : -1) : 0;
            judge3.player += Math.max(6, playerScore + variation3);
            judge3.opponent += Math.max(6, opponentScore - variation3);
            
            // 4. Зберегти результат раунду для історії
            const winner = playerScore > opponentScore ? 'player' : 
                          opponentScore > playerScore ? 'opponent' : 'draw';
            
            rounds.push({
                round: roundNumber,
                playerScore,
                opponentScore,
                winner,
                playerHits: pHits,
                opponentHits: oHits,
                playerKnockdowns: pKD,
                opponentKnockdowns: oKD
            });
            
            // 5. Додати у лог
            const scoreText = `${playerScore}-${opponentScore}`;
            const winnerText = winner === 'player' ? '(Ти)' : 
                              winner === 'opponent' ? '(Опонент)' : '(Рівно)';
            
            log.innerHTML += `<div class="fight-log-entry neutral" style="opacity: 0.7; font-size: 0.9em;">📋 Раунд ${roundNumber}: ${scoreText} ${winnerText}</div>`;
            log.scrollTop = log.scrollHeight;
        }
        
        // ===== ДЕТАЛЬНА СТАТИСТИКА =====
        function showDetailedStats(fightStats, rounds, player, opponent, result) {
            console.log('=== SHOWING DETAILED STATS ===');
            console.log('fightStats:', fightStats);
            console.log('rounds:', rounds);
            console.log('result:', result);
            
            // ДІАГНОСТИКА
            if (!fightStats) {
                console.error('❌ fightStats is null!');
                alert('БАГ: fightStats is null! Статистика не може показатись.');
                return;
            }
            if (!rounds) {
                console.error('❌ rounds is null!');
                alert('БАГ: rounds is null!');
                rounds = [];
            }
            
            console.log('✅ Starting to show stats...');
            
            const log = document.getElementById('fightLog');
            if (!log) {
                console.error('❌ fightLog element not found!');
                alert('БАГ: fightLog елемент не знайдено!');
                return;
            }
            
            // Розрахунки
            const totalPlayerPunches = fightStats.playerHits + fightStats.playerMisses;
            const totalOpponentPunches = fightStats.opponentHits + fightStats.opponentMisses;
            
            const playerAccuracy = totalPlayerPunches > 0 ? 
                Math.round((fightStats.playerHits / totalPlayerPunches) * 100) : 0;
            const opponentAccuracy = totalOpponentPunches > 0 ?
                Math.round((fightStats.opponentHits / totalOpponentPunches) * 100) : 0;
            
            // Знайти кращий раунд для гравця
            let bestRound = 1;
            let bestScore = 0;
            rounds.forEach(r => {
                const scoreDiff = r.playerScore - r.opponentScore;
                if (scoreDiff > bestScore) {
                    bestScore = scoreDiff;
                    bestRound = r.round;
                }
            });
            
            // Оцінка виступу (A+ до F)
            let grade = 'C';
            if (result === 'win') {
                if (playerAccuracy >= 70 && fightStats.playerMaxCombo >= 5) grade = 'A+';
                else if (playerAccuracy >= 60 && fightStats.playerMaxCombo >= 4) grade = 'A';
                else if (playerAccuracy >= 50) grade = 'B';
                else grade = 'C';
            } else if (result === 'loss') {
                if (playerAccuracy < 30) grade = 'F';
                else if (playerAccuracy < 40) grade = 'D';
                else grade = 'C';
            } else {
                grade = 'B'; // Нічия
            }
            
            // Показати детальну статистику
            log.innerHTML += `<div class="fight-log-entry neutral" style="margin-top: 1rem; font-weight: bold; font-size: 1.1em;">📊 ДЕТАЛЬНА СТАТИСТИКА:</div>`;
            log.innerHTML += `<div class="fight-log-entry neutral" style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 0.5rem;">🎯 Точність: ${playerAccuracy}% (${fightStats.playerHits}/${totalPlayerPunches}) vs ${opponentAccuracy}% (${fightStats.opponentHits}/${totalOpponentPunches})</div>`;
            log.innerHTML += `<div class="fight-log-entry neutral">💥 Загальний урон: ${fightStats.playerTotalDamage} HP vs ${fightStats.opponentTotalDamage} HP</div>`;
            log.innerHTML += `<div class="fight-log-entry neutral">⚡ Максимальний удар: ${fightStats.playerMaxDamage} HP vs ${fightStats.opponentMaxDamage} HP</div>`;
            log.innerHTML += `<div class="fight-log-entry neutral">🔥 Найдовше комбо: x${fightStats.playerMaxCombo} vs x${fightStats.opponentMaxCombo}</div>`;
            
            if (rounds.length > 0) {
                log.innerHTML += `<div class="fight-log-entry neutral">⭐ Кращий раунд: Раунд ${bestRound} (${rounds[bestRound-1]?.playerScore}-${rounds[bestRound-1]?.opponentScore})</div>`;
            }
            
            log.innerHTML += `<div class="fight-log-entry ${result === 'win' ? 'player' : result === 'loss' ? 'opponent' : 'neutral'}" style="font-weight: bold; font-size: 1.2em; margin-top: 0.5rem;">💯 Оцінка виступу: ${grade}</div>`;
            
            // МАРКЕР ДЛЯ ДІАГНОСТИКИ
            log.innerHTML += `<div class="fight-log-entry neutral" style="background: red; color: white; font-size: 2em; padding: 1rem; margin: 1rem 0;">🔴 СТАТИСТИКА ПОКАЗАНА! 🔴</div>`;
            
            log.scrollTop = log.scrollHeight;
            
            console.log('✅ Detailed stats shown successfully!');
            console.log('Grade:', grade);
            console.log('Player accuracy:', playerAccuracy + '%');
        }
        
        function runFightSimulation(player, opponent, tactic = 'balanced') {
            try {
                console.log('=== Fight simulation started ===');
                console.log('Player:', player);
                console.log('Opponent:', opponent);
                console.log('Selected tactic:', tactic);
                
                // Validate inputs
                if (!player || !opponent) {
                    throw new Error('Player or opponent is null');
                }
                
                if (!player.stats || !opponent.stats) {
                    throw new Error('Player or opponent stats are missing');
                }
                
                // Setup display
                document.getElementById('simPlayerAvatar').textContent = player.avatar || '🥊';
                document.getElementById('simPlayerName').textContent = `${player.firstName} "${player.nickname}"`;
                document.getElementById('simOpponentAvatar').textContent = opponent.avatar || '👊';
                document.getElementById('simOpponentName').textContent = `${opponent.firstName} "${opponent.nickname}"`;
                
                // Clear log
                const log = document.getElementById('fightLog');
                log.innerHTML = '';
                
                // Fight variables
                let playerHP = 100;
                let opponentHP = 100;
                let currentRound = 1;
                const maxRounds = 12;
                
                // NEW: Combat mechanics variables
                let playerCombo = 0;
                let opponentCombo = 0;
                let playerStamina = 100;
                let opponentStamina = 100;
                
                // KNOCKDOWN SYSTEM
                let playerKnockdowns = 0;
                let opponentKnockdowns = 0;
                
                // JUDGES SCORING SYSTEM
                let judge1Score = { player: 0, opponent: 0 };
                let judge2Score = { player: 0, opponent: 0 };
                let judge3Score = { player: 0, opponent: 0 };
                let roundScores = []; // Історія кожного раунду
                let playerRoundHits = 0; // Лічильник ударів у поточному раунді
                let opponentRoundHits = 0;
                let playerRoundKnockdowns = 0; // Нокдауни у поточному раунді
                let opponentRoundKnockdowns = 0;
                
                let fightStats = {
                    playerHits: 0,
                    opponentHits: 0,
                    playerCrits: 0,
                    opponentCrits: 0,
                    playerBlocks: 0,
                    opponentBlocks: 0,
                    knockdowns: 0,
                    // ДЕТАЛЬНА СТАТИСТИКА
                    playerMisses: 0,
                    opponentMisses: 0,
                    playerTotalDamage: 0,
                    opponentTotalDamage: 0,
                    playerMaxDamage: 0,
                    opponentMaxDamage: 0,
                    playerMaxCombo: 0,
                    opponentMaxCombo: 0,
                    bestRoundForPlayer: { round: 1, score: 0 },
                    roundDetails: []  // Деталі кожного раунду
                };
                
                // Get player form
                const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
                const activeFighter = characterData.fighters[characterData.activeFighterIndex];
                
                // Initialize gameData if doesn't exist
                if (!activeFighter.gameData) {
                    activeFighter.gameData = { form: 100 };
                }
                
                const playerForm = activeFighter.gameData.form || 100;
                
                // Apply injury effects to stats
                let playerStats = applyInjuryEffects(player);
                
                // APPLY TACTIC BONUSES
                playerStats = applyTacticModifiers(playerStats, tactic);
                
                // Add intro log entries
                log.innerHTML += `<div class="fight-log-entry neutral" style="font-weight: bold; font-size: 1.1em;">🔔 БІЙ РОЗПОЧАВСЯ!</div>`;
                
                // Show tactic
                const tacticInfo = {
                    aggressive: { icon: '🔴', name: 'АГРЕСИВНИЙ СТИЛЬ' },
                    defensive: { icon: '🔵', name: 'ОБОРОННИЙ СТИЛЬ' },
                    balanced: { icon: '🟡', name: 'ЗБАЛАНСОВАНИЙ СТИЛЬ' }
                };
                log.innerHTML += `<div class="fight-log-entry player" style="font-weight: bold;">${tacticInfo[tactic].icon} ${player.firstName} обрав ${tacticInfo[tactic].name}</div>`;
                
                log.innerHTML += `<div class="fight-log-entry neutral" style="opacity: 0.7;">📊 ${player.firstName} (Оверол: ${Math.round((playerStats.power + playerStats.speed + playerStats.stamina + playerStats.defense) / 4)})</div>`;
                log.innerHTML += `<div class="fight-log-entry neutral" style="opacity: 0.7;">📊 ${opponent.firstName} (Оверол: ${Math.round((opponent.stats.power + opponent.stats.speed + opponent.stats.stamina + opponent.stats.defense) / 4)})</div>`;
                
                // Attack types with different properties
                const attackTypes = [
                    { name: 'джеб', icon: '👊', damage: 0.8, speed: 1.3, stamina: 5 },
                    { name: 'хук', icon: '💥', damage: 1.2, speed: 1.0, stamina: 10 },
                    { name: 'апперкот', icon: '⚡', damage: 1.5, speed: 0.7, stamina: 15 }
                ];
                
                // Helper function to get attack type based on stats
                function chooseAttack(stats, stamina) {
                    if (stamina < 30) return attackTypes[0]; // Low stamina = jabs only
                    const roll = Math.random();
                    if (stats.speed > 80 && roll < 0.5) return attackTypes[0]; // Fast fighters = more jabs
                    if (stats.power > 80 && roll < 0.3) return attackTypes[2]; // Strong fighters = more uppercuts
                    return attackTypes[Math.floor(Math.random() * 3)];
                }
                
                // Helper function to add colored log entry
                function addLog(message, type = 'neutral', isSpecial = false) {
                    const style = isSpecial ? 'font-weight: bold; font-size: 1.05em; animation: pulse 0.3s;' : '';
                    log.innerHTML += `<div class="fight-log-entry ${type}" style="${style}">${message}</div>`;
                    log.scrollTop = log.scrollHeight;
                }
                
                // Start fight loop
                console.log('Starting fight interval...');
                const fightInterval = setInterval(() => {
                    console.log('Round', currentRound);
                    
                    // Check if fight should end (KO/TKO)
                    if (playerHP <= 0 || opponentHP <= 0) {
                        clearInterval(fightInterval);
                        console.log('Fight ended by KO/TKO');
                        
                        // Show final stats
                        addLog('━━━━━━━━━━━━━━━━━━━━', 'neutral');
                        addLog(`📊 СТАТИСТИКА: Удари ${fightStats.playerHits}-${fightStats.opponentHits} | Крити ${fightStats.playerCrits}-${fightStats.opponentCrits} | Нокдауни ${opponentKnockdowns}-${playerKnockdowns}`, 'neutral');
                        
                        finishFight(playerHP, opponentHP, player, opponent, judge1Score, judge2Score, judge3Score, fightStats, roundScores);
                        return;
                    }
                    
                    // Show round number
                    document.getElementById('simRound').textContent = `Раунд ${currentRound}`;
                    addLog(`━━━━━ РАУНД ${currentRound} ━━━━━`, 'neutral', true);
                    
                    // Restore some stamina between rounds
                    playerStamina = Math.min(100, playerStamina + 15);
                    opponentStamina = Math.min(100, opponentStamina + 15);
                    
                    // === PLAYER ATTACK ===
                    const playerAttack = chooseAttack(playerStats, playerStamina);
                    playerStamina -= playerAttack.stamina;
                    
                    // Calculate hit chance based on speed
                    const playerHitChance = 0.6 + (playerStats.speed / 1000) * 0.3;
                    const playerHits = Math.random() < (playerHitChance * playerAttack.speed);
                    
                    if (playerHits) {
                        // Check for opponent block
                        const blockChance = (opponent.stats.defense / 1000) * 0.3;
                        const opponentBlocks = Math.random() < blockChance;
                        
                        if (opponentBlocks) {
                            fightStats.opponentBlocks++;
                            addLog(`${playerAttack.icon} ${player.firstName} атакує (${playerAttack.name}) - 🛡️ ${opponent.firstName} БЛОКУЄ!`, 'neutral');
                        } else {
                            // Calculate damage - more predictable based on stats
                            // Base damage: depends on power stat
                            // Random variance: ±20% instead of huge random range
                            const baseDamage = (playerStats.power / 20) * playerAttack.damage;
                            const variance = 0.2; // ±20%
                            let damage = Math.floor(baseDamage * (1 + (Math.random() * variance * 2 - variance)));
                            
                            // Stamina affects damage (50%-100%)
                            damage = Math.floor(damage * (playerStamina / 100 * 0.5 + 0.5));
                            
                            // ВАЖЛИВО: Мінімум 1 HP урону (інакше може бути 0)
                            damage = Math.max(1, damage);
                            
                            // Check for critical hit (10% chance + speed bonus)
                            const critChance = 0.10 + (playerStats.speed / 1000) * 0.1;
                            const isCrit = Math.random() < critChance;
                            
                            if (isCrit) {
                                damage = Math.floor(damage * 2);
                                fightStats.playerCrits++;
                                addLog(`${playerAttack.icon} ${player.firstName} ${playerAttack.name} - ⚡ КРИТИЧНИЙ УДАР! -${damage} HP`, 'player', true);
                                playerCombo++;
                            } else {
                                addLog(`${playerAttack.icon} ${player.firstName} ${playerAttack.name} - ${damage} HP`, 'player');
                                playerCombo++;
                            }
                            
                            opponentHP -= damage;
                            opponentHP = Math.max(0, opponentHP); // Ensure HP doesn't go below 0
                            fightStats.playerHits++;
                            playerRoundHits++; // Рахуємо удари в раунді
                            
                            // СТАТИСТИКА: загальний та максимальний урон
                            fightStats.playerTotalDamage += damage;
                            if (damage > fightStats.playerMaxDamage) {
                                fightStats.playerMaxDamage = damage;
                            }
                            
                            // СТАТИСТИКА: максимальне комбо
                            if (playerCombo > fightStats.playerMaxCombo) {
                                fightStats.playerMaxCombo = playerCombo;
                            }
                            
                            // KNOCKDOWN CHECK: Великий урон або низький HP можуть викликати нокдаун
                            const knockdownChance = (damage >= 15) ? 
                                (damage / 20) * 0.5 * (opponentHP < 30 ? 1.5 : 1.0) : 0;
                            
                            if (knockdownChance > 0 && Math.random() < knockdownChance) {
                                opponentKnockdowns++;
                                opponentRoundKnockdowns++; // Рахуємо нокдауни опонента в раунді
                                fightStats.knockdowns++;
                                
                                addLog(`💥💥💥 НОКДАУН! ${opponent.firstName} НА КАНВАСІ!`, 'player', true);
                                addLog(`⏱️ Рефері рахує: 1... 2... 3... 4... 5... 6... 7... 8...`, 'neutral');
                                
                                // Перевірка: 3 нокдауни = автоматичний TKO
                                if (opponentKnockdowns >= 3) {
                                    addLog(`🚫 ТРИ НОКДАУНИ! ТЕХНІЧНИЙ НОКАУТ!`, 'player', true);
                                    opponentHP = 0; // Завершити бій
                                    clearInterval(fightInterval);
                                    addLog('━━━━━━━━━━━━━━━━━━━━', 'neutral');
                                    addLog(`📊 СТАТИСТИКА: Удари ${fightStats.playerHits}-${fightStats.opponentHits} | Крити ${fightStats.playerCrits}-${fightStats.opponentCrits} | Нокдауни ${opponentKnockdowns}-${playerKnockdowns}`, 'neutral');
                                    finishFight(playerHP, opponentHP, player, opponent, judge1Score, judge2Score, judge3Score, fightStats, roundScores);
                                    return;
                                }
                                
                                // Боєць піднімається
                                addLog(`💪 ${opponent.firstName} ПІДНІМАЄТЬСЯ! Бій продовжується!`, 'opponent');
                                opponentHP = Math.max(20, opponentHP); // Мінімум 20 HP після нокдауну
                            }
                            
                            // Check if opponent knocked out (тільки якщо HP реально 0)
                            if (opponentHP <= 0) {
                                addLog(`💥 ${opponent.firstName} НОКАУТ!`, 'player', true);
                                clearInterval(fightInterval);
                                addLog('━━━━━━━━━━━━━━━━━━━━', 'neutral');
                                addLog(`📊 СТАТИСТИКА: Удари ${fightStats.playerHits}-${fightStats.opponentHits} | Крити ${fightStats.playerCrits}-${fightStats.opponentCrits} | Нокдауни ${opponentKnockdowns}-${playerKnockdowns}`, 'neutral');
                                finishFight(playerHP, opponentHP, player, opponent, judge1Score, judge2Score, judge3Score, fightStats, roundScores);
                                return;
                            }
                            
                            // Combo bonus
                            if (playerCombo >= 3) {
                                const comboBonus = 5;
                                opponentHP -= comboBonus;
                                opponentHP = Math.max(0, opponentHP);
                                addLog(`🔥 КОМБО x${playerCombo}! Додаткові -${comboBonus} HP`, 'player', true);
                                
                                // Check for knockdown after combo
                                const comboKDChance = 0.15; // 15% шанс нокдауну після комбо
                                if (Math.random() < comboKDChance && opponentHP > 0) {
                                    opponentKnockdowns++;
                                    fightStats.knockdowns++;
                                    
                                    addLog(`💥💥💥 НОКДАУН від КОМБО! ${opponent.firstName} НА КАНВАСІ!`, 'player', true);
                                    addLog(`⏱️ Рефері рахує: 1... 2... 3... 4... 5... 6... 7... 8...`, 'neutral');
                                    
                                    if (opponentKnockdowns >= 3) {
                                        addLog(`🚫 ТРИ НОКДАУНИ! ТЕХНІЧНИЙ НОКАУТ!`, 'player', true);
                                        opponentHP = 0;
                                        clearInterval(fightInterval);
                                        addLog('━━━━━━━━━━━━━━━━━━━━', 'neutral');
                                        addLog(`📊 СТАТИСТИКА: Удари ${fightStats.playerHits}-${fightStats.opponentHits} | Крити ${fightStats.playerCrits}-${fightStats.opponentCrits} | Нокдауни ${opponentKnockdowns}-${playerKnockdowns}`, 'neutral');
                                        finishFight(playerHP, opponentHP, player, opponent, judge1Score, judge2Score, judge3Score, fightStats, roundScores);
                                        return;
                                    }
                                    
                                    addLog(`💪 ${opponent.firstName} ПІДНІМАЄТЬСЯ!`, 'opponent');
                                    opponentHP = Math.max(20, opponentHP);
                                }
                                
                                // Check for KO
                                if (opponentHP <= 0) {
                                    addLog(`💥 ${opponent.firstName} НОКАУТ!`, 'player', true);
                                    clearInterval(fightInterval);
                                    addLog('━━━━━━━━━━━━━━━━━━━━', 'neutral');
                                    addLog(`📊 СТАТИСТИКА: Удари ${fightStats.playerHits}-${fightStats.opponentHits} | Крити ${fightStats.playerCrits}-${fightStats.opponentCrits} | Нокдауни ${opponentKnockdowns}-${playerKnockdowns}`, 'neutral');
                                    finishFight(playerHP, opponentHP, player, opponent, judge1Score, judge2Score, judge3Score, fightStats, roundScores);
                                    return;
                                }
                            }
                        }
                    } else {
                        addLog(`${playerAttack.icon} ${player.firstName} ${playerAttack.name} - ПРОМАХ`, 'player');
                        fightStats.playerMisses++; // Рахуємо промахи
                        playerCombo = 0; // Reset combo on miss
                        
                        // Counter-attack chance on miss
                        if (Math.random() < 0.3) {
                            const counterDamage = Math.floor(5 + opponent.stats.power / 100);
                            playerHP -= counterDamage;
                            playerHP = Math.max(0, playerHP);
                            addLog(`🔄 ${opponent.firstName} КОНТРАТАКА! -${counterDamage} HP`, 'opponent', true);
                            
                            // Check if player knocked out
                            if (playerHP <= 0) {
                                addLog(`💥 ${player.firstName} НОКАУТ!`, 'opponent', true);
                                clearInterval(fightInterval);
                                addLog('━━━━━━━━━━━━━━━━━━━━', 'neutral');
                                addLog(`📊 СТАТИСТИКА: Удари ${fightStats.playerHits}-${fightStats.opponentHits} | Крити ${fightStats.playerCrits}-${fightStats.opponentCrits} | Блоки ${fightStats.playerBlocks}-${fightStats.opponentBlocks}`, 'neutral');
                                finishFight(playerHP, opponentHP, player, opponent, judge1Score, judge2Score, judge3Score, fightStats, roundScores);
                                return;
                            }
                        }
                    }
                    
                    // === OPPONENT ATTACK ===
                    const opponentAttack = chooseAttack(opponent.stats, opponentStamina);
                    opponentStamina -= opponentAttack.stamina;
                    
                    const opponentHitChance = 0.6 + (opponent.stats.speed / 1000) * 0.3;
                    const opponentHitsPlayer = Math.random() < (opponentHitChance * opponentAttack.speed);
                    
                    if (opponentHitsPlayer) {
                        const playerBlockChance = (playerStats.defense / 1000) * 0.3;
                        const playerBlocksHit = Math.random() < playerBlockChance;
                        
                        if (playerBlocksHit) {
                            fightStats.playerBlocks++;
                            addLog(`${opponentAttack.icon} ${opponent.firstName} атакує (${opponentAttack.name}) - 🛡️ ${player.firstName} БЛОКУЄ!`, 'neutral');
                        } else {
                            // Calculate damage - more predictable based on stats
                            const baseDamage = (opponent.stats.power / 20) * opponentAttack.damage;
                            const variance = 0.2; // ±20%
                            let damage = Math.floor(baseDamage * (1 + (Math.random() * variance * 2 - variance)));
                            
                            // Stamina affects damage (50%-100%)
                            damage = Math.floor(damage * (opponentStamina / 100 * 0.5 + 0.5));
                            
                            // ВАЖЛИВО: Мінімум 1 HP урону
                            damage = Math.max(1, damage);
                            
                            const critChance = 0.10 + (opponent.stats.speed / 1000) * 0.1;
                            const isCrit = Math.random() < critChance;
                            
                            if (isCrit) {
                                damage = Math.floor(damage * 2);
                                fightStats.opponentCrits++;
                                addLog(`${opponentAttack.icon} ${opponent.firstName} ${opponentAttack.name} - ⚡ КРИТИЧНИЙ УДАР! -${damage} HP`, 'opponent', true);
                                opponentCombo++;
                            } else {
                                addLog(`${opponentAttack.icon} ${opponent.firstName} ${opponentAttack.name} - ${damage} HP`, 'opponent');
                                opponentCombo++;
                            }
                            
                            playerHP -= damage;
                            playerHP = Math.max(0, playerHP);
                            fightStats.opponentHits++;
                            opponentRoundHits++; // Рахуємо удари опонента в раунді
                            
                            // СТАТИСТИКА: загальний та максимальний урон опонента
                            fightStats.opponentTotalDamage += damage;
                            if (damage > fightStats.opponentMaxDamage) {
                                fightStats.opponentMaxDamage = damage;
                            }
                            
                            // СТАТИСТИКА: максимальне комбо опонента
                            if (opponentCombo > fightStats.opponentMaxCombo) {
                                fightStats.opponentMaxCombo = opponentCombo;
                            }
                            
                            // KNOCKDOWN CHECK для гравця
                            const playerKDChance = (damage >= 15) ? 
                                (damage / 20) * 0.5 * (playerHP < 30 ? 1.5 : 1.0) : 0;
                            
                            if (playerKDChance > 0 && Math.random() < playerKDChance) {
                                playerKnockdowns++;
                                playerRoundKnockdowns++; // Рахуємо нокдауни в раунді
                                fightStats.knockdowns++;
                                
                                addLog(`💥💥💥 НОКДАУН! ${player.firstName} НА КАНВАСІ!`, 'opponent', true);
                                addLog(`⏱️ Рефері рахує: 1... 2... 3... 4... 5... 6... 7... 8...`, 'neutral');
                                
                                // 3 нокдауни = TKO
                                if (playerKnockdowns >= 3) {
                                    addLog(`🚫 ТРИ НОКДАУНИ! ТЕХНІЧНИЙ НОКАУТ!`, 'opponent', true);
                                    playerHP = 0;
                                    clearInterval(fightInterval);
                                    addLog('━━━━━━━━━━━━━━━━━━━━', 'neutral');
                                    addLog(`📊 СТАТИСТИКА: Удари ${fightStats.playerHits}-${fightStats.opponentHits} | Крити ${fightStats.playerCrits}-${fightStats.opponentCrits} | Нокдауни ${opponentKnockdowns}-${playerKnockdowns}`, 'neutral');
                                    finishFight(playerHP, opponentHP, player, opponent, judge1Score, judge2Score, judge3Score, fightStats, roundScores);
                                    return;
                                }
                                
                                addLog(`💪 ${player.firstName} ПІДНІМАЄТЬСЯ! Бій продовжується!`, 'player');
                                playerHP = Math.max(20, playerHP);
                            }
                            
                            // Check if player knocked out
                            if (playerHP <= 0) {
                                addLog(`💥 ${player.firstName} НОКАУТ!`, 'opponent', true);
                                clearInterval(fightInterval);
                                addLog('━━━━━━━━━━━━━━━━━━━━', 'neutral');
                                addLog(`📊 СТАТИСТИКА: Удари ${fightStats.playerHits}-${fightStats.opponentHits} | Крити ${fightStats.playerCrits}-${fightStats.opponentCrits} | Нокдауни ${opponentKnockdowns}-${playerKnockdowns}`, 'neutral');
                                finishFight(playerHP, opponentHP, player, opponent, judge1Score, judge2Score, judge3Score, fightStats, roundScores);
                                return;
                            }
                            
                            if (opponentCombo >= 3) {
                                const comboBonus = 5;
                                playerHP -= comboBonus;
                                playerHP = Math.max(0, playerHP);
                                addLog(`🔥 КОМБО x${opponentCombo}! Додаткові -${comboBonus} HP`, 'opponent', true);
                                
                                // Knockdown chance after combo
                                const comboKDChance = 0.15;
                                if (Math.random() < comboKDChance && playerHP > 0) {
                                    playerKnockdowns++;
                                    fightStats.knockdowns++;
                                    
                                    addLog(`💥💥💥 НОКДАУН від КОМБО! ${player.firstName} НА КАНВАСІ!`, 'opponent', true);
                                    addLog(`⏱️ Рефері рахує: 1... 2... 3... 4... 5... 6... 7... 8...`, 'neutral');
                                    
                                    if (playerKnockdowns >= 3) {
                                        addLog(`🚫 ТРИ НОКДАУНИ! ТЕХНІЧНИЙ НОКАУТ!`, 'opponent', true);
                                        playerHP = 0;
                                        clearInterval(fightInterval);
                                        addLog('━━━━━━━━━━━━━━━━━━━━', 'neutral');
                                        addLog(`📊 СТАТИСТИКА: Удари ${fightStats.playerHits}-${fightStats.opponentHits} | Крити ${fightStats.playerCrits}-${fightStats.opponentCrits} | Нокдауни ${opponentKnockdowns}-${playerKnockdowns}`, 'neutral');
                                        finishFight(playerHP, opponentHP, player, opponent, judge1Score, judge2Score, judge3Score, fightStats, roundScores);
                                        return;
                                    }
                                    
                                    addLog(`💪 ${player.firstName} ПІДНІМАЄТЬСЯ!`, 'player');
                                    playerHP = Math.max(20, playerHP);
                                }
                                
                                // Check for KO
                                if (playerHP <= 0) {
                                    addLog(`💥 ${player.firstName} НОКАУТ!`, 'opponent', true);
                                    clearInterval(fightInterval);
                                    addLog('━━━━━━━━━━━━━━━━━━━━', 'neutral');
                                    addLog(`📊 СТАТИСТИКА: Удари ${fightStats.playerHits}-${fightStats.opponentHits} | Крити ${fightStats.playerCrits}-${fightStats.opponentCrits} | Нокдауни ${opponentKnockdowns}-${playerKnockdowns}`, 'neutral');
                                    finishFight(playerHP, opponentHP, player, opponent, judge1Score, judge2Score, judge3Score, fightStats, roundScores);
                                    return;
                                }
                            }
                        }
                    } else {
                        addLog(`${opponentAttack.icon} ${opponent.firstName} ${opponentAttack.name} - ПРОМАХ`, 'opponent');
                        fightStats.opponentMisses++; // Рахуємо промахи
                        opponentCombo = 0;
                    }
                    
                    // Ensure HP doesn't go below 0
                    if (opponentHP < 0) opponentHP = 0;
                    if (playerHP < 0) playerHP = 0;
                    
                    // === SPECIAL MOMENTS ===
                    
                    // Second wind (below 30% HP)
                    if (playerHP < 30 && playerHP > 0 && currentRound > 6 && Math.random() < 0.15) {
                        addLog(`💪 ${player.firstName} ДРУГИЙ ПОДИХ! Прилив енергії!`, 'player', true);
                        playerStamina = Math.min(100, playerStamina + 30);
                    }
                    
                    if (opponentHP < 30 && opponentHP > 0 && currentRound > 6 && Math.random() < 0.15) {
                        addLog(`💪 ${opponent.firstName} ДРУГИЙ ПОДИХ! Прилив енергії!`, 'opponent', true);
                        opponentStamina = Math.min(100, opponentStamina + 30);
                    }
                    
                    // Update health bars
                    const playerBar = document.getElementById('simPlayerHealth');
                    const opponentBar = document.getElementById('simOpponentHealth');
                    
                    if (playerBar && opponentBar) {
                        playerBar.style.width = playerHP + '%';
                        opponentBar.style.width = opponentHP + '%';
                        
                        // Color health bars (keep base class)
                        playerBar.className = 'fighter-health-fill';
                        opponentBar.className = 'fighter-health-fill';
                        
                        if (playerHP < 30) playerBar.classList.add('critical');
                        else if (playerHP < 60) playerBar.classList.add('low');
                        
                        if (opponentHP < 30) opponentBar.classList.add('critical');
                        else if (opponentHP < 60) opponentBar.classList.add('low');
                    }
                    
                    // JUDGE SCORING - підрахувати очки за раунд (якщо не нокаут)
                    if (playerHP > 0 && opponentHP > 0) {
                        scoreRound(
                            currentRound, 
                            playerRoundHits, 
                            opponentRoundHits, 
                            playerRoundKnockdowns, 
                            opponentRoundKnockdowns,
                            judge1Score,
                            judge2Score,
                            judge3Score,
                            roundScores,
                            log
                        );
                    }
                    
                    // Скинути лічильники раунду
                    playerRoundHits = 0;
                    opponentRoundHits = 0;
                    playerRoundKnockdowns = 0;
                    opponentRoundKnockdowns = 0;
                    
                    currentRound++;
                    
                    // ПЕРЕВІРКА: Чи закінчились раунди (після інкременту!)
                    if (currentRound > maxRounds) {
                        clearInterval(fightInterval);
                        console.log('Fight ended - 12 rounds completed');
                        
                        // Show final stats
                        addLog('━━━━━━━━━━━━━━━━━━━━', 'neutral');
                        addLog(`📊 СТАТИСТИКА: Удари ${fightStats.playerHits}-${fightStats.opponentHits} | Крити ${fightStats.playerCrits}-${fightStats.opponentCrits} | Нокдауни ${opponentKnockdowns}-${playerKnockdowns}`, 'neutral');
                        
                        finishFight(playerHP, opponentHP, player, opponent, judge1Score, judge2Score, judge3Score, fightStats, roundScores);
                        return;
                    }
                }, 2500); // 2.5 seconds per round for better readability
                
            } catch (error) {
                console.error('=== ERROR IN FIGHT SIMULATION ===');
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                console.error('Player:', player);
                console.error('Opponent:', opponent);
                console.error('Tactic:', tactic);
                showToast('Помилка симуляції бою', error.message || 'Невідома помилка', 'error');
                
                // Return to fights screen
                setTimeout(() => {
                    showScreen('fightsScreen');
                }, 2000);
            }
        }
        
        function finishFight(playerHP, opponentHP, player, opponent, judge1 = null, judge2 = null, judge3 = null, fightStats = null, roundScores = null) {
            console.log('=== FINISH FIGHT CALLED ===');
            console.log('Player HP:', playerHP);
            console.log('Opponent HP:', opponentHP);
            
            const log = document.getElementById('fightLog');
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            let result, icon, cash = 0, rep = 0;
            let isKO = false; // Чи закінчився бій нокаутом
            
            // ПОКАЗАТИ СУДЕЙСЬКІ КАРТКИ якщо бій НЕ закінчився KO
            if (playerHP > 0 && opponentHP > 0 && judge1 && judge2 && judge3) {
                // Бій пішов до рішення суддів
                log.innerHTML += `<div class="fight-log-entry neutral" style="margin-top: 1rem; font-weight: bold; font-size: 1.1em;">👨‍⚖️ РАХУНОК СУДДІВ:</div>`;
                
                const j1Winner = judge1.player > judge1.opponent ? player.firstName : 
                                judge1.opponent > judge1.player ? opponent.firstName : 'Нічия';
                const j2Winner = judge2.player > judge2.opponent ? player.firstName :
                                judge2.opponent > judge2.player ? opponent.firstName : 'Нічия';
                const j3Winner = judge3.player > judge3.opponent ? player.firstName :
                                judge3.opponent > judge3.player ? opponent.firstName : 'Нічия';
                
                log.innerHTML += `<div class="fight-log-entry neutral">Суддя 1: ${judge1.player}-${judge1.opponent} (${j1Winner})</div>`;
                log.innerHTML += `<div class="fight-log-entry neutral">Суддя 2: ${judge2.player}-${judge2.opponent} (${j2Winner})</div>`;
                log.innerHTML += `<div class="fight-log-entry neutral">Суддя 3: ${judge3.player}-${judge3.opponent} (${j3Winner})</div>`;
                
                // Підрахувати скільки суддів за кого
                let judgesForPlayer = 0;
                let judgesForOpponent = 0;
                let judgesDraw = 0;
                
                if (judge1.player > judge1.opponent) judgesForPlayer++;
                else if (judge1.opponent > judge1.player) judgesForOpponent++;
                else judgesDraw++;
                
                if (judge2.player > judge2.opponent) judgesForPlayer++;
                else if (judge2.opponent > judge2.player) judgesForOpponent++;
                else judgesDraw++;
                
                if (judge3.player > judge3.opponent) judgesForPlayer++;
                else if (judge3.opponent > judge3.player) judgesForOpponent++;
                else judgesDraw++;
                
                log.innerHTML += `<div class="fight-log-entry neutral" style="margin-top: 0.5rem; font-weight: bold;">Рішення: ${judgesForPlayer}-${judgesForOpponent}-${judgesDraw}</div>`;
                log.scrollTop = log.scrollHeight;
                
                // Визначити переможця за суддями
                if (judgesForPlayer >= 2) {
                    // Гравець виграв (одноголосно або роздільно)
                    const decision = judgesForPlayer === 3 ? 'одноголосним рішенням' : 'роздільним рішенням';
                    log.innerHTML += `<div class="fight-log-entry player" style="font-weight: bold; font-size: 1.1em; margin-top: 0.5rem;">🏆 ${player.firstName} перемагає ${decision}!</div>`;
                    
                    result = `ПЕРЕМОГА ${decision}!`;
                    icon = '🏆';
                    playerHP = 100; // Simulate win
                    opponentHP = 0;
                } else if (judgesForOpponent >= 2) {
                    // Опонент виграв
                    const decision = judgesForOpponent === 3 ? 'одноголосним рішенням' : 'роздільним рішенням';
                    log.innerHTML += `<div class="fight-log-entry opponent" style="font-weight: bold; font-size: 1.1em; margin-top: 0.5rem;">😞 ${opponent.firstName} перемагає ${decision}</div>`;
                    
                    result = `ПРОГРАШ ${decision}`;
                    icon = '😞';
                    playerHP = 0; // Simulate loss
                    opponentHP = 100;
                } else {
                    // Нічия (дуже рідко)
                    log.innerHTML += `<div class="fight-log-entry neutral" style="font-weight: bold; font-size: 1.1em; margin-top: 0.5rem;">🤝 НІЧИЯ за рішенням суддів!</div>`;
                    
                    result = 'НІЧИЯ!';
                    icon = '🤝';
                    playerHP = 50;
                    opponentHP = 50;
                }
                
                log.scrollTop = log.scrollHeight;
            } else {
                // Бій закінчився KO/TKO
                isKO = true;
            }
            
            // Визначити переможця (тепер вже після судейського рішення)
            if (playerHP > opponentHP) {
                if (!isKO) {
                    // Вже встановлено вище (рішення суддів)
                } else {
                    result = 'ПЕРЕМОГА!';
                    icon = '🏆';
                }
                
                // ПОКАЗАТИ ДЕТАЛЬНУ СТАТИСТИКУ
                if (fightStats && roundScores) {
                    console.log('📊 Calling showDetailedStats for WIN...');
                    showDetailedStats(fightStats, roundScores, player, opponent, 'win');
                    console.log('📊 showDetailedStats completed for WIN');
                    
                    // Перевіряємо чи ще є в логу
                    const logContent = document.getElementById('fightLog').innerHTML;
                    console.log('Log contains "СТАТИСТИКА"?', logContent.includes('СТАТИСТИКА'));
                    console.log('Log contains red marker?', logContent.includes('🔴'));
                }
                
                const baseCash = opponent.cashReward;
                cash = baseCash;
                
                // Apply MANAGER bonus first
                initializeTeam(characterData);
                const teamBonuses = getTeamBonuses(characterData);
                let managerBonus = 0;
                
                if (teamBonuses.fightEarnings > 0) {
                    const cashWithManager = Math.floor(cash * (1 + teamBonuses.fightEarnings));
                    managerBonus = cashWithManager - cash;
                    cash = cashWithManager;
                }
                
                // Check VIP status
                const isVIPActive = gameState.vipUntil && gameState.vipUntil > Date.now();
                let vipBonus = 0;
                let potentialVipBonus = 0;
                
                if (isVIPActive) {
                    // Apply VIP bonus (+15%)
                    const vipMultiplier = getVIPMultiplier('cash');
                    cash = Math.floor(baseCash * vipMultiplier);
                    vipBonus = cash - baseCash;
                } else {
                    // Calculate what VIP would give (+15%)
                    const potentialCash = Math.floor(baseCash * 1.15);
                    potentialVipBonus = potentialCash - baseCash;
                }
                
                gameState.cash += cash;
                gameState.totalWins = (gameState.totalWins || 0) + 1;
                
                // Track hard opponent wins
                if (opponent.difficulty === 'hard') {
                    gameState.hardWins = (gameState.hardWins || 0) + 1;
                }
                
                // Track win streak
                gameState.winStreak = (gameState.winStreak || 0) + 1;
                
                if (!fighter.gameData) fighter.gameData = {};
                if (!fighter.gameData.record) {
                    fighter.gameData.record = { wins: 0, losses: 0, draws: 0 };
                }
                if (!fighter.gameData.rating) fighter.gameData.rating = 0;
                
                fighter.gameData.record.wins++;
                
                // Use new ranking system
                updateRatingAfterWin(fighter, opponent);
                
                // Show rating change toast
                setTimeout(() => {
                    // Calculate same rating as updateRatingAfterWin
                    let ratingGained = 25;
                    if (opponent.isChampion) {
                        ratingGained = 50;
                    } else if (opponent.difficulty === 'hard') {
                        ratingGained = 50;
                    } else if (opponent.difficulty === 'easy') {
                        ratingGained = 15;
                    }
                    showToast(`📈 Рейтинг +${ratingGained}`, `Тепер: ${fighter.gameData.rating}`, 'success');
                }, 2000);
                
                // Award stars if it was championship fight
                if (opponent.starsReward) {
                    gameState.stars += opponent.starsReward;
                }
                
                // Calculate rating gain for display (same logic as updateRatingAfterWin)
                let displayRatingGain = 25;
                if (opponent.isChampion) {
                    displayRatingGain = 50;
                } else if (opponent.difficulty === 'hard') {
                    displayRatingGain = 50;
                } else if (opponent.difficulty === 'easy') {
                    displayRatingGain = 15;
                }
                
                // Store for result display
                fighter._lastFightRewards = {
                    cash: cash,
                    baseCash: baseCash,
                    ratingGain: displayRatingGain,
                    currentRating: fighter.gameData.rating,
                    vipBonus: vipBonus,
                    potentialVipBonus: potentialVipBonus,
                    managerBonus: managerBonus,
                    isVIPActive: isVIPActive,
                    starsReward: opponent.starsReward || 0,
                    beltWon: opponent.belt || null
                };
                
            } else if (opponentHP > playerHP) {
                result = 'ПОРАЗКА';
                icon = '😞';
                
                // ПОКАЗАТИ ДЕТАЛЬНУ СТАТИСТИКУ
                if (fightStats && roundScores) {
                    console.log('📊 Calling showDetailedStats for LOSS...');
                    showDetailedStats(fightStats, roundScores, player, opponent, 'loss');
                    console.log('📊 showDetailedStats completed for LOSS');
                    
                    const logContent = document.getElementById('fightLog').innerHTML;
                    console.log('Log contains "СТАТИСТИКА"?', logContent.includes('СТАТИСТИКА'));
                    console.log('Log contains red marker?', logContent.includes('🔴'));
                }
                
                // Reset win streak on loss
                gameState.winStreak = 0;
                
                if (!fighter.gameData) fighter.gameData = {};
                if (!fighter.gameData.record) {
                    fighter.gameData.record = { wins: 0, losses: 0, draws: 0 };
                }
                if (!fighter.gameData.rating) fighter.gameData.rating = 0;
                
                fighter.gameData.record.losses++;
                
                // Use new ranking system
                updateRatingAfterLoss(fighter, opponent);
                
                fighter._lastFightRewards = null;
                
            } else {
                result = 'НІЧИЯ';
                icon = '🤝';
                
                // ПОКАЗАТИ ДЕТАЛЬНУ СТАТИСТИКУ
                if (fightStats && roundScores) {
                    showDetailedStats(fightStats, roundScores, player, opponent, 'draw');
                }
                
                const baseCash = Math.floor(opponent.cashReward * 0.3);
                cash = baseCash;
                
                // Check VIP for draw
                const isVIPActive = gameState.isVIP && gameState.vipEndTime > Date.now();
                let vipBonus = 0;
                let potentialVipBonus = 0;
                
                if (isVIPActive) {
                    const vipMultiplier = getVIPMultiplier('cash');
                    cash = Math.floor(baseCash * vipMultiplier);
                    vipBonus = cash - baseCash;
                } else {
                    const potentialCash = Math.floor(baseCash * 1.15);
                    potentialVipBonus = potentialCash - baseCash;
                }
                
                gameState.cash += cash;
                
                if (!fighter.gameData) fighter.gameData = {};
                if (!fighter.gameData.record) {
                    fighter.gameData.record = { wins: 0, losses: 0, draws: 0 };
                }
                if (!fighter.gameData.rating) fighter.gameData.rating = 0;
                
                fighter.gameData.record.draws++;
                
                fighter._lastFightRewards = {
                    cash: cash,
                    baseCash: baseCash,
                    vipBonus: vipBonus,
                    potentialVipBonus: potentialVipBonus,
                    isVIPActive: isVIPActive
                };
            }
            
            // ADD FIGHT TO HISTORY
            if (!fighter.fightHistory) fighter.fightHistory = [];
            
            const fightResult = playerHP > opponentHP ? 'win' : (opponentHP > playerHP ? 'loss' : 'draw');
            fighter.fightHistory.push({
                date: Date.now(),
                opponentName: `${opponent.firstName} "${opponent.nickname}"`,
                difficulty: opponent.difficulty,
                result: fightResult
            });
            
            if (fighter.fightHistory.length > 50) {
                fighter.fightHistory = fighter.fightHistory.slice(-50);
            }
            
            // Set cooldown
            if (!fighter.fightCooldown) fighter.fightCooldown = {};
            fighter.fightCooldown.nextAvailable = Date.now() + (2 * 60 * 60 * 1000);
            
            // CHECK FOR INJURY
            const injury = checkForInjury(fighter, opponent.difficulty, fightResult);
            if (injury) {
                fighter.injury = injury;
                console.log('Fighter injured:', injury.name);
            }
            
            // Save
            saveGameSync(characterData);
            updateResourceBar(); // Update rating display after fight
            
            // Check achievements - wrapped in try-catch to prevent breaking
            try {
                if (typeof checkAchievements === 'function') {
                    checkAchievements(characterData);
                }
            } catch (error) {
                console.error('Achievement check error (non-critical):', error);
            }
            
            // === THIS IS THE WORKING CODE FROM TEST FILE ===
            console.log('HIDING simulation...');
            const simContent = document.getElementById('fightSimContent');
            console.log('simContent element:', simContent);
            simContent.style.display = 'none';
            console.log('simContent hidden! display =', simContent.style.display);
            
            console.log('SHOWING result...');
            const resultDiv = document.getElementById('fightResultDisplay');
            console.log('resultDiv element:', resultDiv);
            
            let rewardsHTML = '';
            if (fighter._lastFightRewards) {
                const rewards = fighter._lastFightRewards;
                
                rewardsHTML = `
                    ${rewards.beltWon ? `
                        <div style="background: linear-gradient(135deg, ${rewards.beltWon.color}20, ${rewards.beltWon.color}10); 
                                    border: 2px solid ${rewards.beltWon.color}; border-radius: 12px; 
                                    padding: 1.5rem; margin-bottom: 1.5rem; text-align: center; animation: pulse 0.5s;">
                            <div style="font-size: 3rem; margin-bottom: 0.5rem; 
                                        filter: drop-shadow(0 0 15px ${rewards.beltWon.color});">
                                ${rewards.beltWon.icon}
                            </div>
                            <div style="color: ${rewards.beltWon.color}; font-weight: 700; font-size: 1.3rem; margin-bottom: 0.3rem;">
                                НОВИЙ ЧЕМПІОН!
                            </div>
                            <div style="color: white; font-size: 1rem;">
                                ${rewards.beltWon.name}
                            </div>
                        </div>
                    ` : ''}
                    <div class="result-rewards">
                        ${rewards.cash > 0 ? `
                            <div class="reward-item">
                                <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                                    <span style="font-size: 1.2rem;">💵 +$${formatNumber(rewards.cash)}</span>
                                </div>
                                ${rewards.managerBonus > 0 ? `
                                    <div style="font-size: 0.85rem; color: #fbbf24; margin-top: 0.3rem;">
                                        👥 Менеджер: +$${formatNumber(rewards.managerBonus)}
                                    </div>
                                ` : ''}
                                ${rewards.isVIPActive ? `
                                    <div style="font-size: 0.85rem; color: var(--gold); margin-top: 0.3rem;">
                                        ⭐ VIP бонус: +$${formatNumber(rewards.vipBonus)}
                                    </div>
                                ` : `
                                    <div style="font-size: 0.8rem; color: rgba(255,215,0,0.6); margin-top: 0.3rem;">
                                        💎 З VIP: +$${formatNumber(rewards.potentialVipBonus)} більше
                                    </div>
                                `}
                            </div>
                        ` : ''}
                        ${rewards.ratingGain > 0 ? `<div class="reward-item">📈 Рейтинг +${rewards.ratingGain} (${rewards.currentRating})</div>` : ''}
                        ${rewards.starsReward > 0 ? `<div class="reward-item">⭐ +${rewards.starsReward}</div>` : ''}
                    </div>
                `;
            }
            
            resultDiv.innerHTML = `
                <div class="result-icon">${icon}</div>
                <div class="result-title">${result}</div>
                <div class="result-subtitle">vs ${opponent.firstName} "${opponent.nickname}"</div>
                ${rewardsHTML}
                <button class="continue-btn" onclick="closeFightResult()">
                    Продовжити
                </button>
            `;
            
            resultDiv.classList.add('show');
            console.log('Result classList:', resultDiv.classList);
            console.log('Result display:', window.getComputedStyle(resultDiv).display);
            console.log('=== RESULT SHOULD BE VISIBLE NOW ===');
            
            // Show injury modal if injured
            if (injury) {
                setTimeout(() => {
                    showToast(`❗ ТРАВМА! ${injury.name}`, 'error');
                    setTimeout(() => {
                        openTreatmentModal();
                    }, 1500);
                }, 2000);
            }
        }
        
        function closeFightResult() {
            // Check if belt was won
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (fighter._lastFightRewards && fighter._lastFightRewards.beltWon) {
                const belt = fighter._lastFightRewards.beltWon;
                
                // Show belt celebration toast
                setTimeout(() => {
                    showToast(`🏆 НОВИЙ ПОЯС! ${belt.name}!`, 'success');
                }, 500);
            }
            
            // Hide result
            document.getElementById('fightResultDisplay').classList.remove('show');
            
            // Show simulation content again (for next fight)
            document.getElementById('fightSimContent').style.display = 'block';
            
            // Go back to fights screen
            showScreen('fightsScreen');
            loadFightsScreen();
            
            // Check for random event after fight
            triggerRandomEventCheck();
        }
        
        // ===== RANDOM EVENTS SYSTEM =====
        
        function getModifiedStats(fighter) {
            const baseStats = { ...fighter.stats };
            const buffs = getActiveBuffs(fighter);
            
            if (buffs) {
                baseStats.power += buffs.power;
                baseStats.speed += buffs.speed;
                baseStats.stamina += buffs.stamina;
                baseStats.defense += buffs.defense;
            }
            
            return baseStats;
        }
        
        function getBuffsDisplay(fighter) {
            const buffs = getActiveBuffs(fighter);
            if (!buffs) return '';
            
            const buffItems = [];
            if (buffs.power > 0) buffItems.push(`💪 +${buffs.power}`);
            if (buffs.speed > 0) buffItems.push(`⚡ +${buffs.speed}`);
            if (buffs.stamina > 0) buffItems.push(`🫁 +${buffs.stamina}`);
            if (buffs.defense > 0) buffItems.push(`🛡️ +${buffs.defense}`);
            if (buffs.form > 0) buffItems.push(`✨ +${buffs.form}%`);
            
            return buffItems.join(' ');
        }
        
        function getSponsorDisplay(fighter) {
            const sponsorBonus = getSponsorBonus(fighter);
            if (sponsorBonus === 0) return '';
            
            return `💼 Спонсор: +${Math.round(sponsorBonus * 100)}% до заробітку`;
        }
        
        function triggerRandomEventCheck() {
            if (!shouldTriggerEvent()) return;
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const event = getRandomEvent(characterData);
            
            if (event) {
                setTimeout(() => showRandomEvent(event), 1000);
            }
        }
        
        function showRandomEvent(event) {
            const overlay = document.getElementById('eventOverlay');
            const icon = document.getElementById('eventIcon');
            const title = document.getElementById('eventTitle');
            const description = document.getElementById('eventDescription');
            const choices = document.getElementById('eventChoices');
            
            icon.textContent = event.icon;
            title.textContent = event.title;
            description.textContent = event.description;
            
            // Generate choice buttons
            choices.innerHTML = event.choices.map((choice, index) => `
                <button class="event-choice-btn" 
                        onclick="handleEventChoice('${event.id}', ${index})"
                        style="background: linear-gradient(135deg, #4ade80, #22c55e); 
                               color: white; 
                               border: none; 
                               padding: 1rem 1.5rem; 
                               border-radius: 12px; 
                               font-size: 1rem; 
                               font-weight: 600; 
                               cursor: pointer;
                               transition: all 0.3s;
                               box-shadow: 0 4px 15px rgba(74, 222, 128, 0.3);">
                    ${choice.text}
                </button>
            `).join('');
            
            overlay.style.display = 'flex';
            hapticMedium();
        }
        
        function handleEventChoice(eventId, choiceIndex) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const event = RANDOM_EVENTS[eventId];
            const choice = event.choices[choiceIndex];
            
            // Record event in history (for once-per-year events like birthday)
            if (!characterData.gameState.eventHistory) {
                characterData.gameState.eventHistory = {};
            }
            characterData.gameState.eventHistory[eventId] = Date.now();
            
            // Apply effects
            const specialResults = applyEventEffects(characterData, choice.effects);
            
            // Save
            saveGameSync(characterData);
            
            // Close event
            document.getElementById('eventOverlay').style.display = 'none';
            
            // Show result
            let resultMessage = choice.result;
            
            if (specialResults.injury) {
                resultMessage += '\n⚠️ Отримав травму!';
            }
            
            if (specialResults.dopingFailed) {
                resultMessage = '🚨 ДОПІНГ-ТЕСТ ПРОВАЛЕНО!\n\nШтраф: -$50,000\nРепутація: -5,000\nРейтинг: -200\n\nТвоя кар\'єра під загрозою!';
            }
            
            showToast(resultMessage, specialResults.dopingFailed ? 'error' : 'success');
            
            // Refresh current screen
            const currentScreen = document.querySelector('.screen.active');
            if (currentScreen) {
                const screenId = currentScreen.id;
                if (screenId === 'managerScreen') loadManagerScreen();
                if (screenId === 'fightsScreen') loadFightsScreen();
            }
        }
        
        // ===== END NEW FIGHT SYSTEM =====
        
        
        function openAcademy() {
            showScreen('academyScreen');
            currentAcademyTab = 'rookies';
            document.getElementById('academyTabRookies').classList.add('active');
            document.getElementById('academyTabMarket').classList.remove('active');
            loadAcademyScreen();
        }
        
        function openMarket() {
            showScreen('academyScreen');
            currentAcademyTab = 'market';
            document.getElementById('academyTabRookies').classList.remove('active');
            document.getElementById('academyTabMarket').classList.add('active');
            loadMarketScreen();
        }
        
        // ACADEMY SYSTEM
        let academyTimer = null;
        
        function loadAcademyScreen() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // Initialize academy data
            if (!gameState.academyData) {
                gameState.academyData = {
                    lastRefresh: Date.now(),
                    candidates: generateCandidates()
                };
                saveGameSync(characterData);
            }
            
            const academyData = gameState.academyData;
            const content = document.getElementById('academyContent');
            
            // Check if refresh is needed (3 days = 72 hours)
            const refreshTime = 3 * 24 * 60 * 60 * 1000; // 3 days
            const timeSinceRefresh = Date.now() - academyData.lastRefresh;
            
            let html = '';
            
            // Timer card
            if (timeSinceRefresh < refreshTime) {
                const remaining = refreshTime - timeSinceRefresh;
                html += `
                    <div class="academy-timer-card">
                        <div class="academy-timer-label">⏱️ Нові кандидати через:</div>
                        <div class="academy-timer-value" id="academyTimerDisplay">Завантаження...</div>
                        <button class="academy-refresh-button" onclick="refreshAcademyCandidates()">
                            🔄 ОНОВИТИ ЗАРАЗ ⭐ 30
                        </button>
                    </div>
                `;
            } else {
                html += `
                    <div class="academy-timer-card">
                        <div class="academy-timer-label">✨ Нові кандидати доступні!</div>
                        <button class="academy-refresh-button" onclick="autoRefreshAcademy()" style="background: linear-gradient(135deg, var(--gold), #FFA500); border: none; color: var(--dark-bg);">
                            🔄 ПОКАЗАТИ НОВИХ КАНДИДАТІВ
                        </button>
                    </div>
                `;
            }
            
            // Candidates
            html += `
                <div class="academy-candidates">
                    <div class="academy-candidates-title">🌟 Доступні кандидати</div>
                    ${academyData.candidates.map((candidate, idx) => createCandidateCard(candidate, idx, gameState)).join('')}
                </div>
            `;
            
            content.innerHTML = html;
            
            // Start timer if needed
            if (timeSinceRefresh < refreshTime) {
                startAcademyTimer(academyData.lastRefresh + refreshTime);
            }
        }
        
        function generateCandidates() {
            const firstNames = ['Іван', 'Максим', 'Олег', 'Дмитро', 'Андрій', 'Сергій', 'Артем', 'Віктор', 'Олександр'];
            const lastNames = ['Коваль', 'Петров', 'Сидоров', 'Мельник', 'Шевченко', 'Бойко', 'Іванов', 'Гончар', 'Ковальчук'];
            const nicknames = ['Буря', 'Залізний', 'Вогонь', 'Гром', 'Тінь', 'Хижак', 'Ураган', 'Молот', 'Швидкий'];
            const avatars = ['🥊', '👊', '💪'];
            
            const candidates = [];
            
            for (let i = 0; i < 3; i++) {
                // Generate talent (weighted random)
                let talent;
                const rand = Math.random();
                if (rand < 0.01) talent = 10; // 1% chance
                else if (rand < 0.05) talent = 9; // 4% chance
                else if (rand < 0.15) talent = 8; // 10% chance
                else if (rand < 0.30) talent = 7; // 15% chance
                else if (rand < 0.50) talent = 6; // 20% chance
                else if (rand < 0.70) talent = 5; // 20% chance
                else if (rand < 0.85) talent = 4; // 15% chance
                else talent = 3; // 15% chance
                
                const age = Math.floor(Math.random() * 3) + 16; // 16-18
                const weight = Math.floor(Math.random() * 15) + 65; // 65-79 (young fighters)
                
                // Balanced stats: високий талант = слабші старт (більший потенціал)
                // Такий самий принцип як і для стартових бійців
                const baseStats = 30 - (talent * 2); // Високий талант = слабкий старт
                const variance = 5;
                
                const candidate = {
                    firstName: firstNames[Math.floor(Math.random() * firstNames.length)],
                    lastName: lastNames[Math.floor(Math.random() * lastNames.length)],
                    nickname: nicknames[Math.floor(Math.random() * nicknames.length)],
                    avatar: avatars[Math.floor(Math.random() * avatars.length)],
                    age: age,
                    weight: weight,
                    talent: talent,
                    stats: {
                        power: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance))),
                        speed: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance))),
                        stamina: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance))),
                        defense: Math.max(5, Math.min(30, baseStats + Math.floor(Math.random() * variance)))
                    },
                    price: calculateCandidatePrice(talent)
                };
                
                candidates.push(candidate);
            }
            
            // Sort by talent (highest first)
            return candidates.sort((a, b) => b.talent - a.talent);
        }
        
        function calculateCandidatePrice(talent) {
            if (talent <= 4) return 3000;
            if (talent <= 6) return 10000;
            if (talent <= 8) return 25000;
            if (talent === 9) return 60000;
            return 150000; // talent 10
        }
        
        function createCandidateCard(candidate, index, gameState) {
            const avgStat = Math.floor((candidate.stats.power + candidate.stats.speed + candidate.stats.stamina + candidate.stats.defense) / 4);
            const canAfford = gameState.cash >= candidate.price;
            
            return `
                <div class="candidate-card">
                    <div class="candidate-header">
                        <div class="candidate-avatar">${candidate.avatar}</div>
                        <div class="candidate-info">
                            <div class="candidate-name">${candidate.firstName} "${candidate.nickname}" ${candidate.lastName}</div>
                            <div class="candidate-details">${candidate.age} років, ${candidate.weight} кг</div>
                        </div>
                        <div class="candidate-talent-badge">🔥 ${candidate.talent}</div>
                    </div>
                    
                    <div class="candidate-stats">
                        <div class="candidate-stat">
                            <div class="candidate-stat-label">Сила</div>
                            <div class="candidate-stat-value">${candidate.stats.power}</div>
                        </div>
                        <div class="candidate-stat">
                            <div class="candidate-stat-label">Швидкість</div>
                            <div class="candidate-stat-value">${candidate.stats.speed}</div>
                        </div>
                        <div class="candidate-stat">
                            <div class="candidate-stat-label">Витривалість</div>
                            <div class="candidate-stat-value">${candidate.stats.stamina}</div>
                        </div>
                        <div class="candidate-stat">
                            <div class="candidate-stat-label">Захист</div>
                            <div class="candidate-stat-value">${candidate.stats.defense}</div>
                        </div>
                    </div>
                    
                    <div class="candidate-price">
                        <div class="candidate-price-label">Вартість найму:</div>
                        <div class="candidate-price-value">💵 $${candidate.price.toLocaleString()}</div>
                    </div>
                    
                    <button class="candidate-hire-button" 
                            onclick="hireCandidate(${index})"
                            ${!canAfford ? 'disabled' : ''}>
                        ${!canAfford ? 'НЕДОСТАТНЬО ГРОШЕЙ' : 'НАЙНЯТИ'}
                    </button>
                </div>
            `;
        }
        
        function startAcademyTimer(endTime) {
            if (academyTimer) clearInterval(academyTimer);
            
            academyTimer = setInterval(() => {
                const remaining = Math.max(0, endTime - Date.now());
                
                if (remaining <= 0) {
                    clearInterval(academyTimer);
                    loadAcademyScreen();
                    return;
                }
                
                const days = Math.floor(remaining / (24 * 60 * 60 * 1000));
                const hours = Math.floor((remaining % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
                const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
                
                const timerEl = document.getElementById('academyTimerDisplay');
                if (timerEl) {
                    timerEl.textContent = `${days} дн ${hours} год ${minutes} хв`;
                }
            }, 1000);
        }
        
        function refreshAcademyCandidates() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // Check if enough stars
            if (gameState.stars < 30) {
                alert('❌ Недостатньо Stars!\n\nПотрібно: ⭐ 30\nУ тебе: ⭐ ' + gameState.stars);
                return;
            }
            
            // Deduct stars
            gameState.stars -= 30;
            
            // Generate new candidates
            gameState.academyData.candidates = generateCandidates();
            gameState.academyData.lastRefresh = Date.now();
            
            saveGameSync(characterData);
            
            alert('✨ Кандидати оновлені!\n\nНові таланти доступні!');
            
            if (academyTimer) clearInterval(academyTimer);
            loadAcademyScreen();
        }
        
        function autoRefreshAcademy() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // Generate new candidates (free auto-refresh)
            gameState.academyData.candidates = generateCandidates();
            gameState.academyData.lastRefresh = Date.now();
            
            saveGameSync(characterData);
            
            if (academyTimer) clearInterval(academyTimer);
            loadAcademyScreen();
        }
        
        function hireCandidate(index) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            const candidate = gameState.academyData.candidates[index];
            
            // Check if enough money
            if (gameState.cash < candidate.price) {
                showToast('Недостатньо грошей!', `Потрібно: $${candidate.price.toLocaleString()}\nУ тебе: $${gameState.cash.toLocaleString()}`, 'error');
                return;
            }
            
            // Check if has free slot
            const availableSlots = characterData.unlockedSlots || 1;
            const activeFighters = characterData.fighters.filter(f => !f.retired).length;
            
            if (activeFighters >= availableSlots) {
                showToast('Немає вільних слотів!', 'Розблокуй додатковий слот за ⭐ 100 Stars', 'warning');
                return;
            }
            
            // Show loading
            showLoading();
            
            // Deduct money
            gameState.cash -= candidate.price;
            
            // Initialize candidate as fighter
            candidate.gameData = {
                rating: 0,  // Починаємо з 0 рейтингу!
                form: calculateFormByAge(candidate.age),
                record: { wins: 0, losses: 0, draws: 0 }
            };
            candidate.agingData = {
                lastCheckDate: Date.now(),
                monthsPlayed: 0,
                birthdayMonth: new Date().getMonth()
            };
            
            // Add to fighters
            characterData.fighters.push(candidate);
            gameState.totalFighters++;
            
            // Set as active if first fighter or only active one is retired
            if (characterData.fighters.filter(f => !f.retired).length === 1) {
                characterData.activeFighterIndex = characterData.fighters.length - 1;
            }
            
            saveGameSync(characterData, true); // IMMEDIATE - критична транзакція!
            
            hideLoading();
            
            showToast('🎉 Боксер найнятий!', `${candidate.firstName} "${candidate.nickname}"\n🔥 Талант: ${candidate.talent}`, 'success');
            
            setTimeout(() => {
                backToGame();
            }, 1500);
        }
// MARKET FUNCTIONS TO ADD AFTER hireCandidate function

let currentAcademyTab = 'rookies';

function switchAcademyTab(tab) {
    currentAcademyTab = tab;
    document.getElementById('academyTabRookies').classList.toggle('active', tab === 'rookies');
    document.getElementById('academyTabMarket').classList.toggle('active', tab === 'market');
    
    if (tab === 'rookies') {
        loadAcademyScreen();
    } else {
        loadMarketScreen();
    }
}

function loadMarketScreen() {
    const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
    const gameState = characterData.gameState;
    
    if (!gameState.marketData || Date.now() - gameState.marketData.lastRefresh > 6 * 60 * 60 * 1000) {
        gameState.marketData = { lastRefresh: Date.now(), fighters: generateMarketFighters() };
        saveGameSync(characterData);
    }
    
    const content = document.getElementById('academyContent');
    const remaining = (gameState.marketData.lastRefresh + 6 * 60 * 60 * 1000) - Date.now();
    const hours = Math.floor(remaining / (60 * 60 * 1000));
    const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
    
    content.innerHTML = `
        <div class="academy-timer-card">
            <div class="academy-timer-label">💼 Список оновиться через: ${hours}г ${minutes}хв</div>
            <button class="academy-refresh-button" onclick="refreshMarket()">🔄 ОНОВИТИ ⭐ 50</button>
        </div>
        <div class="academy-candidates">
            <div class="academy-candidates-title">🥊 Доступні бійці</div>
            ${gameState.marketData.fighters.map((f, i) => createMarketCard(f, i, gameState)).join('')}
        </div>
    `;
}

function generateMarketFighters() {
    const names = ['Іван', 'Максим', 'Олег', 'Дмитро', 'Андрій'];
    const last = ['Коваль', 'Петров', 'Мельник', 'Бойко'];
    const nicks = ['Буря', 'Залізний', 'Вогонь', 'Гром', 'Тінь'];
    const ava = ['🥊', '👊', '💪'];
    
    return Array(3).fill().map(() => {
        // Weighted talent (Academy fighters are slightly better: 4-10)
        let talent;
        const rand = Math.random();
        if (rand < 0.02) {
            talent = 10; // 2% - legendary
        } else if (rand < 0.12) {
            talent = Math.random() < 0.5 ? 8 : 9; // 10% - rare
        } else if (rand < 0.40) {
            talent = Math.random() < 0.5 ? 6 : 7; // 28% - uncommon
        } else {
            talent = Math.random() < 0.5 ? 4 : 5; // 60% - common (4-5)
        }
        
        const age = Math.floor(Math.random() * 12) + 20;
        const overall = Math.floor(Math.random() * 200) + 150;
        
        return {
            firstName: names[Math.floor(Math.random() * names.length)],
            lastName: last[Math.floor(Math.random() * last.length)],
            nickname: nicks[Math.floor(Math.random() * nicks.length)],
            avatar: ava[Math.floor(Math.random() * ava.length)],
            age, weight: 65 + Math.floor(Math.random() * 30), talent,
            stats: { power: overall + Math.floor(Math.random() * 30), speed: overall + Math.floor(Math.random() * 30), 
                    stamina: overall + Math.floor(Math.random() * 30), defense: overall + Math.floor(Math.random() * 30) },
            gameData: { 
                rating: Math.floor(Math.random() * 300),  // 0-299 рейтинг для досвідчених
                record: { wins: 5 + Math.floor(Math.random() * 20), losses: Math.floor(Math.random() * 5), 
                         draws: Math.floor(Math.random() * 3) }, 
                form: 100 
            }
        };
    });
}

function createMarketCard(f, index, gameState) {
    const overall = Math.round((f.stats.power + f.stats.speed + f.stats.stamina + f.stats.defense) / 4);
    const price = calculateFighterPrice(f);
    const comm = Math.floor(price * 0.1);
    const total = price + comm;
    const canAfford = gameState.cash >= total;
    
    return `
        <div class="candidate-card">
            <div class="candidate-header">
                <div class="candidate-avatar">${f.avatar}</div>
                <div class="candidate-info">
                    <div class="candidate-name">${f.firstName} "${f.nickname}" ${f.lastName}</div>
                    <div class="candidate-details">${f.age} років, ${f.weight} кг</div>
                </div>
                <div class="candidate-talent-badge">🔥 ${f.talent}</div>
            </div>
            <div style="background: rgba(255,215,0,0.1); padding: 0.8rem; border-radius: 8px; margin: 1rem 0;">
                <div style="display: flex; justify-content: space-between;"><span>Оверол:</span><span style="color: var(--gold); font-weight: 700;">${overall}</span></div>
                <div style="display: flex; justify-content: space-between;"><span>Рекорд:</span><span>${f.gameData.record.wins}-${f.gameData.record.losses}-${f.gameData.record.draws}</span></div>
            </div>
            <div class="candidate-stats">
                <div class="candidate-stat"><div class="candidate-stat-label">💪</div><div class="candidate-stat-value">${f.stats.power}</div></div>
                <div class="candidate-stat"><div class="candidate-stat-label">⚡</div><div class="candidate-stat-value">${f.stats.speed}</div></div>
                <div class="candidate-stat"><div class="candidate-stat-label">🫁</div><div class="candidate-stat-value">${f.stats.stamina}</div></div>
                <div class="candidate-stat"><div class="candidate-stat-label">🛡️</div><div class="candidate-stat-value">${f.stats.defense}</div></div>
            </div>
            <div class="candidate-price">
                <div class="candidate-price-label">Вартість:</div>
                <div class="candidate-price-value">$${formatNumber(total)}</div>
                <div style="font-size: 0.8rem; opacity: 0.5;">($${formatNumber(price)} + $${formatNumber(comm)} комісія)</div>
            </div>
            <button class="candidate-hire-button" onclick="buyMarketFighter(${index})" ${!canAfford ? 'disabled' : ''}>
                ${!canAfford ? `ПОТРІБНО $${formatNumber(total)}` : `КУПИТИ`}
            </button>
        </div>
    `;
}

function buyMarketFighter(index) {
    const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
    const gameState = characterData.gameState;
    const f = gameState.marketData.fighters[index];
    
    const price = calculateFighterPrice(f);
    const total = price + Math.floor(price * 0.1);
    
    if (gameState.cash < total) { showToast('Недостатньо грошей! 💰', 'error'); return; }
    if (characterData.fighters.length >= (characterData.unlockedSlots || 1)) { 
        showToast('Всі слоти зайняті! ⚠️', 'error'); return; 
    }
    
    gameState.cash -= total;
    characterData.fighters.push(f);
    gameState.marketData.fighters.splice(index, 1);
    
    saveGameSync(characterData);
    
    showToast(`${f.firstName} "${f.nickname}" куплений! 🥊`, 'success');
    loadMarketScreen();
    loadGameData();
}

function refreshMarket() {
    const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
    const gameState = characterData.gameState;
    
    if (gameState.stars < 50) { showToast('Недостатньо зірок! Потрібно ⭐ 50', 'error'); return; }
    
    gameState.stars -= 50;
    gameState.marketData = { lastRefresh: Date.now(), fighters: generateMarketFighters() };
    saveGameSync(characterData);
    
    showToast('Список оновлено! 💼', 'success');
    loadMarketScreen();
}
        
        function openVIP() {
            showScreen('vipScreen');
            loadVIPScreen();
        }
        
        // ===== EMERGENCY RESET FUNCTION =====
        async function emergencyReset() {
            const confirmed = confirm(
                '⚠️ УВАГА! ПОВНЕ СКИДАННЯ!\n\n' +
                'Це видалить ВСІ дані:\n' +
                '✗ Всіх бійців\n' +
                '✗ Весь прогрес\n' +
                '✗ Гроші та зірки\n' +
                '✗ VIP статус\n' +
                '✗ З Telegram Cloud\n' +
                '✗ З localStorage\n\n' +
                'Гра почнеться ЗАНОВО!\n\n' +
                'Продовжити?'
            );
            
            if (!confirmed) return;
            
            const doubleConfirm = confirm('ТИ ВПЕВНЕНИЙ? Це НЕ МОЖНА ВІДМІНИТИ!');
            if (!doubleConfirm) return;
            
            console.log('🔥 EMERGENCY RESET INITIATED');
            
            try {
                // 1. Очистити localStorage
                localStorage.removeItem('boxingManager_character');
                console.log('✅ localStorage cleared');
                
                // 2. Очистити Telegram Cloud Storage (якщо доступний)
                if (tg.CloudStorage && typeof tg.CloudStorage.removeItem === 'function') {
                    // Видалити основний ключ
                    await new Promise((resolve) => {
                        tg.CloudStorage.removeItem('bm_character', (error) => {
                            if (error) console.error('Cloud remove error:', error);
                            else console.log('✅ Cloud cleared: bm_character');
                            resolve();
                        });
                    });
                    
                    // Видалити можливі частини
                    for (let i = 0; i < 10; i++) {
                        await new Promise((resolve) => {
                            tg.CloudStorage.removeItem(`bm_character_${i}`, () => resolve());
                        });
                    }
                    
                    // Видалити мета
                    await new Promise((resolve) => {
                        tg.CloudStorage.removeItem('bm_character_meta', () => resolve());
                    });
                    
                    console.log('✅ Telegram Cloud fully cleared');
                }
                
                // 3. Очистити кеш
                cachedCharacterData = null;
                cacheTimestamp = 0;
                lastSaveHash = null;
                
                alert('✅ ВСЕ ВИДАЛЕНО!\n\nГра перезавантажиться...');
                
                // 4. Перезавантажити
                setTimeout(() => window.location.reload(), 500);
                
            } catch (error) {
                console.error('❌ Reset error:', error);
                alert('❌ Помилка: ' + error.message);
            }
        }
        
        // VIP SYSTEM
        let vipTimer = null;
        
        const VIP_PACKAGES = [
            { days: 7, stars: 50, name: '7 ДНІВ' },
            { days: 30, stars: 150, name: '30 ДНІВ', recommended: true, save: 'Економія 50 Stars!' }
        ];
        
        const VIP_BENEFITS = [
            { icon: '🏋️', title: '+20% до тренувань', desc: 'Швидше прокачуй характеристики' },
            { icon: '💵', title: '+15% до заробітку', desc: 'Більше грошей за перемоги' },
            { icon: '⏱️', title: '-10% до часу', desc: 'Тренування проходять швидше' },
            { icon: '🎓', title: '+1 кандидат', desc: 'Додатковий боксер в академії' }
        ];
        
        function loadVIPScreen() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            const content = document.getElementById('vipContent');
            
            // Check if VIP is active
            const isVIPActive = gameState.vipEndTime && gameState.vipEndTime > Date.now();
            
            let html = '';
            
            // VIP Status Card
            if (isVIPActive) {
                html += `
                    <div class="vip-status-card vip-status-active">
                        <div class="vip-status-label">⭐ VIP АКТИВНИЙ</div>
                        <div class="vip-status-value">Активно</div>
                        <div class="vip-timer" id="vipTimerDisplay">Завантаження...</div>
                    </div>
                `;
            } else {
                html += `
                    <div class="vip-status-card">
                        <div class="vip-status-label">VIP Статус</div>
                        <div class="vip-status-value">Не активний</div>
                    </div>
                `;
            }
            
            // VIP Benefits
            html += `
                <div class="vip-benefits">
                    <div class="vip-benefits-title">💎 VIP Переваги</div>
            `;
            
            VIP_BENEFITS.forEach(benefit => {
                html += `
                    <div class="vip-benefit-item">
                        <div class="vip-benefit-icon">${benefit.icon}</div>
                        <div class="vip-benefit-text">
                            <div class="vip-benefit-title">${benefit.title}</div>
                            <div class="vip-benefit-desc">${benefit.desc}</div>
                        </div>
                    </div>
                `;
            });
            
            html += `</div>`;
            
            // VIP Packages
            html += `
                <div class="vip-packages">
                    <div class="vip-packages-title">⭐ Купити VIP</div>
            `;
            
            VIP_PACKAGES.forEach(pkg => {
                const hasEnoughStars = gameState.stars >= pkg.stars;
                
                html += `
                    <div class="vip-package ${pkg.recommended ? 'recommended' : ''}">
                        ${pkg.recommended ? '<div class="vip-package-badge">💎 ВИГІДНО</div>' : ''}
                        <div class="vip-package-duration">${pkg.name}</div>
                        <div class="vip-package-price">⭐ ${pkg.stars} Stars</div>
                        ${pkg.save ? `<div class="vip-package-save">${pkg.save}</div>` : ''}
                        <button class="vip-buy-button" 
                                onclick="buyVIP(${pkg.days}, ${pkg.stars})"
                                ${!hasEnoughStars || isVIPActive ? 'disabled' : ''}>
                            ${!hasEnoughStars ? 'НЕДОСТАТНЬО STARS' : isVIPActive ? 'VIP УЖЕ АКТИВНИЙ' : 'КУПИТИ VIP'}
                        </button>
                    </div>
                `;
            });
            
            html += `</div>`;
            
            // Note
            html += `
                <div class="vip-note">
                    VIP статус автоматично продовжує всі бонуси.<br>
                    Час VIP відраховується навіть офлайн.
                </div>
            `;
            
            content.innerHTML = html;
            
            // Start VIP timer if active
            if (isVIPActive) {
                startVIPTimer(gameState.vipEndTime);
            }
        }
        
        function buyVIP(days, stars) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            // Check if enough stars
            if (gameState.stars < stars) {
                showToast('Недостатньо Stars!', `Потрібно: ⭐ ${stars}\nУ тебе: ⭐ ${gameState.stars}`, 'error');
                return;
            }
            
            // Check if VIP already active
            if (gameState.vipEndTime && gameState.vipEndTime > Date.now()) {
                showToast('VIP вже активний!', '', 'info');
                return;
            }
            
            // Deduct stars
            gameState.stars -= stars;
            
            // Activate VIP (НОВИЙ ФОРМАТ!)
            const endTime = Date.now() + (days * 24 * 60 * 60 * 1000);
            gameState.vipUntil = endTime; // ✅ НОВИЙ формат
            
            saveGameSync(characterData, true); // IMMEDIATE - витрата Stars!
            
            showToast('🎉 VIP активовано!', `${days} днів VIP статусу\n🏋️ +20% тренування\n💵 +15% заробіток\n⏱️ -10% час`, 'success');
            
            loadVIPScreen();
            loadGameData(); // Оновити головний екран
        }
        
        function startVIPTimer(endTime) {
            if (vipTimer) clearInterval(vipTimer);
            
            vipTimer = setInterval(() => {
                const remaining = Math.max(0, endTime - Date.now());
                
                if (remaining <= 0) {
                    // VIP expired
                    clearInterval(vipTimer);
                    expireVIP();
                    return;
                }
                
                const days = Math.floor(remaining / (24 * 60 * 60 * 1000));
                const hours = Math.floor((remaining % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
                const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
                
                const timerEl = document.getElementById('vipTimerDisplay');
                if (timerEl) {
                    if (days > 0) {
                        timerEl.textContent = `${days} дн ${hours} год залишилось`;
                    } else {
                        timerEl.textContent = `${hours} год ${minutes} хв залишилось`;
                    }
                }
            }, 1000);
        }
        
        function expireVIP() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            gameState.isVIP = false;
            delete gameState.vipEndTime;
            
            saveGameSync(characterData);
            
            alert('⏰ VIP статус закінчився!\n\nБонуси деактивовані.\nПродовж VIP щоб отримати переваги знову!');
            
            // Reload VIP screen if open
            const vipScreen = document.getElementById('vipScreen');
            if (vipScreen.classList.contains('active')) {
                loadVIPScreen();
            }
            
            // Update game screen if open
            const gameScreen = document.getElementById('gameScreen');
            if (gameScreen.classList.contains('active')) {
                loadGameData();
            }
        }
        
        // Apply VIP bonuses
        function getVIPMultiplier(type) {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const gameState = characterData.gameState;
            
            console.log('=== VIP CHECK ===');
            console.log('vipUntil:', gameState.vipUntil);
            console.log('Current time:', Date.now());
            console.log('VIP active?', gameState.vipUntil > Date.now());
            
            // Check if VIP is active (НОВИЙ ФОРМАТ!)
            if (!gameState.vipUntil || gameState.vipUntil <= Date.now()) {
                console.log('VIP NOT ACTIVE - returning multiplier 1');
                return 1;
            }
            
            console.log('VIP ACTIVE - applying bonus for type:', type);
            
            switch(type) {
                case 'training':
                    console.log('Training multiplier: 1.2');
                    return 1.2; // +20%
                case 'cash':
                    console.log('Cash multiplier: 1.15');
                    return 1.15; // +15%
                case 'time':
                    console.log('Time multiplier: 0.9');
                    return 0.9; // -10%
                default:
                    return 1;
            }
        }
        
        // AGING SYSTEM
        function initializeAgingSystem() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            
            if (!characterData.fighters) return;
            
            // Initialize aging for all fighters
            characterData.fighters.forEach(fighter => {
                if (!fighter.agingData) {
                    fighter.agingData = {
                        lastCheckDate: Date.now(),
                        monthsPlayed: 0,
                        birthdayMonth: new Date().getMonth()
                    };
                }
                
                if (!fighter.gameData) {
                    fighter.gameData = {
                        form: calculateFormByAge(fighter.age),
                        rating: 1000,
                        record: { wins: 0, losses: 0, draws: 0 }
                    };
                }
            });
            
            saveGameSync(characterData);
            
            // Check aging every time game loads
            checkAging();
        }
        
        function checkAging() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            
            if (!characterData.fighters) return;
            
            characterData.fighters.forEach(fighter => {
                if (!fighter.agingData) return;
                
                const now = Date.now();
                const lastCheck = fighter.agingData.lastCheckDate;
                const monthsPassed = Math.floor((now - lastCheck) / (30 * 24 * 60 * 60 * 1000));
                
                if (monthsPassed >= 1) {
                    for (let i = 0; i < monthsPassed; i++) {
                        ageFighter(characterData, fighter);
                    }
                    
                    fighter.agingData.lastCheckDate = now;
                    fighter.agingData.monthsPlayed += monthsPassed;
                }
            });
            
            saveGameSync(characterData);
        }
        
        function ageFighter(characterData, fighter) {
            const oldAge = fighter.age;
            fighter.age += 1;
            
            // Calculate form based on age
            const newForm = calculateFormByAge(fighter.age);
            const oldForm = fighter.gameData.form;
            fighter.gameData.form = newForm;
            
            // Check for retirement (40-45 years)
            if (fighter.age >= 40 && fighter.age < 45) {
                const retirementChance = getRetirementChance(fighter.age);
                if (Math.random() < retirementChance) {
                    retireFighter(fighter);
                    return;
                }
            } else if (fighter.age >= 45) {
                retireFighter(fighter);
                return;
            }
            
            // Show birthday message
            let message = `🎂 День народження!\n\n${fighter.firstName} "${fighter.nickname}" ${fighter.lastName}\nТепер ${fighter.age} років\n\n`;
            
            if (newForm < oldForm) {
                message += `⚠️ Форма знизилась: ${oldForm}% → ${newForm}%\n`;
            } else if (newForm > oldForm) {
                message += `✨ Форма покращилась: ${oldForm}% → ${newForm}%\n`;
            } else {
                message += `💪 Форма залишається на піку: ${newForm}%\n`;
            }
            
            if (fighter.age === 33) {
                message += `\n⚠️ Боксер виходить із піку кар'єри. Форма почне падати.`;
            } else if (fighter.age === 37) {
                message += `\n🔴 Різке падіння форми! Форма падає швидше.`;
            } else if (fighter.age === 40) {
                message += `\n💔 НЕБЕЗПЕКА! Кар'єра може завершитися в будь-який момент!`;
            } else if (fighter.age >= 41) {
                message += `\n💔 КРИТИЧНО! Високий ризик завершення кар'єри!`;
            }
            
            alert(message);
        }
        
        function calculateFormByAge(age) {
            if (age <= 25) {
                // Growing: 80% at 18 → 100% at 25
                const yearsFromStart = age - 18;
                return Math.min(100, 80 + (yearsFromStart * 2));
            } else if (age <= 32) {
                // Peak: 100%
                return 100;
            } else if (age <= 36) {
                // Decline: -5% per year
                const yearsAfterPeak = age - 32;
                return Math.max(50, 100 - (yearsAfterPeak * 5));
            } else if (age <= 39) {
                // Steep decline: -10% per year
                const yearsAfterPeak = age - 32;
                const declineTo36 = 100 - (4 * 5); // 80% at 36
                const declineAfter36 = (age - 36) * 10;
                return Math.max(30, declineTo36 - declineAfter36);
            } else {
                // Critical: very low form
                const yearsAfterPeak = age - 32;
                const declineTo36 = 100 - (4 * 5); // 80% at 36
                const declineTo39 = declineTo36 - (3 * 10); // 50% at 39
                const declineAfter39 = (age - 39) * 10;
                return Math.max(20, declineTo39 - declineAfter39);
            }
        }
        
        function getRetirementChance(age) {
            // Retirement probability per month
            if (age === 40) return 0.10; // 10% per month
            if (age === 41 || age === 42) return 0.20; // 20% per month
            if (age === 43 || age === 44) return 0.40; // 40% per month
            return 1.0; // 100% at 45
        }
        
        function retireFighter(fighter) {
            const record = fighter.gameData.record;
            
            let message = `💔 ЗАВЕРШЕННЯ КАР'ЄРИ\n\n`;
            message += `${fighter.firstName} "${fighter.nickname}" ${fighter.lastName}\n`;
            message += `Вік: ${fighter.age} років\n\n`;
            message += `📊 ФІНАЛЬНА СТАТИСТИКА:\n`;
            message += `🏆 Перемоги: ${record.wins}\n`;
            message += `😞 Поразки: ${record.losses}\n`;
            message += `🤝 Нічиї: ${record.draws}\n`;
            message += `📈 Рейтинг: ${fighter.gameData.rating}\n\n`;
            
            if (fighter.age >= 45) {
                message += `Твій боксер досяг граничного віку.\n`;
            } else {
                message += `Твій боксер вирішив завершити кар'єру.\n`;
            }
            
            message += `\n🎓 Час шукати нового таланту в Академії!`;
            
            alert(message);
            
            // Mark fighter as retired
            fighter.retired = true;
            fighter.retirementDate = Date.now();
            
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            saveGameSync(characterData);
        }
        
        function applyFormToTraining(baseReward, form) {
            // Form affects training results
            const formMultiplier = form / 100;
            return Math.floor(baseReward * formMultiplier);
        }
        
        function applyFormToDamage(baseDamage, form) {
            // Form affects fight damage
            const formMultiplier = form / 100;
            return Math.floor(baseDamage * formMultiplier);
        }
        
        function openFighterDetails() {
            hapticMedium();
            showScreen('fighterStatsScreen');
            loadFighterStats();
        }
        
        function loadFighterStats() {
            const characterData = JSON.parse(localStorage.getItem('boxingManager_character'));
            const fighter = characterData.fighters[characterData.activeFighterIndex];
            
            if (!fighter) {
                showToast('Помилка!', 'Боксер не знайдений', 'error');
                backToGame();
                return;
            }
            
            // Fighter card header
            const card = document.getElementById('statsFighterCard');
            card.innerHTML = `
                <div class="stats-fighter-avatar">${fighter.avatar}</div>
                <div class="stats-fighter-info">
                    <div class="stats-fighter-name">${fighter.firstName} "${fighter.nickname}" ${fighter.lastName}</div>
                    <div class="stats-fighter-details">
                        <span>${fighter.age} років</span>
                        <span>${fighter.weight} кг</span>
                        <span>🔥 ${fighter.talent}</span>
                    </div>
                    <div class="stats-fighter-record">
                        ${fighter.gameData.record.wins}-${fighter.gameData.record.losses}-${fighter.gameData.record.draws}
                    </div>
                </div>
            `;
            
            // Stats content
            const content = document.getElementById('statsContent');
            
            // Calculate stats
            const totalFights = fighter.gameData.record.wins + fighter.gameData.record.losses + fighter.gameData.record.draws;
            const winRate = totalFights > 0 ? Math.round((fighter.gameData.record.wins / totalFights) * 100) : 0;
            const avgStat = Math.round((fighter.stats.power + fighter.stats.speed + fighter.stats.stamina + fighter.stats.defense) / 4);
            
            // Age status
            let ageStatus = '';
            let ageColor = '';
            if (fighter.age < 26) {
                ageStatus = '📈 Зростання';
                ageColor = '#4ade80';
            } else if (fighter.age < 33) {
                ageStatus = '✨ Пік';
                ageColor = '#fbbf24';
            } else if (fighter.age < 37) {
                ageStatus = '⚠️ Спад';
                ageColor = '#fb923c';
            } else {
                ageStatus = '🔴 Критично';
                ageColor = '#ef4444';
            }
            
            content.innerHTML = `
                <!-- Championship Belts -->
                ${fighter.belts && Object.keys(fighter.belts).length > 0 ? `
                    <div class="stats-section">
                        <div class="stats-section-title">🏆 Чемпіонські пояси</div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
                            ${Object.keys(fighter.belts).map(beltId => {
                                const belt = CHAMPIONSHIP_BELTS.find(b => b.id === beltId);
                                const beltData = fighter.belts[beltId];
                                if (!belt) return '';
                                
                                return `
                                    <div style="background: linear-gradient(135deg, ${belt.color}20, ${belt.color}10); 
                                                border: 2px solid ${belt.color}; border-radius: 12px; 
                                                padding: 1rem; text-align: center;">
                                        <div style="font-size: 2.5rem; margin-bottom: 0.5rem; 
                                                    filter: drop-shadow(0 0 10px ${belt.color});">
                                            ${belt.icon}
                                        </div>
                                        <div style="color: ${belt.color}; font-weight: 700; font-size: 0.9rem; margin-bottom: 0.3rem;">
                                            ${belt.name}
                                        </div>
                                        <div style="color: rgba(255,255,255,0.7); font-size: 0.75rem;">
                                            Захистів: ${beltData.defenses}
                                        </div>
                                        <div style="color: rgba(255,255,255,0.5); font-size: 0.7rem; margin-top: 0.3rem;">
                                            ${new Date(beltData.wonDate).toLocaleDateString('uk-UA')}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                ` : ''}
                
                <!-- Overview Stats -->
                <div class="stats-section">
                    <div class="stats-section-title">📊 Загальна інформація</div>
                    <div class="stats-grid">
                        <div class="stats-box highlight">
                            <div class="stats-box-label">Рейтинг</div>
                            <div class="stats-box-value">${fighter.gameData.rating}</div>
                        </div>
                        <div class="stats-box">
                            <div class="stats-box-label">Форма</div>
                            <div class="stats-box-value">${fighter.gameData.form}%</div>
                        </div>
                        <div class="stats-box">
                            <div class="stats-box-label">Всього боїв</div>
                            <div class="stats-box-value">${totalFights}</div>
                        </div>
                        <div class="stats-box">
                            <div class="stats-box-label">% перемог</div>
                            <div class="stats-box-value">${winRate}%</div>
                        </div>
                        <div class="stats-box">
                            <div class="stats-box-label">Середній стат</div>
                            <div class="stats-box-value">${avgStat}</div>
                        </div>
                        <div class="stats-box">
                            <div class="stats-box-label">Вік</div>
                            <div class="stats-box-value" style="color: ${ageColor}">${ageStatus}</div>
                        </div>
                    </div>
                </div>
                
                <!-- Fighting Stats -->
                <div class="stats-section">
                    <div class="stats-section-title">🥊 Бойові характеристики</div>
                    <div class="stats-bar-item">
                        <div class="stats-bar-header">
                            <span class="stats-bar-label">💪 Сила</span>
                            <span class="stats-bar-value">${fighter.stats.power}/1000</span>
                        </div>
                        <div class="stats-bar-container">
                            <div class="stats-bar-fill" style="width: ${(fighter.stats.power / 1000 * 100)}%"></div>
                        </div>
                    </div>
                    <div class="stats-bar-item">
                        <div class="stats-bar-header">
                            <span class="stats-bar-label">⚡ Швидкість</span>
                            <span class="stats-bar-value">${fighter.stats.speed}/1000</span>
                        </div>
                        <div class="stats-bar-container">
                            <div class="stats-bar-fill" style="width: ${(fighter.stats.speed / 1000 * 100)}%"></div>
                        </div>
                    </div>
                    <div class="stats-bar-item">
                        <div class="stats-bar-header">
                            <span class="stats-bar-label">🫁 Витривалість</span>
                            <span class="stats-bar-value">${fighter.stats.stamina}/1000</span>
                        </div>
                        <div class="stats-bar-container">
                            <div class="stats-bar-fill" style="width: ${(fighter.stats.stamina / 1000 * 100)}%"></div>
                        </div>
                    </div>
                    <div class="stats-bar-item">
                        <div class="stats-bar-header">
                            <span class="stats-bar-label">🛡️ Захист</span>
                            <span class="stats-bar-value">${fighter.stats.defense}/1000</span>
                        </div>
                        <div class="stats-bar-container">
                            <div class="stats-bar-fill" style="width: ${(fighter.stats.defense / 1000 * 100)}%"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Fight History -->
                <div class="stats-section">
                    <div class="stats-section-title">📜 Історія боїв</div>
                    ${generateFightHistory(fighter)}
                </div>
                
                <!-- Badges/Achievements -->
                <div class="stats-section">
                    <div class="stats-section-title">🏆 Досягнення</div>
                    ${generateBadges(fighter)}
                </div>
            `;
        }
        
        function generateFightHistory(fighter) {
            if (!fighter.fightHistory || fighter.fightHistory.length === 0) {
                return '<div class="stats-empty">📭 Історія боїв порожня<br>Проведи перший бій!</div>';
            }
            
            // Show last 10 fights
            const recentFights = fighter.fightHistory.slice(-10).reverse();
            
            return `
                <div class="fight-history-list">
                    ${recentFights.map(fight => {
                        const resultIcon = fight.result === 'win' ? '🏆' : fight.result === 'loss' ? '😞' : '🤝';
                        const date = new Date(fight.date).toLocaleDateString('uk-UA', { 
                            day: 'numeric', 
                            month: 'short' 
                        });
                        
                        return `
                            <div class="fight-history-item ${fight.result}">
                                <div class="fight-history-result">${resultIcon}</div>
                                <div class="fight-history-info">
                                    <div class="fight-history-opponent">
                                        vs ${fight.opponentName}
                                    </div>
                                    <div class="fight-history-date">${date} • ${fight.difficulty}</div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        function generateBadges(fighter) {
            const badges = [];
            const record = fighter.gameData.record;
            const totalFights = record.wins + record.losses + record.draws;
            
            // First Fight
            if (totalFights > 0) {
                badges.push({ icon: '🥊', label: 'Перший бій' });
            }
            
            // Win milestones
            if (record.wins >= 1) badges.push({ icon: '🥉', label: 'Перша перемога' });
            if (record.wins >= 10) badges.push({ icon: '🥈', label: '10 перемог' });
            if (record.wins >= 25) badges.push({ icon: '🥇', label: '25 перемог' });
            if (record.wins >= 50) badges.push({ icon: '👑', label: 'Чемпіон' });
            if (record.wins >= 100) badges.push({ icon: '⭐', label: 'Легенда' });
            
            // Perfect stats
            if (fighter.stats.power === 1000) badges.push({ icon: '💪', label: 'Майстер сили' });
            if (fighter.stats.speed === 1000) badges.push({ icon: '⚡', label: 'Блискавка' });
            if (fighter.stats.stamina === 1000) badges.push({ icon: '🫁', label: 'Залізні легені' });
            if (fighter.stats.defense === 1000) badges.push({ icon: '🛡️', label: 'Непробивний' });
            
            // Veteran
            if (fighter.age >= 35) badges.push({ icon: '🎖️', label: 'Ветеран' });
            
            // High talent
            if (fighter.talent >= 9) badges.push({ icon: '🔥', label: 'Вундеркінд' });
            
            if (badges.length === 0) {
                return '<div class="stats-empty">🏅 Досягнень поки немає<br>Проводь бої та тренуйся!</div>';
            }
            
            return `
                <div class="stats-badges">
                    ${badges.map(badge => `
                        <div class="stats-badge">
                            <span class="stats-badge-icon">${badge.icon}</span>
                            <span>${badge.label}</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        // Handle back button
        tg.BackButton.onClick(() => {
            const currentScreen = document.querySelector('.screen.active').id;
            
            if (currentScreen === 'characterScreen') {
                showPrologue();
            } else if (currentScreen === 'prologueScreen') {
                showScreen('loadingScreen');
            }
        });
        
        // Show back button on character screen
        const observer = new MutationObserver(() => {
            const characterScreen = document.getElementById('characterScreen');
            if (characterScreen.classList.contains('active')) {
                tg.BackButton.show();
            } else {
                tg.BackButton.hide();
            }
        });
        
        observer.observe(document.getElementById('characterScreen'), {
            attributes: true,
            attributeFilter: ['class']
        });
        
        // ===== GAME INITIALIZATION =====
        
        // Async initialization on page load
        (async function initializeGame() {
            console.log('🎮 Game initializing...');
            
            try {
                // Спробувати завантажити з Cloud
                let result = await gameStorage.loadCharacter();
                
                // Якщо Cloud не дав результат, спробувати localStorage
                if (!result.data) {
                    const localData = localStorage.getItem('boxingManager_character');
                    if (localData) {
                        result = {
                            data: JSON.parse(localData),
                            source: 'local_direct'
                        };
                        console.log('📦 Loaded from localStorage (direct)');
                    }
                }
                
                if (result.data) {
                    console.log(`✅ Game loaded from ${result.source}`);
                    console.log('📊 Data structure:', {
                        hasFighters: !!(result.data.fighters),
                        fightersLength: result.data.fighters?.length,
                        fightersData: result.data.fighters
                    });
                    
                    // Зберегти в localStorage для sync доступу
                    localStorage.setItem('boxingManager_character', JSON.stringify(result.data));
                    
                    // Перевірити чи гра завершена (є боєць)
                    if (result.data.fighters && result.data.fighters.length > 0) {
                        console.log('✅ Returning player - loading game...');
                        
                        // Cancel intro sequence for returning players
                        cancelIntroSequence();
                        
                        // ОДРАЗУ оновити ім'я З ДАНИХ (ще до показу екрану)
                        if (result.data.name) {
                            console.log('🔧 Setting manager name IMMEDIATELY:', result.data.name);
                            // Використовуємо setTimeout(0) щоб гарантувати що DOM готовий
                            setTimeout(() => {
                                const nameElement = document.getElementById('managerName');
                                if (nameElement) {
                                    nameElement.textContent = result.data.name;
                                    console.log('✅ Manager name set:', result.data.name);
                                } else {
                                    console.error('❌ managerName element not found!');
                                }
                            }, 0);
                        }
                        
                        // Показати головний екран
                        showScreen('gameScreen');
                        
                        // Завантажити решту даних (async)
                        await loadGameData();
                        
                        // Welcome message вимкнено - не дратує користувача
                        // Можна включити якщо потрібно:
                        // setTimeout(() => {
                        //     const telegramUser = tg.initDataUnsafe?.user;
                        //     const userName = telegramUser ? telegramUser.first_name : result.data.name;
                        //     showToast(`👋 З поверненням, ${userName}!`, '', 'success');
                        // }, 1000);
                    } else {
                        console.log('ℹ️ Player data exists but no fighters - showing intro...');
                        console.log('   fighters:', result.data.fighters);
                        // Дані є, але немає бійців - показати інтро
                        startIntroSequence(); // Start intro for incomplete registration
                    }
                } else {
                    console.log('ℹ️ No saved data found - new game');
                    // Немає збережених даних - показати інтро
                    startIntroSequence(); // Start intro for new players
                }
                
                // Update Cloud status
                updateCloudStatus();
                
            } catch (error) {
                console.error('Initialization error:', error);
                
                // Fallback: спробувати localStorage при помилці
                try {
                    const localData = localStorage.getItem('boxingManager_character');
                    if (localData) {
                        const data = JSON.parse(localData);
                        if (data.fighters && data.fighters.length > 0) {
                            console.log('⚠️ Error but found localStorage - loading...');
                            cancelIntroSequence(); // Cancel intro
                            
                            // Оновити ім'я ОДРАЗУ
                            if (data.name) {
                                setTimeout(() => {
                                    const nameElement = document.getElementById('managerName');
                                    if (nameElement) {
                                        nameElement.textContent = data.name;
                                        console.log('✅ Manager name set (fallback):', data.name);
                                    }
                                }, 0);
                            }
                            
                            showScreen('gameScreen'); // Показати екран
                            await loadGameData(); // Завантажити решту
                            return;
                        }
                    }
                } catch (e) {
                    console.error('Fallback error:', e);
                }
                
                showToast('⚠️ Помилка', 'Не вдалось завантажити дані', 'warning');
                // Показати інтро при помилці
                startIntroSequence();
            }
        })();
    
</script>

    <!-- TRAINING SCREEN -->
</body>
</html>
